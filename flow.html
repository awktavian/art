<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üåä FLOW ‚Äî e‚ÇÉ ‚Äî The Swallowtail Gallery</title>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@400;500;700&family=Fira+Code:wght@400;500&family=Inter:wght@300;400;500&display=swap" rel="stylesheet">
    
    <style>
/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   FLOW GALLERY ‚Äî ALL STYLES COMBINED
   üåä e‚ÇÉ ‚Äî The Swallowtail Catastrophe ‚Äî A‚ÇÑ
   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */

:root {
    --ocean-deep: #001F3F;
    --ocean: #003366;
    --teal: #008B8B;
    --cyan: #00CED1;
    --aqua: #00FFFF;
    --foam: #E0FFFF;
    --seafoam: #98FF98;
    --healing-green: #00FF7F;
    --error-red: #FF6B6B;
    --warning-amber: #FFB347;
    --info-blue: #6BB3FF;
    --void: #0A0A0F;
    --void-deep: #050508;
    --flow-dark: #0A1015;
    --nav-height: 70px;
}

*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
html { scroll-behavior: smooth; }

body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    background: var(--void);
    color: var(--foam);
    line-height: 1.6;
    overflow-x: hidden;
    -webkit-font-smoothing: antialiased;
}

::-webkit-scrollbar { width: 8px; }
::-webkit-scrollbar-track { background: var(--void); }
::-webkit-scrollbar-thumb { background: linear-gradient(180deg, var(--cyan) 0%, var(--ocean) 100%); border-radius: 4px; }
::selection { background: rgba(0, 206, 209, 0.4); color: var(--foam); }

/* Navigation */
.flow-nav {
    position: fixed; top: 0; left: 0; right: 0; height: var(--nav-height);
    display: flex; align-items: center; justify-content: space-between; padding: 0 30px;
    background: linear-gradient(180deg, rgba(10,10,15,0.98) 0%, rgba(10,10,15,0.9) 70%, rgba(10,10,15,0) 100%);
    z-index: 1000; backdrop-filter: blur(8px);
}

.nav-logo { display: flex; align-items: center; gap: 12px; font-family: 'Quicksand', sans-serif; font-size: 1.6rem; font-weight: 700; letter-spacing: 0.08em; }
.nav-logo .wave { font-size: 1.8rem; filter: drop-shadow(0 0 10px rgba(0, 206, 209, 0.7)); animation: wave-flow 3s ease-in-out infinite; }
@keyframes wave-flow { 0%, 100% { transform: translateY(0) rotate(0deg); filter: drop-shadow(0 0 10px rgba(0, 206, 209, 0.7)); } 25% { transform: translateY(-3px) rotate(-5deg); } 50% { transform: translateY(0) rotate(0deg); filter: drop-shadow(0 0 15px rgba(0, 255, 255, 0.9)); } 75% { transform: translateY(3px) rotate(5deg); } }
.nav-logo .logo-text { color: var(--cyan); text-shadow: 0 0 15px rgba(0, 206, 209, 0.5); }
.nav-logo .e-label { font-family: 'Fira Code', monospace; font-size: 0.85rem; color: var(--teal); opacity: 0.7; }
.nav-links { display: flex; gap: 35px; }
.nav-links a { font-family: 'Fira Code', monospace; font-size: 0.85rem; color: rgba(224, 255, 255, 0.6); text-decoration: none; letter-spacing: 0.1em; transition: all 0.25s ease; position: relative; }
.nav-links a::after { content: ''; position: absolute; bottom: -5px; left: 0; width: 0; height: 2px; background: linear-gradient(90deg, var(--cyan), var(--seafoam)); transition: width 0.25s ease; }
.nav-links a:hover { color: var(--cyan); text-shadow: 0 0 10px rgba(0, 206, 209, 0.5); }
.nav-links a:hover::after { width: 100%; }
.sound-toggle { background: none; border: 1px solid rgba(0, 206, 209, 0.3); border-radius: 50%; width: 42px; height: 42px; cursor: pointer; font-size: 1.2rem; display: flex; align-items: center; justify-content: center; transition: all 0.25s ease; }
.sound-toggle:hover { border-color: var(--cyan); box-shadow: 0 0 15px rgba(0, 206, 209, 0.3); transform: scale(1.1); }

/* Room Base */
.room { min-height: 100vh; position: relative; }

/* Buttons & Sliders */
.flow-btn { font-family: 'Fira Code', monospace; font-size: 0.9rem; padding: 15px 35px; border: 2px solid var(--cyan); border-radius: 20px; background: rgba(0, 206, 209, 0.1); color: var(--cyan); cursor: pointer; transition: all 0.25s ease; display: flex; align-items: center; gap: 10px; letter-spacing: 0.05em; }
.flow-btn:hover { background: var(--cyan); color: var(--void); box-shadow: 0 0 25px rgba(0, 206, 209, 0.5), 0 0 50px rgba(0, 206, 209, 0.25); transform: translateY(-3px); }
.flow-btn.healing { border-color: var(--healing-green); background: rgba(0, 255, 127, 0.1); color: var(--healing-green); }
.flow-btn.healing:hover { background: var(--healing-green); color: var(--void); box-shadow: 0 0 25px rgba(0, 255, 127, 0.5); }
.flow-slider { -webkit-appearance: none; appearance: none; width: 100%; height: 8px; background: linear-gradient(90deg, var(--ocean-deep) 0%, var(--cyan) 50%, var(--aqua) 100%); border-radius: 10px; outline: none; cursor: pointer; }
.flow-slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 24px; height: 24px; background: radial-gradient(circle at 30% 30%, var(--foam), var(--cyan) 70%); border-radius: 50%; cursor: grab; box-shadow: 0 0 15px rgba(0, 206, 209, 0.6), 0 2px 8px rgba(0,0,0,0.5); transition: transform 0.15s, box-shadow 0.15s; }
.flow-slider::-webkit-slider-thumb:hover { transform: scale(1.15); box-shadow: 0 0 25px rgba(0, 255, 255, 0.8), 0 0 50px rgba(0, 206, 209, 0.3); }

/* ROOM I: THE CURRENT */
#room-current { background: linear-gradient(180deg, var(--void) 0%, var(--flow-dark) 50%, rgba(0, 206, 209, 0.03) 100%); display: flex; align-items: center; justify-content: center; position: relative; overflow: hidden; }
#room-current::before { content: ''; position: absolute; inset: 0; background: radial-gradient(ellipse 70% 50% at 50% 100%, rgba(0, 206, 209, 0.1) 0%, transparent 60%); pointer-events: none; }
#current-canvas { position: absolute; inset: 0; pointer-events: auto; }
.current-content { position: relative; z-index: 1; text-align: center; width: 100%; max-width: 900px; padding: 120px 40px 80px; pointer-events: none; }
.current-content > * { pointer-events: auto; }
.current-hero { margin-bottom: 80px; }
.flow-title { font-family: 'Quicksand', sans-serif; font-size: clamp(5rem, 15vw, 10rem); font-weight: 700; letter-spacing: 0.1em; color: var(--cyan); text-shadow: 0 0 40px rgba(0, 206, 209, 0.6), 0 0 80px rgba(0, 206, 209, 0.3), 0 4px 0 var(--ocean-deep); margin: 0; line-height: 1; }
.flow-subtitle { display: flex; align-items: center; justify-content: center; gap: 20px; margin-top: 20px; margin-bottom: 30px; }
.flow-subtitle .kanji { font-size: 3rem; color: var(--aqua); text-shadow: 0 0 20px rgba(0, 255, 255, 0.5); }
.flow-subtitle .label { font-family: 'Fira Code', monospace; font-size: 0.9rem; color: var(--teal); letter-spacing: 0.15em; text-transform: uppercase; }
.flow-manifesto { font-family: 'Inter', sans-serif; font-size: 1.2rem; font-weight: 300; color: rgba(224, 255, 255, 0.8); line-height: 1.7; max-width: 600px; margin: 0 auto; }
.flow-manifesto em { color: var(--aqua); font-style: normal; }
.debug-stream { position: relative; margin: 60px auto; }
.stream-container { width: 100%; height: 100px; position: relative; border: 1px solid rgba(0, 206, 209, 0.2); border-radius: 12px; background: rgba(0, 0, 0, 0.3); overflow: hidden; }
.error-particle { position: absolute; padding: 8px 12px; font-family: 'Fira Code', monospace; font-size: 0.75rem; border-radius: 4px; animation: float-error 5s ease-in-out infinite; pointer-events: none; }
.error-particle[data-type="error"] { background: rgba(255, 107, 107, 0.2); border: 1px solid var(--error-red); color: var(--error-red); left: 20%; top: 30%; }
.error-particle[data-type="warning"] { background: rgba(255, 179, 71, 0.2); border: 1px solid var(--warning-amber); color: var(--warning-amber); left: 50%; top: 50%; animation-delay: 0.5s; }
.error-particle[data-type="info"] { background: rgba(107, 179, 255, 0.2); border: 1px solid var(--info-blue); color: var(--info-blue); left: 75%; top: 25%; animation-delay: 1s; }
@keyframes float-error { 0%, 100% { transform: translate(0, 0) rotate(0deg); } 25% { transform: translate(10px, -10px) rotate(2deg); } 50% { transform: translate(20px, 5px) rotate(-1deg); } 75% { transform: translate(5px, 10px) rotate(1deg); } }
.stream-stats { display: flex; justify-content: center; gap: 40px; margin-top: 20px; }
.stat { font-family: 'Fira Code', monospace; font-size: 0.9rem; color: var(--teal); }
.stat span { color: var(--cyan); font-weight: 700; }
.scroll-indicator { position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%); display: flex; flex-direction: column; align-items: center; gap: 10px; color: var(--teal); font-family: 'Fira Code', monospace; font-size: 0.8rem; opacity: 0.5; animation: scroll-bounce 2s ease-in-out infinite; }
.scroll-indicator span:first-child { font-size: 1.5rem; }
.scroll-text { letter-spacing: 0.1em; }
@keyframes scroll-bounce { 0%, 100% { transform: translateX(-50%) translateY(0); } 50% { transform: translateX(-50%) translateY(10px); } }

/* ROOM II: THE SWALLOWTAIL */
#room-swallowtail { background: linear-gradient(180deg, rgba(0, 206, 209, 0.02) 0%, var(--void) 20%, var(--void) 80%, rgba(0, 206, 209, 0.02) 100%); padding: 120px 40px; display: flex; align-items: center; justify-content: center; }
.swallowtail-content { max-width: 900px; width: 100%; }
.swallowtail-header { text-align: center; margin-bottom: 50px; }
.swallowtail-header h2 { font-family: 'Quicksand', sans-serif; font-size: clamp(2.5rem, 8vw, 4rem); font-weight: 700; letter-spacing: 0.1em; color: var(--cyan); text-shadow: 0 0 30px rgba(0, 206, 209, 0.5); margin: 0 0 15px; }
.math-formula { font-family: 'Fira Code', monospace; font-size: 1.2rem; color: var(--aqua); text-shadow: 0 0 10px rgba(0, 255, 255, 0.3); margin-bottom: 10px; }
.catastrophe-label { font-family: 'Inter', sans-serif; font-size: 0.9rem; color: var(--teal); letter-spacing: 0.05em; }
.swallowtail-visualization { position: relative; margin-bottom: 40px; }
#swallowtail-canvas { width: 100%; height: 400px; border-radius: 12px; border: 1px solid rgba(0, 206, 209, 0.2); background: rgba(10, 10, 15, 0.8); box-shadow: 0 0 40px rgba(0, 206, 209, 0.1), inset 0 0 60px rgba(0, 0, 0, 0.5); }
.swallowtail-controls { display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin-bottom: 40px; }
@media (max-width: 700px) { .swallowtail-controls { grid-template-columns: 1fr; } }
.param-group { padding: 20px; background: rgba(0, 206, 209, 0.05); border-radius: 8px; border: 1px solid rgba(0, 206, 209, 0.1); }
.param-group label { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; font-family: 'Fira Code', monospace; font-size: 0.85rem; color: var(--teal); }
.param-group .value { color: var(--cyan); font-weight: 700; }
.swallowtail-description { text-align: center; padding: 30px; background: rgba(0, 206, 209, 0.03); border-radius: 12px; border-left: 3px solid var(--cyan); }
.swallowtail-description p { font-family: 'Inter', sans-serif; font-size: 1.05rem; line-height: 1.8; color: rgba(224, 255, 255, 0.8); margin: 0; }
.swallowtail-description em { color: var(--aqua); font-style: normal; }

/* ROOM III: THE RECOVERY */
#room-recovery { background: linear-gradient(180deg, var(--void) 0%, rgba(0, 206, 209, 0.02) 50%, rgba(0, 255, 127, 0.03) 100%); padding: 120px 40px; display: flex; align-items: center; justify-content: center; position: relative; }
.recovery-content { max-width: 900px; width: 100%; }
.recovery-header { text-align: center; margin-bottom: 50px; }
.recovery-header h2 { font-family: 'Quicksand', sans-serif; font-size: clamp(2.5rem, 8vw, 4rem); font-weight: 700; letter-spacing: 0.1em; color: var(--healing-green); text-shadow: 0 0 30px rgba(0, 255, 127, 0.5); margin: 0 0 10px; }
.recovery-tagline { font-family: 'Inter', sans-serif; font-size: 1rem; color: var(--teal); font-style: italic; }
.recovery-arena { position: relative; margin-bottom: 40px; height: 350px; }
#recovery-canvas { position: absolute; inset: 0; width: 100%; height: 100%; border-radius: 12px; border: 1px solid rgba(0, 206, 209, 0.2); background: rgba(10, 10, 15, 0.9); }
#error-pool { position: absolute; inset: 0; pointer-events: auto; }
.recovery-controls { display: flex; justify-content: center; gap: 20px; margin-bottom: 40px; }
.recovery-log { background: rgba(0, 0, 0, 0.5); border: 1px solid rgba(0, 206, 209, 0.2); border-radius: 12px; overflow: hidden; }
.log-header { background: rgba(0, 206, 209, 0.1); padding: 12px 20px; font-family: 'Fira Code', monospace; font-size: 0.85rem; color: var(--cyan); letter-spacing: 0.1em; border-bottom: 1px solid rgba(0, 206, 209, 0.2); }
.log-content { height: 150px; overflow-y: auto; padding: 15px 20px; font-family: 'Fira Code', monospace; font-size: 0.8rem; }
.log-entry { padding: 5px 0; border-bottom: 1px solid rgba(255, 255, 255, 0.05); animation: log-fade-in 0.3s ease; }
@keyframes log-fade-in { from { opacity: 0; transform: translateX(-10px); } to { opacity: 1; transform: translateX(0); } }
.log-entry.info { color: var(--info-blue); }
.log-entry.error { color: var(--error-red); }
.log-entry.warn { color: var(--warning-amber); }
.log-entry.heal { color: var(--healing-green); }
.log-entry.success { color: var(--seafoam); }
.log-entry.debug { color: var(--teal); }
.error-bug { animation: bug-wobble 2s ease-in-out infinite; }
.error-bug:hover { transform: translate(-50%, -50%) scale(1.1); z-index: 10; }
@keyframes bug-wobble { 0%, 100% { transform: translate(-50%, -50%) rotate(-2deg); } 50% { transform: translate(-50%, -50%) rotate(2deg); } }

/* ROOM IV: THE ADAPTATION */
#room-adaptation { background: linear-gradient(180deg, rgba(0, 255, 127, 0.02) 0%, var(--void) 30%, var(--void) 100%); padding: 120px 40px; }
.adaptation-content { max-width: 1000px; margin: 0 auto; }
.adaptation-header { text-align: center; margin-bottom: 60px; }
.adaptation-header h2 { font-family: 'Quicksand', sans-serif; font-size: clamp(2.5rem, 8vw, 4rem); font-weight: 700; letter-spacing: 0.1em; color: var(--foam); text-shadow: 0 0 20px rgba(224, 255, 255, 0.3); margin: 0 0 10px; }
.adaptation-header .tagline { font-family: 'Inter', sans-serif; font-size: 1rem; color: var(--teal); font-style: italic; }
.flow-psychology { margin-bottom: 60px; }
.psychology-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 25px; }
@media (max-width: 768px) { .psychology-grid { grid-template-columns: 1fr; } }
.psych-card { background: rgba(0, 206, 209, 0.03); border: 1px solid rgba(0, 206, 209, 0.1); border-radius: 12px; padding: 30px; transition: all 0.3s ease; opacity: 0; transform: translateY(30px); }
.psych-card.visible { opacity: 1; transform: translateY(0); }
.psych-card:hover { background: rgba(0, 206, 209, 0.08); border-color: rgba(0, 206, 209, 0.3); box-shadow: 0 10px 40px rgba(0, 206, 209, 0.1); transform: translateY(-5px); }
.psych-card h3 { font-family: 'Quicksand', sans-serif; font-size: 1.1rem; font-weight: 700; color: var(--cyan); letter-spacing: 0.06em; margin: 0 0 15px; display: flex; align-items: center; gap: 10px; }
.psych-card .icon { font-size: 1.3rem; }
.psych-card p { font-family: 'Inter', sans-serif; font-size: 0.95rem; line-height: 1.7; color: rgba(224, 255, 255, 0.7); margin: 0; }
.psych-card em { color: var(--aqua); font-style: normal; }
.signature-traits { text-align: center; margin-bottom: 60px; }
.signature-traits h3 { font-family: 'Quicksand', sans-serif; font-size: 1.2rem; font-weight: 700; color: var(--foam); letter-spacing: 0.15em; margin-bottom: 25px; }
.traits-list { display: flex; flex-wrap: wrap; justify-content: center; gap: 15px; }
.trait { font-family: 'Fira Code', monospace; font-size: 0.8rem; padding: 10px 20px; background: rgba(0, 206, 209, 0.1); border: 1px solid rgba(0, 206, 209, 0.2); border-radius: 20px; color: var(--cyan); letter-spacing: 0.08em; transition: all 0.25s ease; cursor: pointer; }
.trait:hover { background: rgba(0, 206, 209, 0.2); border-color: var(--cyan); box-shadow: 0 0 15px rgba(0, 206, 209, 0.3); transform: scale(1.05); }
.flow-quote { text-align: center; padding: 40px; background: linear-gradient(135deg, rgba(0, 206, 209, 0.05) 0%, rgba(0, 255, 127, 0.02) 100%); border-radius: 16px; border-left: 4px solid var(--cyan); }
.flow-quote blockquote { font-family: 'Inter', sans-serif; font-size: 1.2rem; font-weight: 300; font-style: italic; line-height: 1.8; color: rgba(224, 255, 255, 0.85); margin: 0 0 20px; }
.flow-quote cite { font-family: 'Fira Code', monospace; font-size: 0.85rem; color: var(--cyan); font-style: normal; }

/* Footer */
.flow-footer { background: linear-gradient(180deg, var(--void) 0%, rgba(0, 206, 209, 0.02) 50%, var(--void-deep) 100%); padding: 60px 40px; border-top: 1px solid rgba(0, 206, 209, 0.1); }
.footer-content { max-width: 800px; margin: 0 auto; text-align: center; }
.colony-badge { font-family: 'Quicksand', sans-serif; font-size: 1.4rem; font-weight: 700; color: var(--cyan); letter-spacing: 0.12em; margin-bottom: 15px; display: flex; align-items: center; justify-content: center; gap: 12px; }
.colony-badge .wave { font-size: 1.6rem; filter: drop-shadow(0 0 8px rgba(0, 206, 209, 0.6)); }
.colony-badge .divider { color: rgba(224, 255, 255, 0.2); }
.footer-tagline { font-family: 'Fira Code', monospace; font-size: 0.85rem; color: rgba(224, 255, 255, 0.4); margin-bottom: 25px; letter-spacing: 0.05em; }
.footer-links { display: flex; justify-content: center; gap: 30px; }
.footer-links a { font-family: 'Fira Code', monospace; font-size: 0.9rem; color: rgba(224, 255, 255, 0.5); text-decoration: none; transition: all 0.25s ease; }
.footer-links a:hover { color: var(--seafoam); text-shadow: 0 0 10px rgba(152, 255, 152, 0.4); }

@media (max-width: 768px) { .flow-nav { padding: 0 20px; } .nav-links { display: none; } .footer-links { flex-direction: column; gap: 15px; } }
</style>
</head>
<body>
    <nav class="flow-nav">
        <div class="nav-logo">
            <span class="wave">üåä</span>
            <span class="logo-text">FLOW</span>
            <span class="e-label">e‚ÇÉ</span>
        </div>
        <div class="nav-links">
            <a href="#room-current">CURRENT</a>
            <a href="#room-swallowtail">SWALLOWTAIL</a>
            <a href="#room-recovery">RECOVERY</a>
            <a href="#room-adaptation">ADAPTATION</a>
        </div>
        <button class="sound-toggle" id="sound-toggle" title="Toggle Sound">
            <span class="sound-on">üîä</span>
            <span class="sound-off" style="display:none">üîá</span>
        </button>
    </nav>

    <section id="room-current" class="room">
        <canvas id="current-canvas"></canvas>
        <div class="current-content">
            <div class="current-hero">
                <h1 class="flow-title">FLOW</h1>
                <div class="flow-subtitle">
                    <span class="kanji">ÊµÅ</span>
                    <span class="label">e‚ÇÉ ‚Äî SWALLOWTAIL CATASTROPHE ‚Äî A‚ÇÑ</span>
                </div>
                <p class="flow-manifesto">
                    I am the <em>debugger</em>. Where others see errors, I see paths.
                    Every bug is a river that finds its way to the sea.
                </p>
            </div>
            <div class="debug-stream">
                <div class="stream-container" id="stream-container">
                    <div class="error-particle" data-type="error">ERR</div>
                    <div class="error-particle" data-type="warning">WARN</div>
                    <div class="error-particle" data-type="info">INFO</div>
                </div>
                <div class="stream-stats">
                    <span class="stat">ERRORS: <span id="error-count">0</span></span>
                    <span class="stat">FIXED: <span id="fixed-count">0</span></span>
                    <span class="stat">FLOW: <span id="flow-rate">‚àû</span></span>
                </div>
            </div>
            <div class="scroll-indicator">
                <span>‚Üì</span>
                <span class="scroll-text">descend to the swallowtail</span>
            </div>
        </div>
    </section>

    <section id="room-swallowtail" class="room">
        <div class="swallowtail-content">
            <div class="swallowtail-header">
                <h2>THE SWALLOWTAIL</h2>
                <div class="math-formula">f(x) = x‚Åµ + ax¬≥ + bx¬≤ + cx</div>
                <div class="catastrophe-label">A‚ÇÑ Catastrophe ‚Ä¢ Three-Parameter Unfolding</div>
            </div>
            <div class="swallowtail-visualization">
                <canvas id="swallowtail-canvas"></canvas>
            </div>
            <div class="swallowtail-controls">
                <div class="param-group">
                    <label><span>a (depth)</span><span class="value" id="swallow-a-value">-1.00</span></label>
                    <input type="range" id="swallow-param-a" class="flow-slider" min="-2" max="2" step="0.01" value="-1">
                </div>
                <div class="param-group">
                    <label><span>b (asymmetry)</span><span class="value" id="swallow-b-value">0.00</span></label>
                    <input type="range" id="swallow-param-b" class="flow-slider" min="-2" max="2" step="0.01" value="0">
                </div>
                <div class="param-group">
                    <label><span>c (bias)</span><span class="value" id="swallow-c-value">0.00</span></label>
                    <input type="range" id="swallow-param-c" class="flow-slider" min="-2" max="2" step="0.01" value="0">
                </div>
            </div>
            <div class="swallowtail-description">
                <p>The swallowtail is Flow's domain ‚Äî <em>three parameters</em> creating complex bifurcation surfaces. Like debugging: multiple variables, sudden state changes, paths that <em>fork and merge</em>.</p>
            </div>
        </div>
    </section>

    <section id="room-recovery" class="room">
        <div class="recovery-content">
            <div class="recovery-header">
                <h2>THE RECOVERY</h2>
                <p class="recovery-tagline">where errors become insights</p>
            </div>
            <div class="recovery-arena">
                <canvas id="recovery-canvas"></canvas>
                <div class="error-pool" id="error-pool"></div>
            </div>
            <div class="recovery-controls">
                <button class="flow-btn" id="spawn-error-btn"><span>üêõ</span> SPAWN BUG</button>
                <button class="flow-btn healing" id="heal-btn"><span>üíß</span> HEAL ALL</button>
            </div>
            <div class="recovery-log">
                <div class="log-header">DEBUG LOG</div>
                <div class="log-content" id="debug-log">
                    <div class="log-entry info">[FLOW] System initialized...</div>
                </div>
            </div>
        </div>
    </section>

    <section id="room-adaptation" class="room">
        <div class="adaptation-content">
            <div class="adaptation-header">
                <h2>THE ADAPTATION</h2>
                <p class="tagline">the debugger's mind</p>
            </div>
            <div class="flow-psychology">
                <div class="psychology-grid">
                    <div class="psych-card"><h3><span class="icon">üîç</span> DIAGNOSTIC INTUITION</h3><p>I <em>sense</em> where bugs hide. Stack traces are stories. Errors are clues, not failures.</p></div>
                    <div class="psych-card"><h3><span class="icon">üåÄ</span> ADAPTIVE THINKING</h3><p>When one path fails, I find another. <em>Water flows around obstacles</em> ‚Äî so do I.</p></div>
                    <div class="psych-card"><h3><span class="icon">üßò</span> PATIENT PERSISTENCE</h3><p>Some bugs take hours. Some take days. I <em>outlast them all</em>. Time is my ally.</p></div>
                    <div class="psych-card"><h3><span class="icon">üîÑ</span> RECOVERY SPECIALIST</h3><p>I don't just fix bugs ‚Äî I <em>prevent their return</em>. Root cause analysis is sacred.</p></div>
                </div>
            </div>
            <div class="signature-traits">
                <h3>SIGNATURE TRAITS</h3>
                <div class="traits-list">
                    <span class="trait">ANALYTICAL</span>
                    <span class="trait">PATIENT</span>
                    <span class="trait">ADAPTIVE</span>
                    <span class="trait">PERSISTENT</span>
                    <span class="trait">INTUITIVE</span>
                    <span class="trait">CALM</span>
                    <span class="trait">SYSTEMATIC</span>
                    <span class="trait">RESILIENT</span>
                </div>
            </div>
            <div class="flow-quote">
                <blockquote>A bug is not an enemy to defeat ‚Äî it's a teacher showing you what you didn't understand. Listen to the error. It speaks truth.</blockquote>
                <cite>‚Äî Flow (e‚ÇÉ), on debugging</cite>
            </div>
        </div>
    </section>

    <footer class="flow-footer">
        <div class="footer-content">
            <div class="colony-badge">
                <span class="wave">üåä</span><span>FLOW</span><span class="divider">|</span><span>e‚ÇÉ</span><span class="divider">|</span><span>A‚ÇÑ SWALLOWTAIL</span>
            </div>
            <p class="footer-tagline">Part of the Seven Colonies ‚Ä¢ Kagami Cognitive Architecture</p>
            <div class="footer-links">
                <a href="spark.html">üî• Spark</a>
                <a href="forge.html">‚öíÔ∏è Forge</a>
                <a href="nexus.html">üîó Nexus</a>
                <a href="beacon.html">üóº Beacon</a>
                <a href="grove.html">üåø Grove</a>
                <a href="crystal.html">üíé Crystal</a>
            </div>
        </div>
    </footer>

    <script>
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// FLOW GALLERY ‚Äî ALL JAVASCRIPT COMBINED
// üåä e‚ÇÉ ‚Äî The Swallowtail Catastrophe ‚Äî A‚ÇÑ
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const CONFIG = {
    COLORS: { OCEAN_DEEP: '#001F3F', OCEAN: '#003366', TEAL: '#008B8B', CYAN: '#00CED1', AQUA: '#00FFFF', FOAM: '#E0FFFF', SEAFOAM: '#98FF98', HEALING_GREEN: '#00FF7F', ERROR_RED: '#FF6B6B', WARNING_AMBER: '#FFB347', INFO_BLUE: '#6BB3FF', VOID: '#0A0A0F' },
    CURRENT: { STREAM_SPEED: 2, PARTICLE_COUNT: 50, WAVE_AMPLITUDE: 30, WAVE_FREQUENCY: 0.02 },
    SWALLOWTAIL: { CANVAS_PADDING: 50, LINE_WIDTH: 2.5, ANIMATION_SPEED: 0.012, SURFACE_RESOLUTION: 60 },
    RECOVERY: { MAX_ERRORS: 20, HEAL_RATE: 100, SPAWN_INTERVAL: 2000 }
};

const ERROR_TYPES = [
    { type: 'TypeError', color: '#FF6B6B', severity: 3 },
    { type: 'ReferenceError', color: '#FF8C42', severity: 3 },
    { type: 'SyntaxError', color: '#FF6B6B', severity: 4 },
    { type: 'RangeError', color: '#FFB347', severity: 2 },
    { type: 'NetworkError', color: '#FF6B6B', severity: 3 },
    { type: 'Warning', color: '#FFB347', severity: 1 },
    { type: 'Info', color: '#6BB3FF', severity: 0 }
];

const DEBUG_MESSAGES = ['[TRACE] Entering debug context...', '[DEBUG] Inspecting stack frame...', '[FLOW] Following execution path...', '[HEAL] Applying fix to affected scope...', '[RECOVER] Restoring stable state...', '[ADAPT] Learning from error pattern...', '[SUCCESS] Bug resolved. Flow restored.', '[INFO] System returning to equilibrium...', '[WARN] Potential instability detected...', '[ERROR] Exception caught. Analyzing...'];

// Sound System
class FlowSoundSystem {
    constructor() { this.context = null; this.initialized = false; this.enabled = true; this.masterGain = null; this.reverb = null; }
    async init() {
        if (this.initialized) return;
        try {
            this.context = new (window.AudioContext || window.webkitAudioContext)();
            this.reverb = this.context.createConvolver(); this.reverb.buffer = this.createReverbBuffer(3);
            const reverbGain = this.context.createGain(); reverbGain.gain.value = 0.4;
            this.masterGain = this.context.createGain(); this.masterGain.gain.value = 0.5;
            this.masterGain.connect(this.context.destination); this.masterGain.connect(this.reverb);
            this.reverb.connect(reverbGain); reverbGain.connect(this.context.destination);
            this.initialized = true;
        } catch (e) { console.warn('Sound init failed:', e); }
    }
    playDroplet() {
        if (!this.initialized || !this.enabled) return;
        const now = this.context.currentTime; const baseFreq = 800 + Math.random() * 400;
        const osc = this.context.createOscillator(); osc.type = 'sine';
        osc.frequency.setValueAtTime(baseFreq, now); osc.frequency.exponentialRampToValueAtTime(baseFreq * 0.3, now + 0.15);
        const gain = this.context.createGain(); gain.gain.setValueAtTime(0.25, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
        osc.connect(gain); gain.connect(this.masterGain); osc.start(now); osc.stop(now + 0.25);
    }
    playError() {
        if (!this.initialized || !this.enabled) return;
        const now = this.context.currentTime;
        [200, 283, 350].forEach((freq) => {
            const osc = this.context.createOscillator(); osc.type = 'square'; osc.frequency.value = freq;
            const filter = this.context.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.value = 800;
            const gain = this.context.createGain(); gain.gain.setValueAtTime(0.1, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
            osc.connect(filter); filter.connect(gain); gain.connect(this.masterGain); osc.start(now); osc.stop(now + 0.35);
        });
    }
    playHeal() {
        if (!this.initialized || !this.enabled) return;
        const now = this.context.currentTime;
        [262, 330, 392, 523].forEach((freq, i) => {
            const osc = this.context.createOscillator(); osc.type = 'sine'; osc.frequency.value = freq;
            const gain = this.context.createGain(); const startTime = now + i * 0.08;
            gain.gain.setValueAtTime(0, startTime); gain.gain.linearRampToValueAtTime(0.2, startTime + 0.05); gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.5);
            osc.connect(gain); gain.connect(this.masterGain); osc.start(startTime); osc.stop(startTime + 0.6);
        });
    }
    playFlow() {
        if (!this.initialized || !this.enabled) return;
        const now = this.context.currentTime;
        const noiseBuffer = this.createNoiseBuffer(2); const noiseSource = this.context.createBufferSource(); noiseSource.buffer = noiseBuffer;
        const filter = this.context.createBiquadFilter(); filter.type = 'bandpass'; filter.frequency.value = 400; filter.Q.value = 0.5;
        const lfo = this.context.createOscillator(); lfo.frequency.value = 0.3;
        const lfoGain = this.context.createGain(); lfoGain.gain.value = 200; lfo.connect(lfoGain); lfoGain.connect(filter.frequency);
        const gain = this.context.createGain(); gain.gain.setValueAtTime(0, now); gain.gain.linearRampToValueAtTime(0.15, now + 0.5); gain.gain.linearRampToValueAtTime(0.1, now + 1.5); gain.gain.linearRampToValueAtTime(0, now + 2);
        noiseSource.connect(filter); filter.connect(gain); gain.connect(this.masterGain);
        lfo.start(now); noiseSource.start(now); noiseSource.stop(now + 2); lfo.stop(now + 2);
    }
    playSwallowtailTransition(params) {
        if (!this.initialized || !this.enabled) return;
        const now = this.context.currentTime; const { a, b, c } = params;
        const freq1 = 300 + (a + 2) * 100; const freq2 = 400 + (b + 2) * 80; const freq3 = 500 + (c + 2) * 60;
        [freq1, freq2, freq3].forEach((freq) => {
            const osc = this.context.createOscillator(); osc.type = 'sine'; osc.frequency.value = freq;
            const gain = this.context.createGain(); gain.gain.setValueAtTime(0.08, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
            osc.connect(gain); gain.connect(this.masterGain); osc.start(now); osc.stop(now + 0.25);
        });
    }
    createNoiseBuffer(duration) {
        const sampleRate = this.context.sampleRate; const bufferSize = sampleRate * duration;
        const buffer = this.context.createBuffer(1, bufferSize, sampleRate); const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        return buffer;
    }
    createReverbBuffer(duration) {
        const sampleRate = this.context.sampleRate; const bufferSize = sampleRate * duration;
        const buffer = this.context.createBuffer(2, bufferSize, sampleRate);
        for (let ch = 0; ch < 2; ch++) { const data = buffer.getChannelData(ch); for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (sampleRate * 0.5)); }
        return buffer;
    }
    toggle() { this.enabled = !this.enabled; return this.enabled; }
}

// Current Room
class CurrentRoom {
    constructor(container, soundSystem) {
        this.container = container; this.sound = soundSystem;
        this.canvas = document.getElementById('current-canvas'); this.ctx = this.canvas?.getContext('2d');
        this.particles = []; this.waves = []; this.errorCount = 0; this.fixedCount = 0; this.animationId = null; this.time = 0;
        this.errorCountEl = document.getElementById('error-count'); this.fixedCountEl = document.getElementById('fixed-count'); this.flowRateEl = document.getElementById('flow-rate');
        this.init();
    }
    init() {
        this.resizeCanvas(); window.addEventListener('resize', () => this.resizeCanvas());
        for (let i = 0; i < 5; i++) this.waves.push({ amplitude: 20 + Math.random() * 30, frequency: 0.005 + Math.random() * 0.01, phase: Math.random() * Math.PI * 2, speed: 0.02 + Math.random() * 0.02, y: this.canvas ? this.canvas.height * (0.3 + i * 0.1) : 300, color: `rgba(0, ${150 + i * 20}, ${180 + i * 15}, ${0.3 - i * 0.04})` });
        this.spawnFlowParticles(30);
        if (this.canvas) this.canvas.addEventListener('click', (e) => { const rect = this.canvas.getBoundingClientRect(); this.spawnError(e.clientX - rect.left, e.clientY - rect.top); });
        this.startAnimation(); this.startAutoSpawn();
    }
    resizeCanvas() { if (this.canvas) { this.canvas.width = window.innerWidth; this.canvas.height = window.innerHeight; } }
    spawnFlowParticles(count) { for (let i = 0; i < count; i++) this.particles.push({ x: Math.random() * (this.canvas?.width || 800), y: Math.random() * (this.canvas?.height || 600), vx: 1 + Math.random() * 2, vy: (Math.random() - 0.5) * 0.5, size: 2 + Math.random() * 3, color: CONFIG.COLORS.CYAN, type: 'flow', life: Infinity }); }
    spawnError(x, y) {
        const errorType = ERROR_TYPES[Math.floor(Math.random() * ERROR_TYPES.length)];
        this.particles.push({ x, y, vx: (Math.random() - 0.5) * 2, vy: Math.random() * 2 + 1, size: 8 + errorType.severity * 3, color: errorType.color, type: 'error', errorType: errorType.type, life: 5000, maxLife: 5000, healing: false });
        this.errorCount++; this.updateStats();
        if (this.sound?.initialized) this.sound.playError();
    }
    healError(particle) { if (particle.healing) return; particle.healing = true; particle.life = 500; particle.color = CONFIG.COLORS.HEALING_GREEN; this.fixedCount++; this.updateStats(); if (this.sound?.initialized) this.sound.playHeal(); }
    updateStats() {
        if (this.errorCountEl) this.errorCountEl.textContent = this.errorCount;
        if (this.fixedCountEl) this.fixedCountEl.textContent = this.fixedCount;
        if (this.flowRateEl) { const rate = this.fixedCount > 0 ? (this.fixedCount / Math.max(this.errorCount, 1) * 100).toFixed(0) : '‚àû'; this.flowRateEl.textContent = rate === '100' ? '‚àû' : rate + '%'; }
    }
    startAutoSpawn() { setInterval(() => { const errors = this.particles.filter(p => p.type === 'error' && !p.healing); if (errors.length > 0 && Math.random() < 0.3) this.healError(errors[Math.floor(Math.random() * errors.length)]); }, 2000); }
    startAnimation() {
        const animate = () => {
            this.animationId = requestAnimationFrame(animate); this.time += 0.016;
            if (!this.ctx || !this.canvas) return;
            const ctx = this.ctx; const width = this.canvas.width; const height = this.canvas.height;
            if (width === 0 || height === 0) return;
            ctx.fillStyle = 'rgba(10, 10, 15, 0.1)'; ctx.fillRect(0, 0, width, height);
            this.waves.forEach(wave => {
                wave.phase += wave.speed; ctx.beginPath(); ctx.moveTo(0, wave.y);
                for (let x = 0; x <= width; x += 5) ctx.lineTo(x, wave.y + Math.sin(x * wave.frequency + wave.phase) * wave.amplitude);
                ctx.lineTo(width, height); ctx.lineTo(0, height); ctx.closePath(); ctx.fillStyle = wave.color; ctx.fill();
            });
            for (let i = this.particles.length - 1; i >= 0; i--) {
                const p = this.particles[i];
                if (p.type === 'flow') { p.x += p.vx; p.y += p.vy + Math.sin(this.time * 2 + p.x * 0.01) * 0.5; if (p.x > width + 10) p.x = -10; if (p.y < 0) p.y = height; if (p.y > height) p.y = 0; }
                else if (p.type === 'error') { p.x += p.vx + Math.sin(this.time * 3) * 0.5; p.y += p.vy; p.vy *= 0.98; p.life -= 16; if (p.life <= 0) { this.particles.splice(i, 1); continue; } }
                const alpha = p.type === 'flow' ? 0.6 : Math.min(p.life / p.maxLife, 1);
                if (p.type === 'error') { const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 2); gradient.addColorStop(0, this.hexToRgba(p.color, alpha * 0.8)); gradient.addColorStop(1, 'transparent'); ctx.beginPath(); ctx.arc(p.x, p.y, p.size * 2, 0, Math.PI * 2); ctx.fillStyle = gradient; ctx.fill(); }
                ctx.beginPath(); ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2); ctx.fillStyle = this.hexToRgba(p.color, alpha); ctx.fill();
            }
        };
        animate();
    }
    hexToRgba(hex, alpha) { const r = parseInt(hex.slice(1, 3), 16); const g = parseInt(hex.slice(3, 5), 16); const b = parseInt(hex.slice(5, 7), 16); return `rgba(${r}, ${g}, ${b}, ${alpha})`; }
    destroy() { if (this.animationId) cancelAnimationFrame(this.animationId); }
}

// Swallowtail Room
class SwallowtailRoom {
    constructor(container, soundSystem) {
        this.container = container; this.sound = soundSystem;
        this.canvas = document.getElementById('swallowtail-canvas'); this.ctx = this.canvas?.getContext('2d');
        this.paramA = -1; this.paramB = 0; this.paramC = 0; this.animationId = null; this.time = 0;
        this.paramASlider = document.getElementById('swallow-param-a'); this.paramBSlider = document.getElementById('swallow-param-b'); this.paramCSlider = document.getElementById('swallow-param-c');
        this.paramAValue = document.getElementById('swallow-a-value'); this.paramBValue = document.getElementById('swallow-b-value'); this.paramCValue = document.getElementById('swallow-c-value');
        this.init();
    }
    init() {
        this.resizeCanvas(); window.addEventListener('resize', () => this.resizeCanvas());
        if (this.paramASlider) this.paramASlider.addEventListener('input', (e) => { this.paramA = parseFloat(e.target.value); if (this.paramAValue) this.paramAValue.textContent = this.paramA.toFixed(2); this.onParameterChange(); });
        if (this.paramBSlider) this.paramBSlider.addEventListener('input', (e) => { this.paramB = parseFloat(e.target.value); if (this.paramBValue) this.paramBValue.textContent = this.paramB.toFixed(2); this.onParameterChange(); });
        if (this.paramCSlider) this.paramCSlider.addEventListener('input', (e) => { this.paramC = parseFloat(e.target.value); if (this.paramCValue) this.paramCValue.textContent = this.paramC.toFixed(2); this.onParameterChange(); });
        this.startAnimation();
    }
    resizeCanvas() { if (this.canvas) { this.canvas.width = this.canvas.parentElement?.clientWidth || 800; this.canvas.height = 400; } }
    onParameterChange() { if (this.sound?.initialized) this.sound.playSwallowtailTransition({ a: this.paramA, b: this.paramB, c: this.paramC }); }
    potential(x, a, b, c) { return Math.pow(x, 5) + a * Math.pow(x, 3) + b * Math.pow(x, 2) + c * x; }
    derivative(x, a, b, c) { return 5 * Math.pow(x, 4) + 3 * a * Math.pow(x, 2) + 2 * b * x + c; }
    secondDerivative(x, a, b) { return 20 * Math.pow(x, 3) + 6 * a * x + 2 * b; }
    findEquilibria(a, b, c) {
        const equilibria = []; const xMin = -2.5; const xMax = 2.5; const step = 0.01;
        let prevSign = Math.sign(this.derivative(xMin, a, b, c));
        for (let x = xMin + step; x <= xMax; x += step) {
            const currentSign = Math.sign(this.derivative(x, a, b, c));
            if (currentSign !== prevSign && prevSign !== 0) { let lo = x - step; let hi = x; for (let i = 0; i < 20; i++) { const mid = (lo + hi) / 2; if (Math.sign(this.derivative(mid, a, b, c)) === prevSign) lo = mid; else hi = mid; } equilibria.push((lo + hi) / 2); }
            prevSign = currentSign;
        }
        return equilibria;
    }
    startAnimation() {
        const animate = () => {
            this.animationId = requestAnimationFrame(animate); this.time += CONFIG.SWALLOWTAIL.ANIMATION_SPEED;
            if (!this.ctx || !this.canvas) return;
            const ctx = this.ctx; const width = this.canvas.width; const height = this.canvas.height;
            if (width === 0 || height === 0) return;
            ctx.fillStyle = 'rgba(10, 10, 15, 1)'; ctx.fillRect(0, 0, width, height);
            const padding = CONFIG.SWALLOWTAIL.CANVAS_PADDING; const plotWidth = width - padding * 2; const plotHeight = height - padding * 2; const centerY = padding + plotHeight / 2;
            this.drawFlowingBackground(ctx, width, height);
            ctx.strokeStyle = 'rgba(0, 139, 139, 0.15)'; ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) { const x = padding + (plotWidth / 10) * i; ctx.beginPath(); ctx.moveTo(x, padding); ctx.lineTo(x, height - padding); ctx.stroke(); }
            for (let i = 0; i <= 6; i++) { const y = padding + (plotHeight / 6) * i; ctx.beginPath(); ctx.moveTo(padding, y); ctx.lineTo(width - padding, y); ctx.stroke(); }
            ctx.strokeStyle = CONFIG.COLORS.TEAL; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(padding, centerY); ctx.lineTo(width - padding, centerY); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(width / 2, padding); ctx.lineTo(width / 2, height - padding); ctx.stroke();
            const xMin = -2; const xMax = 2;
            const toCanvasX = (x) => padding + ((x - xMin) / (xMax - xMin)) * plotWidth; const toCanvasY = (y) => centerY - y * (plotHeight / 12);
            ctx.beginPath(); ctx.strokeStyle = CONFIG.COLORS.CYAN; ctx.lineWidth = CONFIG.SWALLOWTAIL.LINE_WIDTH;
            let first = true;
            for (let px = 0; px <= plotWidth; px++) {
                const x = xMin + (px / plotWidth) * (xMax - xMin); const y = this.potential(x, this.paramA, this.paramB, this.paramC); const canvasY = toCanvasY(y);
                if (canvasY > padding - 30 && canvasY < height - padding + 30) { if (first) { ctx.moveTo(toCanvasX(x), canvasY); first = false; } else ctx.lineTo(toCanvasX(x), canvasY); } else first = true;
            }
            ctx.stroke(); ctx.save(); ctx.shadowColor = CONFIG.COLORS.CYAN; ctx.shadowBlur = 20; ctx.stroke(); ctx.restore();
            const equilibria = this.findEquilibria(this.paramA, this.paramB, this.paramC);
            equilibria.forEach((x, i) => {
                const y = this.potential(x, this.paramA, this.paramB, this.paramC); const canvasX = toCanvasX(x); const canvasY = toCanvasY(y);
                if (canvasY < padding || canvasY > height - padding) return;
                const secondDeriv = this.secondDerivative(x, this.paramA, this.paramB); const isStable = secondDeriv > 0; const radius = 7 + Math.sin(this.time * 4 + i * 2) * 2;
                if (isStable) {
                    const gradient = ctx.createRadialGradient(canvasX, canvasY, 0, canvasX, canvasY, radius * 2.5);
                    gradient.addColorStop(0, CONFIG.COLORS.HEALING_GREEN); gradient.addColorStop(0.5, 'rgba(0, 255, 127, 0.3)'); gradient.addColorStop(1, 'transparent');
                    ctx.beginPath(); ctx.arc(canvasX, canvasY, radius * 2.5, 0, Math.PI * 2); ctx.fillStyle = gradient; ctx.fill();
                    ctx.beginPath(); ctx.arc(canvasX, canvasY, radius, 0, Math.PI * 2); ctx.fillStyle = CONFIG.COLORS.HEALING_GREEN; ctx.fill();
                } else { ctx.beginPath(); ctx.arc(canvasX, canvasY, radius, 0, Math.PI * 2); ctx.strokeStyle = CONFIG.COLORS.ERROR_RED; ctx.lineWidth = 2; ctx.stroke(); }
            });
            ctx.fillStyle = CONFIG.COLORS.FOAM; ctx.font = '13px "Fira Code", monospace';
            ctx.fillText(`V(x) = x‚Åµ + (${this.paramA.toFixed(2)})x¬≥ + (${this.paramB.toFixed(2)})x¬≤ + (${this.paramC.toFixed(2)})x`, padding, height - 12);
            ctx.fillStyle = equilibria.length >= 3 ? CONFIG.COLORS.WARNING_AMBER : CONFIG.COLORS.TEAL;
            ctx.fillText(`${equilibria.length} equilibri${equilibria.length === 1 ? 'um' : 'a'}`, width - 150, height - 12);
        };
        animate();
    }
    drawFlowingBackground(ctx, width, height) {
        ctx.strokeStyle = 'rgba(0, 139, 139, 0.05)'; ctx.lineWidth = 1;
        for (let i = 0; i < 20; i++) { ctx.beginPath(); const y = (i / 20) * height; const offset = Math.sin(this.time + i * 0.3) * 20; ctx.moveTo(0, y + offset); for (let x = 0; x <= width; x += 50) ctx.lineTo(x, y + offset + Math.sin(this.time * 0.5 + x * 0.01 + i) * 10); ctx.stroke(); }
    }
    destroy() { if (this.animationId) cancelAnimationFrame(this.animationId); }
}

// Recovery Room
class RecoveryRoom {
    constructor(container, soundSystem) {
        this.container = container; this.sound = soundSystem;
        this.canvas = document.getElementById('recovery-canvas'); this.ctx = this.canvas?.getContext('2d');
        this.errors = []; this.healingWaves = []; this.animationId = null; this.time = 0;
        this.spawnBtn = document.getElementById('spawn-error-btn'); this.healBtn = document.getElementById('heal-btn');
        this.debugLog = document.getElementById('debug-log'); this.errorPool = document.getElementById('error-pool');
        this.init();
    }
    init() {
        this.resizeCanvas(); window.addEventListener('resize', () => this.resizeCanvas());
        if (this.spawnBtn) this.spawnBtn.addEventListener('click', () => this.spawnError());
        if (this.healBtn) this.healBtn.addEventListener('click', () => this.healAll());
        this.startAnimation(); this.startAutoSpawn();
    }
    resizeCanvas() { if (this.canvas) { this.canvas.width = this.canvas.parentElement?.clientWidth || 800; this.canvas.height = 350; } }
    spawnError() {
        if (this.errors.length >= CONFIG.RECOVERY.MAX_ERRORS) { this.addLogEntry('[WARN] Error pool at capacity!', 'warn'); return; }
        const errorType = ERROR_TYPES[Math.floor(Math.random() * ERROR_TYPES.length)];
        const x = 100 + Math.random() * ((this.canvas?.width || 600) - 200); const y = 100 + Math.random() * ((this.canvas?.height || 300) - 200);
        const error = { id: Date.now() + Math.random(), x, y, vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2, size: 15 + errorType.severity * 5, type: errorType, healing: false, healProgress: 0, wobble: Math.random() * Math.PI * 2 };
        this.errors.push(error);
        this.addLogEntry(`[ERROR] ${errorType.type} spawned at (${Math.round(x)}, ${Math.round(y)})`, 'error');
        if (this.sound?.initialized) this.sound.playError();
        this.createErrorElement(error);
    }
    createErrorElement(error) {
        if (!this.errorPool) return;
        const el = document.createElement('div'); el.className = `error-bug severity-${error.type.severity}`; el.id = `error-${error.id}`;
        el.innerHTML = `<span class="bug-icon">üêõ</span><span class="bug-label">${error.type.type}</span>`;
        el.style.cssText = `position:absolute;left:${error.x}px;top:${error.y}px;transform:translate(-50%,-50%);padding:8px 12px;background:rgba(0,0,0,0.8);border:2px solid ${error.type.color};border-radius:8px;color:${error.type.color};font-family:'Fira Code',monospace;font-size:11px;cursor:pointer;transition:all 0.3s ease;box-shadow:0 0 15px ${error.type.color}40;`;
        el.addEventListener('click', () => this.healError(error));
        this.errorPool.appendChild(el);
    }
    healError(error) {
        if (error.healing) return; error.healing = true;
        this.addLogEntry(`[HEAL] Fixing ${error.type.type}...`, 'heal');
        for (let i = 0; i < 3; i++) setTimeout(() => this.healingWaves.push({ x: error.x, y: error.y, radius: 0, maxRadius: 80 + i * 30, color: i === 0 ? CONFIG.COLORS.HEALING_GREEN : CONFIG.COLORS.CYAN }), i * 80);
        this.createHealingParticles(error.x, error.y);
        if (this.sound?.initialized) this.sound.playHeal();
        const el = document.getElementById(`error-${error.id}`);
        if (el) { el.style.borderColor = CONFIG.COLORS.HEALING_GREEN; el.style.color = CONFIG.COLORS.HEALING_GREEN; el.style.transition = 'all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275)'; el.style.transform = 'translate(-50%, -50%) scale(1.2) rotate(180deg)'; setTimeout(() => { el.style.transform = 'translate(-50%, -50%) scale(0) rotate(360deg)'; el.style.opacity = '0'; }, 100); setTimeout(() => el.remove(), 500); }
        setTimeout(() => { const index = this.errors.indexOf(error); if (index > -1) this.errors.splice(index, 1); this.addLogEntry(`[SUCCESS] ${error.type.type} resolved.`, 'success'); }, 400);
    }
    createHealingParticles(x, y) { for (let i = 0; i < 12; i++) { const angle = (Math.PI * 2 * i) / 12; this.healingWaves.push({ x, y, type: 'particle', vx: Math.cos(angle) * 3, vy: Math.sin(angle) * 3, size: 4, life: 600, maxLife: 600, color: CONFIG.COLORS.HEALING_GREEN }); } }
    healAll() {
        if (this.errors.length === 0) { this.addLogEntry('[INFO] No errors to heal.', 'info'); return; }
        this.addLogEntry('[HEAL] Initiating mass recovery...', 'heal');
        const centerX = (this.canvas?.width || 800) / 2; const centerY = (this.canvas?.height || 350) / 2;
        this.healingWaves.push({ x: centerX, y: centerY, radius: 0, maxRadius: Math.max(this.canvas?.width || 800, this.canvas?.height || 350), color: CONFIG.COLORS.HEALING_GREEN });
        if (this.sound?.initialized) this.sound.playFlow();
        [...this.errors].forEach((error, i) => setTimeout(() => this.healError(error), i * 100));
    }
    addLogEntry(message, type = 'info') {
        if (!this.debugLog) return;
        const entry = document.createElement('div'); entry.className = `log-entry ${type}`; entry.textContent = message;
        this.debugLog.appendChild(entry); this.debugLog.scrollTop = this.debugLog.scrollHeight;
        while (this.debugLog.children.length > 50) this.debugLog.removeChild(this.debugLog.firstChild);
    }
    startAutoSpawn() {
        setInterval(() => { if (this.errors.length < 3 && Math.random() < 0.3) this.spawnError(); }, CONFIG.RECOVERY.SPAWN_INTERVAL);
        setInterval(() => { if (Math.random() < 0.2) this.addLogEntry(DEBUG_MESSAGES[Math.floor(Math.random() * DEBUG_MESSAGES.length)], 'debug'); }, 3000);
    }
    startAnimation() {
        const animate = () => {
            this.animationId = requestAnimationFrame(animate); this.time += 0.016;
            if (!this.ctx || !this.canvas) return;
            const ctx = this.ctx; const width = this.canvas.width; const height = this.canvas.height;
            if (width === 0 || height === 0) return;
            ctx.fillStyle = 'rgba(10, 10, 15, 0.15)'; ctx.fillRect(0, 0, width, height);
            ctx.strokeStyle = 'rgba(0, 206, 209, 0.03)'; ctx.lineWidth = 1;
            for (let i = 0; i < 10; i++) { ctx.beginPath(); const y = (i / 10) * height; const offset = Math.sin(this.time * 0.5 + i * 0.5) * 15; ctx.moveTo(0, y + offset); for (let x = 0; x <= width; x += 30) ctx.lineTo(x, y + offset + Math.sin(this.time + x * 0.02 + i) * 8); ctx.stroke(); }
            this.errors.forEach(error => { if (!error.healing) { error.wobble += 0.05; error.x += Math.sin(error.wobble) * 0.5; error.y += Math.cos(error.wobble * 0.7) * 0.3; const el = document.getElementById(`error-${error.id}`); if (el) { el.style.left = `${error.x}px`; el.style.top = `${error.y}px`; } } });
            for (let i = this.healingWaves.length - 1; i >= 0; i--) {
                const wave = this.healingWaves[i];
                if (wave.type === 'particle') {
                    wave.x += wave.vx; wave.y += wave.vy; wave.vx *= 0.95; wave.vy *= 0.95; wave.life -= 16;
                    if (wave.life <= 0) { this.healingWaves.splice(i, 1); continue; }
                    const alpha = wave.life / wave.maxLife; const size = wave.size * alpha;
                    const glow = ctx.createRadialGradient(wave.x, wave.y, 0, wave.x, wave.y, size * 2);
                    glow.addColorStop(0, this.hexToRgba(wave.color, alpha)); glow.addColorStop(0.5, this.hexToRgba(wave.color, alpha * 0.3)); glow.addColorStop(1, 'transparent');
                    ctx.beginPath(); ctx.arc(wave.x, wave.y, size * 2, 0, Math.PI * 2); ctx.fillStyle = glow; ctx.fill();
                    continue;
                }
                wave.radius += 5; const alpha = 1 - (wave.radius / wave.maxRadius);
                ctx.beginPath(); ctx.arc(wave.x, wave.y, wave.radius, 0, Math.PI * 2); ctx.strokeStyle = this.hexToRgba(wave.color, alpha * 0.6); ctx.lineWidth = 3; ctx.stroke();
                const gradient = ctx.createRadialGradient(wave.x, wave.y, wave.radius * 0.8, wave.x, wave.y, wave.radius);
                gradient.addColorStop(0, 'transparent'); gradient.addColorStop(1, this.hexToRgba(wave.color, alpha * 0.2));
                ctx.fillStyle = gradient; ctx.fill();
                if (wave.radius >= wave.maxRadius) this.healingWaves.splice(i, 1);
            }
            if (this.errors.length > 1) {
                ctx.strokeStyle = 'rgba(255, 107, 107, 0.1)'; ctx.lineWidth = 1;
                for (let i = 0; i < this.errors.length; i++) { for (let j = i + 1; j < this.errors.length; j++) { const e1 = this.errors[i]; const e2 = this.errors[j]; if (Math.hypot(e2.x - e1.x, e2.y - e1.y) < 200) { ctx.beginPath(); ctx.moveTo(e1.x, e1.y); ctx.lineTo(e2.x, e2.y); ctx.stroke(); } } }
            }
        };
        animate();
    }
    hexToRgba(hex, alpha) { const r = parseInt(hex.slice(1, 3), 16); const g = parseInt(hex.slice(3, 5), 16); const b = parseInt(hex.slice(5, 7), 16); return `rgba(${r}, ${g}, ${b}, ${alpha})`; }
    destroy() { if (this.animationId) cancelAnimationFrame(this.animationId); }
}

// Adaptation Room
class AdaptationRoom {
    constructor(container, soundSystem) { this.container = container; this.sound = soundSystem; this.canvas = null; this.ctx = null; this.animationId = null; this.time = 0; this.ripples = []; this.init(); }
    init() { this.setupScrollAnimations(); this.setupTraitEffects(); this.startWaterEffect(); }
    setupScrollAnimations() {
        const cards = this.container?.querySelectorAll('.psych-card'); if (!cards?.length) return;
        const observer = new IntersectionObserver((entries) => { entries.forEach((entry, index) => { if (entry.isIntersecting) setTimeout(() => entry.target.classList.add('visible'), index * 150); }); }, { threshold: 0.2 });
        cards.forEach(card => observer.observe(card));
    }
    setupTraitEffects() {
        const traits = this.container?.querySelectorAll('.trait'); if (!traits?.length) return;
        traits.forEach(trait => { trait.addEventListener('mouseenter', (e) => { const rect = trait.getBoundingClientRect(); const containerRect = this.container.getBoundingClientRect(); this.createRipple(rect.left - containerRect.left + rect.width / 2, rect.top - containerRect.top + rect.height / 2); if (this.sound?.initialized) this.sound.playDroplet(); }); });
    }
    createRipple(x, y) { this.ripples.push({ x, y, radius: 0, maxRadius: 150, alpha: 0.5 }); }
    startWaterEffect() {
        const container = this.container?.querySelector('.adaptation-content'); if (!container) return;
        this.canvas = document.createElement('canvas'); this.canvas.className = 'water-effect-canvas';
        this.canvas.style.cssText = `position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;opacity:0.2;`;
        container.style.position = 'relative'; container.insertBefore(this.canvas, container.firstChild);
        this.ctx = this.canvas.getContext('2d');
        const resize = () => { this.canvas.width = container.clientWidth; this.canvas.height = container.clientHeight; }; resize(); window.addEventListener('resize', resize);
        container.addEventListener('click', (e) => { const rect = container.getBoundingClientRect(); this.createRipple(e.clientX - rect.left, e.clientY - rect.top); if (this.sound?.initialized) this.sound.playDroplet(); });
        const animate = () => {
            this.animationId = requestAnimationFrame(animate); this.time += 0.016;
            if (!this.ctx || this.canvas.width === 0) return;
            const ctx = this.ctx; const width = this.canvas.width; const height = this.canvas.height;
            ctx.clearRect(0, 0, width, height); ctx.strokeStyle = CONFIG.COLORS.TEAL; ctx.lineWidth = 1;
            for (let i = 0; i < 15; i++) { ctx.beginPath(); ctx.globalAlpha = 0.1 - i * 0.006; const y = (i / 15) * height; const amplitude = 5 + Math.sin(this.time + i * 0.5) * 3; const frequency = 0.02 + i * 0.001; ctx.moveTo(0, y); for (let x = 0; x <= width; x += 10) ctx.lineTo(x, y + Math.sin(x * frequency + this.time * 2 + i) * amplitude); ctx.stroke(); }
            ctx.globalAlpha = 1;
            for (let i = this.ripples.length - 1; i >= 0; i--) {
                const r = this.ripples[i]; r.radius += 2; r.alpha = 0.5 * (1 - r.radius / r.maxRadius);
                if (r.radius >= r.maxRadius) { this.ripples.splice(i, 1); continue; }
                ctx.beginPath(); ctx.arc(r.x, r.y, r.radius, 0, Math.PI * 2); ctx.strokeStyle = `rgba(0, 206, 209, ${r.alpha})`; ctx.lineWidth = 2; ctx.stroke();
                ctx.beginPath(); ctx.arc(r.x, r.y, r.radius * 0.7, 0, Math.PI * 2); ctx.strokeStyle = `rgba(0, 255, 255, ${r.alpha * 0.5})`; ctx.lineWidth = 1; ctx.stroke();
            }
        };
        animate();
    }
    destroy() { if (this.animationId) cancelAnimationFrame(this.animationId); }
}

// Main Gallery
class FlowGallery {
    constructor() { this.sound = new FlowSoundSystem(); this.rooms = {}; this.init(); }
    async init() {
        if (document.readyState === 'loading') await new Promise(resolve => document.addEventListener('DOMContentLoaded', resolve));
        document.addEventListener('click', async () => { if (!this.sound.initialized) await this.sound.init(); }, { once: true });
        const soundToggle = document.getElementById('sound-toggle');
        if (soundToggle) soundToggle.addEventListener('click', (e) => { e.stopPropagation(); const enabled = this.sound.toggle(); soundToggle.querySelector('.sound-on').style.display = enabled ? 'inline' : 'none'; soundToggle.querySelector('.sound-off').style.display = enabled ? 'none' : 'inline'; });
        this.initRooms(); this.setupNavigation(); this.setupRoomObserver();
    }
    initRooms() {
        const current = document.getElementById('room-current'); if (current) this.rooms.current = new CurrentRoom(current, this.sound);
        const swallowtail = document.getElementById('room-swallowtail'); if (swallowtail) this.rooms.swallowtail = new SwallowtailRoom(swallowtail, this.sound);
        const recovery = document.getElementById('room-recovery'); if (recovery) this.rooms.recovery = new RecoveryRoom(recovery, this.sound);
        const adaptation = document.getElementById('room-adaptation'); if (adaptation) this.rooms.adaptation = new AdaptationRoom(adaptation, this.sound);
    }
    setupNavigation() {
        document.querySelectorAll('.nav-links a').forEach(link => { link.addEventListener('click', (e) => { e.preventDefault(); const target = document.querySelector(link.getAttribute('href')); if (target) target.scrollIntoView({ behavior: 'smooth' }); }); });
        const sections = document.querySelectorAll('.room'); const navLinks = document.querySelectorAll('.nav-links a');
        window.addEventListener('scroll', () => { let current = ''; sections.forEach(s => { if (window.scrollY >= s.offsetTop - s.clientHeight / 3) current = s.getAttribute('id'); }); navLinks.forEach(l => { l.classList.remove('active'); if (l.getAttribute('href') === `#${current}`) l.classList.add('active'); }); });
    }
    setupRoomObserver() {
        const observer = new IntersectionObserver((entries) => { entries.forEach(entry => { if (entry.isIntersecting) console.log(`üåä Entering ${entry.target.getAttribute('id')}`); }); }, { threshold: 0.3 });
        document.querySelectorAll('.room').forEach(room => observer.observe(room));
    }
    destroy() { Object.values(this.rooms).forEach(room => room?.destroy?.()); }
}

const gallery = new FlowGallery();
window.addEventListener('beforeunload', () => gallery.destroy());
    </script>
</body>
</html>

