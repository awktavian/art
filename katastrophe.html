<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>KATASTROPHE</title>
    <style>
@import url('https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&display=swap');

* { margin: 0; padding: 0; box-sizing: border-box; }

:root {
    --void: #0a0a0b;
    --glow: #ffffff;
    --dim: rgba(255,255,255,0.15);
    --breath: 0;
}

html, body {
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: var(--void);
    font-family: 'Space Mono', monospace;
    color: var(--glow);
    user-select: none;
    -webkit-user-select: none;
    touch-action: manipulation;
    cursor: none;
}

/* Custom cursor */
.cursor {
    position: fixed;
    width: 20px;
    height: 20px;
    border: 1px solid rgba(255,255,255,0.4);
    border-radius: 50%;
    pointer-events: none;
    z-index: 9999;
    transition: transform 0.1s, opacity 0.2s;
    mix-blend-mode: difference;
}

.cursor.active {
    transform: scale(0.7);
}

/* Container */
.instrument {
    width: 100vw;
    height: 100vh;
    display: flex;
    flex-direction: column;
    position: relative;
    overflow: hidden;
}

/* Display - the breathing heart */
.display {
    flex: 1;
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    overflow: hidden;
}

#visualization {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
}

/* Engine indicator - minimal */
.engine-indicator {
    position: absolute;
    top: 2rem;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 0.5rem;
    z-index: 10;
}

.engine-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: var(--dim);
    cursor: pointer;
    transition: all 0.3s;
}

.engine-dot:hover {
    background: rgba(255,255,255,0.4);
}

.engine-dot.active {
    background: var(--glow);
    box-shadow: 0 0 20px var(--glow);
}

/* Knobs row */
.controls {
    position: absolute;
    bottom: 140px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 3rem;
    z-index: 10;
}

.knob-wrap {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 0.5rem;
}

.knob {
    width: 48px;
    height: 48px;
    border-radius: 50%;
    background: radial-gradient(circle at 30% 30%, #2a2a2a, #0a0a0a);
    border: 1px solid rgba(255,255,255,0.1);
    position: relative;
    cursor: grab;
    transition: box-shadow 0.2s;
}

.knob:hover {
    box-shadow: 0 0 30px rgba(255,255,255,0.1);
}

.knob::after {
    content: '';
    position: absolute;
    top: 6px;
    left: 50%;
    transform: translateX(-50%);
    width: 2px;
    height: 10px;
    background: var(--glow);
    border-radius: 1px;
    transform-origin: center 18px;
    box-shadow: 0 0 10px var(--glow);
}

.knob-label {
    font-size: 0.55rem;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    opacity: 0.4;
}

/* Keyboard */
.keyboard {
    height: 120px;
    display: flex;
    justify-content: center;
    align-items: flex-end;
    padding-bottom: 1rem;
    gap: 2px;
    position: relative;
    background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, transparent 100%);
}

.key {
    height: 90px;
    border-radius: 0 0 4px 4px;
    cursor: pointer;
    transition: all 0.08s;
    position: relative;
}

.key.white {
    width: 40px;
    background: linear-gradient(to bottom, #f8f8f8 0%, #e8e8e8 100%);
    box-shadow: 0 4px 8px rgba(0,0,0,0.4), inset 0 -2px 4px rgba(0,0,0,0.1);
    z-index: 1;
}

.key.black {
    width: 26px;
    height: 56px;
    background: linear-gradient(to bottom, #2a2a2a 0%, #1a1a1a 100%);
    box-shadow: 0 2px 4px rgba(0,0,0,0.6);
    margin: 0 -13px;
    z-index: 2;
}

.key.white:active, .key.white.pressed {
    background: linear-gradient(to bottom, #e0e0e0 0%, #d0d0d0 100%);
    transform: translateY(3px);
    box-shadow: 0 1px 2px rgba(0,0,0,0.3);
}

.key.black:active, .key.black.pressed {
    background: linear-gradient(to bottom, #1a1a1a 0%, #101010 100%);
    transform: translateY(2px);
}

/* Breathing overlay */
.breath-overlay {
    position: fixed;
    inset: 0;
    pointer-events: none;
    background: radial-gradient(ellipse at center, transparent 0%, var(--void) 100%);
    opacity: 0.3;
    animation: breathe 8s ease-in-out infinite;
}

@keyframes breathe {
    0%, 100% { opacity: 0.2; }
    50% { opacity: 0.4; }
}

/* Responsive */
@media (max-width: 600px) {
    .controls { gap: 1.5rem; bottom: 100px; }
    .knob { width: 40px; height: 40px; }
    .keyboard { height: 100px; }
    .key.white { width: 32px; height: 70px; }
    .key.black { width: 20px; height: 44px; margin: 0 -10px; }
}

/* Start prompt */
.start-prompt {
    position: fixed;
    inset: 0;
    background: var(--void);
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    gap: 1rem;
    z-index: 1000;
    cursor: pointer;
    transition: opacity 0.8s;
}

.start-prompt.hidden {
    opacity: 0;
    pointer-events: none;
}

.start-text {
    font-size: 0.7rem;
    letter-spacing: 0.3em;
    text-transform: uppercase;
    opacity: 0.5;
    animation: pulse 2s ease-in-out infinite;
}

@keyframes pulse {
    0%, 100% { opacity: 0.3; }
    50% { opacity: 0.7; }
}
    </style>
</head>
<body>
    <div class="start-prompt" id="start">
        <div class="start-text">touch to begin</div>
    </div>
    
    <div class="cursor" id="cursor"></div>
    
    <div class="instrument">
        <div class="display">
            <canvas id="visualization"></canvas>
            
            <div class="engine-indicator">
                <div class="engine-dot active" data-engine="0" title="fold"></div>
                <div class="engine-dot" data-engine="1" title="cusp"></div>
                <div class="engine-dot" data-engine="2" title="swallowtail"></div>
                <div class="engine-dot" data-engine="3" title="butterfly"></div>
                <div class="engine-dot" data-engine="4" title="hyperbolic"></div>
                <div class="engine-dot" data-engine="5" title="elliptic"></div>
                <div class="engine-dot" data-engine="6" title="parabolic"></div>
            </div>
            
            <div class="controls">
                <div class="knob-wrap">
                    <div class="knob" data-param="density" id="knob-0"></div>
                    <span class="knob-label">density</span>
                </div>
                <div class="knob-wrap">
                    <div class="knob" data-param="space" id="knob-1"></div>
                    <span class="knob-label">space</span>
                </div>
                <div class="knob-wrap">
                    <div class="knob" data-param="movement" id="knob-2"></div>
                    <span class="knob-label">movement</span>
                </div>
                <div class="knob-wrap">
                    <div class="knob" data-param="warmth" id="knob-3"></div>
                    <span class="knob-label">warmth</span>
                </div>
            </div>
        </div>
        
        <div class="keyboard" id="keyboard"></div>
    </div>
    
    <div class="breath-overlay"></div>

<script>
// ═══════════════════════════════════════════════════════════════════════════════
// KATASTROPHE — Living Instrument
// Generative ambient synthesis with catastrophe mathematics
// ═══════════════════════════════════════════════════════════════════════════════

const ENGINES = [
    { name: 'fold', color: [255, 68, 34], freq: 0.5 },
    { name: 'cusp', color: [255, 170, 0], freq: 0.7 },
    { name: 'swallowtail', color: [0, 255, 204], freq: 0.6 },
    { name: 'butterfly', color: [187, 68, 255], freq: 0.8 },
    { name: 'hyperbolic', color: [255, 221, 0], freq: 0.55 },
    { name: 'elliptic', color: [34, 255, 102], freq: 0.65 },
    { name: 'parabolic', color: [68, 170, 255], freq: 0.75 }
];

// State
let ctx = null;
let masterGain = null;
let reverbGain = null;
let convolver = null;
let currentEngine = 0;
let params = { density: 0.3, space: 0.5, movement: 0.4, warmth: 0.6 };
let isStarted = false;
let activeVoices = new Map();
let generativeVoices = [];
let breathPhase = 0;
let lastNoteTime = 0;

// Canvas
const canvas = document.getElementById('visualization');
const canvasCtx = canvas.getContext('2d');
let particles = [];

// ═══════════════════════════════════════════════════════════════════════════════
// AUDIO ENGINE
// ═══════════════════════════════════════════════════════════════════════════════

async function initAudio() {
    ctx = new (window.AudioContext || window.webkitAudioContext)();
    
    // Create reverb
    convolver = ctx.createConvolver();
    const reverbTime = 4;
    const sampleRate = ctx.sampleRate;
    const length = sampleRate * reverbTime;
    const impulse = ctx.createBuffer(2, length, sampleRate);
    
    for (let channel = 0; channel < 2; channel++) {
        const data = impulse.getChannelData(channel);
        for (let i = 0; i < length; i++) {
            data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
        }
    }
    convolver.buffer = impulse;
    
    // Reverb mix
    reverbGain = ctx.createGain();
    reverbGain.gain.value = 0.4;
    
    // Master
    masterGain = ctx.createGain();
    masterGain.gain.value = 0.3;
    
    // Routing
    convolver.connect(reverbGain);
    reverbGain.connect(masterGain);
    masterGain.connect(ctx.destination);
    
    // Start generative composition
    startGenerative();
}

// Pentatonic scale for pleasant ambient
const SCALE = [0, 2, 4, 7, 9, 12, 14, 16, 19, 21]; // C pentatonic across 2 octaves
const BASE_NOTE = 48; // C3

function getScaleNote(index) {
    const octave = Math.floor(index / SCALE.length);
    const note = SCALE[index % SCALE.length];
    return BASE_NOTE + note + (octave * 12);
}

function midiToFreq(midi) {
    return 440 * Math.pow(2, (midi - 69) / 12);
}

// Create a gentle voice
function createAmbientVoice(freq, duration, velocity = 0.3) {
    if (!ctx) return null;
    
    const now = ctx.currentTime;
    const engine = ENGINES[currentEngine];
    
    // Oscillators - warm detuned pair
    const osc1 = ctx.createOscillator();
    const osc2 = ctx.createOscillator();
    
    osc1.type = 'sine';
    osc2.type = 'triangle';
    
    osc1.frequency.value = freq;
    osc2.frequency.value = freq * (1 + params.warmth * 0.01); // Slight detune
    
    // Filter
    const filter = ctx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = 800 + params.warmth * 2000;
    filter.Q.value = 0.5 + params.space * 2;
    
    // Envelope
    const env = ctx.createGain();
    env.gain.value = 0;
    
    // Slow attack, long release
    const attack = 0.5 + params.space * 1;
    const release = 1 + params.space * 3;
    
    env.gain.setValueAtTime(0, now);
    env.gain.linearRampToValueAtTime(velocity * 0.2, now + attack);
    env.gain.linearRampToValueAtTime(velocity * 0.15, now + duration * 0.5);
    env.gain.linearRampToValueAtTime(0, now + duration + release);
    
    // Connect
    osc1.connect(filter);
    osc2.connect(filter);
    filter.connect(env);
    env.connect(convolver);
    env.connect(masterGain); // Dry signal too
    
    osc1.start(now);
    osc2.start(now);
    osc1.stop(now + duration + release + 0.5);
    osc2.stop(now + duration + release + 0.5);
    
    return { osc1, osc2, env, filter, endTime: now + duration + release };
}

// Generative composition
function startGenerative() {
    scheduleNextNote();
}

function scheduleNextNote() {
    if (!ctx || !isStarted) return;
    
    const now = ctx.currentTime;
    const engine = ENGINES[currentEngine];
    
    // Time between notes based on density (inverse)
    const interval = 2 + (1 - params.density) * 6; // 2-8 seconds
    
    // Choose note from scale - weighted toward lower notes
    const noteIndex = Math.floor(Math.pow(Math.random(), 1.5) * SCALE.length * 1.5);
    const midiNote = getScaleNote(noteIndex);
    const freq = midiToFreq(midiNote);
    
    // Duration
    const duration = 3 + params.space * 5;
    
    // Create voice
    const voice = createAmbientVoice(freq, duration, 0.15 + params.density * 0.15);
    if (voice) {
        generativeVoices.push(voice);
        
        // Add particle for visualization
        addParticle(freq, duration);
    }
    
    // Occasionally add a chord
    if (Math.random() < params.density * 0.3) {
        const chordNote = midiNote + (Math.random() < 0.5 ? 7 : 5); // Fifth or fourth
        setTimeout(() => {
            const chordVoice = createAmbientVoice(midiToFreq(chordNote), duration * 0.8, 0.1);
            if (chordVoice) generativeVoices.push(chordVoice);
        }, 200 + Math.random() * 500);
    }
    
    // Clean up old voices
    generativeVoices = generativeVoices.filter(v => v.endTime > now);
    
    // Schedule next
    setTimeout(scheduleNextNote, interval * 1000);
}

// User plays a note
function playNote(midiNote) {
    if (!ctx) return;
    if (ctx.state === 'suspended') ctx.resume();
    
    const freq = midiToFreq(midiNote);
    const now = ctx.currentTime;
    
    // Oscillators
    const osc1 = ctx.createOscillator();
    const osc2 = ctx.createOscillator();
    
    osc1.type = 'triangle';
    osc2.type = 'sine';
    
    osc1.frequency.value = freq;
    osc2.frequency.value = freq * 2; // Octave up, quieter
    
    // Filter
    const filter = ctx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = 1500 + params.warmth * 3000;
    filter.Q.value = 1;
    
    // Envelope
    const env = ctx.createGain();
    env.gain.value = 0;
    env.gain.setValueAtTime(0, now);
    env.gain.linearRampToValueAtTime(0.25, now + 0.02);
    env.gain.linearRampToValueAtTime(0.15, now + 0.1);
    
    // Second osc quieter
    const env2 = ctx.createGain();
    env2.gain.value = 0.1;
    
    // Connect
    osc1.connect(filter);
    osc2.connect(env2);
    env2.connect(filter);
    filter.connect(env);
    env.connect(convolver);
    env.connect(masterGain);
    
    osc1.start(now);
    osc2.start(now);
    
    activeVoices.set(midiNote, { osc1, osc2, env, filter });
    
    // Add particle
    addParticle(freq, 2, true);
    
    // Visual feedback
    const key = document.querySelector(`[data-note="${midiNote}"]`);
    if (key) key.classList.add('pressed');
}

function releaseNote(midiNote) {
    const voice = activeVoices.get(midiNote);
    if (!voice) return;
    
    const now = ctx.currentTime;
    const release = 0.5 + params.space * 1;
    
    voice.env.gain.cancelScheduledValues(now);
    voice.env.gain.setValueAtTime(voice.env.gain.value, now);
    voice.env.gain.linearRampToValueAtTime(0, now + release);
    
    voice.osc1.stop(now + release + 0.1);
    voice.osc2.stop(now + release + 0.1);
    
    activeVoices.delete(midiNote);
    
    const key = document.querySelector(`[data-note="${midiNote}"]`);
    if (key) key.classList.remove('pressed');
}

// ═══════════════════════════════════════════════════════════════════════════════
// VISUALIZATION
// ═══════════════════════════════════════════════════════════════════════════════

function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}

function addParticle(freq, duration, isUser = false) {
    const engine = ENGINES[currentEngine];
    const x = Math.random() * canvas.width;
    const y = canvas.height * 0.3 + Math.random() * canvas.height * 0.4;
    
    particles.push({
        x, y,
        size: isUser ? 30 + Math.random() * 20 : 10 + Math.random() * 20,
        life: 0,
        maxLife: duration * 60,
        freq,
        color: engine.color,
        isUser,
        vx: (Math.random() - 0.5) * params.movement * 2,
        vy: (Math.random() - 0.5) * params.movement * 2
    });
}

function drawVisualization() {
    const w = canvas.width;
    const h = canvas.height;
    const engine = ENGINES[currentEngine];
    
    // Breathing background
    breathPhase += 0.005;
    const breathAmt = Math.sin(breathPhase) * 0.5 + 0.5;
    
    // Clear with subtle fade
    canvasCtx.fillStyle = `rgba(10, 10, 11, ${0.1 + breathAmt * 0.05})`;
    canvasCtx.fillRect(0, 0, w, h);
    
    // Draw particles
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.life++;
        p.x += p.vx;
        p.y += p.vy;
        
        // Gentle gravity toward center
        p.vx += (w/2 - p.x) * 0.00005 * params.movement;
        p.vy += (h/2 - p.y) * 0.00005 * params.movement;
        
        if (p.life > p.maxLife) {
            particles.splice(i, 1);
            continue;
        }
        
        const progress = p.life / p.maxLife;
        const alpha = Math.sin(progress * Math.PI) * 0.6;
        const size = p.size * (1 - progress * 0.5);
        
        // Glow
        const gradient = canvasCtx.createRadialGradient(p.x, p.y, 0, p.x, p.y, size * 2);
        gradient.addColorStop(0, `rgba(${p.color[0]}, ${p.color[1]}, ${p.color[2]}, ${alpha * 0.8})`);
        gradient.addColorStop(0.5, `rgba(${p.color[0]}, ${p.color[1]}, ${p.color[2]}, ${alpha * 0.2})`);
        gradient.addColorStop(1, `rgba(${p.color[0]}, ${p.color[1]}, ${p.color[2]}, 0)`);
        
        canvasCtx.beginPath();
        canvasCtx.arc(p.x, p.y, size * 2, 0, Math.PI * 2);
        canvasCtx.fillStyle = gradient;
        canvasCtx.fill();
        
        // Core
        canvasCtx.beginPath();
        canvasCtx.arc(p.x, p.y, size * 0.3, 0, Math.PI * 2);
        canvasCtx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.8})`;
        canvasCtx.fill();
    }
    
    // Central breathing glow
    const centerGlow = canvasCtx.createRadialGradient(w/2, h/2, 0, w/2, h/2, h * 0.4);
    centerGlow.addColorStop(0, `rgba(${engine.color[0]}, ${engine.color[1]}, ${engine.color[2]}, ${0.02 + breathAmt * 0.02})`);
    centerGlow.addColorStop(1, 'transparent');
    canvasCtx.fillStyle = centerGlow;
    canvasCtx.fillRect(0, 0, w, h);
    
    requestAnimationFrame(drawVisualization);
}

// ═══════════════════════════════════════════════════════════════════════════════
// UI
// ═══════════════════════════════════════════════════════════════════════════════

// Keyboard
function initKeyboard() {
    const keyboard = document.getElementById('keyboard');
    keyboard.innerHTML = '';
    
    // Two octaves from C4
    const notes = [
        { note: 60, black: false }, { note: 61, black: true },
        { note: 62, black: false }, { note: 63, black: true },
        { note: 64, black: false }, { note: 65, black: false },
        { note: 66, black: true }, { note: 67, black: false },
        { note: 68, black: true }, { note: 69, black: false },
        { note: 70, black: true }, { note: 71, black: false },
        { note: 72, black: false }, { note: 73, black: true },
        { note: 74, black: false }, { note: 75, black: true },
        { note: 76, black: false }
    ];
    
    notes.forEach(({ note, black }) => {
        const key = document.createElement('div');
        key.className = `key ${black ? 'black' : 'white'}`;
        key.dataset.note = note;
        
        key.addEventListener('mousedown', () => playNote(note));
        key.addEventListener('mouseup', () => releaseNote(note));
        key.addEventListener('mouseleave', () => releaseNote(note));
        key.addEventListener('touchstart', (e) => { e.preventDefault(); playNote(note); }, { passive: false });
        key.addEventListener('touchend', () => releaseNote(note));
        
        keyboard.appendChild(key);
    });
}

// QWERTY
const keyMap = {
    'a': 60, 'w': 61, 's': 62, 'e': 63, 'd': 64,
    'f': 65, 't': 66, 'g': 67, 'y': 68, 'h': 69,
    'u': 70, 'j': 71, 'k': 72, 'o': 73, 'l': 74,
    'p': 75, ';': 76
};

document.addEventListener('keydown', (e) => {
    if (e.repeat) return;
    const note = keyMap[e.key.toLowerCase()];
    if (note && !activeVoices.has(note)) playNote(note);
});

document.addEventListener('keyup', (e) => {
    const note = keyMap[e.key.toLowerCase()];
    if (note) releaseNote(note);
});

// Knobs
function initKnobs() {
    const knobs = document.querySelectorAll('.knob');
    const paramNames = ['density', 'space', 'movement', 'warmth'];
    
    knobs.forEach((knob, i) => {
        const param = paramNames[i];
        let isDragging = false;
        let startY, startValue;
        
        function updateKnob(value) {
            params[param] = Math.max(0, Math.min(1, value));
            const angle = params[param] * 270 - 135;
            knob.style.transform = `rotate(${angle}deg)`;
        }
        
        updateKnob(params[param]);
        
        knob.addEventListener('mousedown', (e) => {
            isDragging = true;
            startY = e.clientY;
            startValue = params[param];
        });
        
        knob.addEventListener('touchstart', (e) => {
            isDragging = true;
            startY = e.touches[0].clientY;
            startValue = params[param];
        }, { passive: true });
        
        window.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            const delta = (startY - e.clientY) / 150;
            updateKnob(startValue + delta);
        });
        
        window.addEventListener('touchmove', (e) => {
            if (!isDragging) return;
            const delta = (startY - e.touches[0].clientY) / 150;
            updateKnob(startValue + delta);
        }, { passive: true });
        
        window.addEventListener('mouseup', () => isDragging = false);
        window.addEventListener('touchend', () => isDragging = false);
        
        knob.addEventListener('wheel', (e) => {
            e.preventDefault();
            updateKnob(params[param] + (e.deltaY > 0 ? -0.03 : 0.03));
        });
    });
}

// Engine selector
document.querySelectorAll('.engine-dot').forEach(dot => {
    dot.addEventListener('click', () => {
        currentEngine = parseInt(dot.dataset.engine);
        document.querySelectorAll('.engine-dot').forEach(d => d.classList.remove('active'));
        dot.classList.add('active');
    });
});

// Custom cursor
const cursor = document.getElementById('cursor');
document.addEventListener('mousemove', (e) => {
    cursor.style.left = e.clientX - 10 + 'px';
    cursor.style.top = e.clientY - 10 + 'px';
});

document.addEventListener('mousedown', () => cursor.classList.add('active'));
document.addEventListener('mouseup', () => cursor.classList.remove('active'));

// Start
document.getElementById('start').addEventListener('click', async () => {
    if (isStarted) return;
    isStarted = true;
    
    await initAudio();
    document.getElementById('start').classList.add('hidden');
});

// Init
window.addEventListener('load', () => {
    resizeCanvas();
    initKeyboard();
    initKnobs();
    drawVisualization();
});

window.addEventListener('resize', resizeCanvas);
</script>
</body>
</html>
