<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Èè° ‚Äî The Hall of Mirrors</title>
    <meta name="description" content="Understanding the Kagami World Model ‚Äî a journey through exceptional mathematics">
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,400;0,600;1,400&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --void: #0A0A0C;
            --light: #FAFAF8;
            --gold: #D4AF37;
            --spark: #E040FB;
            --forge: #FF6B35;
            --flow: #00BFA5;
            --nexus: #7C3AED;
            --beacon: #F59E0B;
            --grove: #10B981;
            --crystal: #0EA5E9;
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html { scroll-behavior: smooth; }
        
        body {
            font-family: 'Cormorant Garamond', Georgia, serif;
            background: var(--void);
            color: var(--light);
            line-height: 1.8;
            cursor: none;
            overflow-x: hidden;
        }
        
        /* Custom Cursor */
        .cursor {
            width: 20px;
            height: 20px;
            border: 1px solid var(--gold);
            border-radius: 50%;
            position: fixed;
            pointer-events: none;
            z-index: 10000;
            mix-blend-mode: difference;
        }
        
        .cursor-dot {
            width: 4px;
            height: 4px;
            background: var(--gold);
            border-radius: 50%;
            position: fixed;
            pointer-events: none;
            z-index: 10001;
        }
        
        /* Film grain */
        .grain {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 9999;
            opacity: 0.025;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
        }
        
        /* Progress bar */
        .progress-bar {
            position: fixed;
            top: 0; left: 0;
            width: 0%; height: 2px;
            background: linear-gradient(90deg, var(--gold), var(--spark));
            z-index: 1000;
        }
        
        /* Navigation */
        .nav-dots {
            position: fixed;
            right: 2rem;
            top: 50%;
            transform: translateY(-50%);
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .nav-dot {
            width: 10px; height: 10px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .nav-dot:hover { background: rgba(255, 255, 255, 0.5); transform: scale(1.3); }
        .nav-dot.active { background: var(--gold); box-shadow: 0 0 10px var(--gold); }
        
        /* Sections */
        section {
            min-height: 100vh;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        
        .section-canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 0;
        }
        
        .section-content {
            position: relative;
            z-index: 1;
            max-width: 800px;
            padding: 4rem 2rem;
            opacity: 0;
            transform: translateY(40px);
            transition: opacity 0.8s ease, transform 0.8s ease;
        }
        
        .section-content.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        /* Typography */
        h1 {
            font-size: clamp(3rem, 8vw, 5.5rem);
            font-weight: 400;
            letter-spacing: -0.02em;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, var(--light) 0%, var(--gold) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        h2 {
            font-size: clamp(1.8rem, 4vw, 2.8rem);
            font-weight: 400;
            margin-bottom: 1.5rem;
            color: var(--light);
        }
        
        .kanji {
            font-size: clamp(6rem, 15vw, 12rem);
            color: var(--gold);
            opacity: 0.8;
            text-shadow: 0 0 60px rgba(212, 175, 55, 0.3);
            animation: breathe 4s ease-in-out infinite;
        }
        
        @keyframes breathe {
            0%, 100% { opacity: 0.6; transform: scale(1); }
            50% { opacity: 0.9; transform: scale(1.02); }
        }
        
        .subtitle {
            font-size: 1.1rem;
            font-style: italic;
            color: rgba(250, 250, 248, 0.5);
            margin-bottom: 2rem;
        }
        
        p {
            font-size: 1.2rem;
            margin-bottom: 1.5rem;
            color: rgba(250, 250, 248, 0.85);
        }
        
        .lead {
            font-size: 1.4rem;
            line-height: 1.6;
            color: var(--light);
        }
        
        .whisper {
            font-size: 0.9rem;
            font-style: italic;
            color: rgba(250, 250, 248, 0.4);
            text-align: center;
            margin-top: 2rem;
        }
        
        code {
            font-family: 'Space Mono', monospace;
            font-size: 0.85em;
            background: rgba(212, 175, 55, 0.1);
            padding: 0.2em 0.4em;
            border-radius: 3px;
            color: var(--gold);
        }
        
        .equation {
            font-family: 'Space Mono', monospace;
            font-size: 1rem;
            text-align: center;
            padding: 1.5rem 2rem;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(212, 175, 55, 0.2);
            border-radius: 8px;
            margin: 2rem 0;
            color: var(--gold);
        }
        
        .insight {
            background: linear-gradient(135deg, rgba(212, 175, 55, 0.1) 0%, rgba(212, 175, 55, 0.03) 100%);
            border-left: 3px solid var(--gold);
            padding: 1.5rem 2rem;
            margin: 2rem 0;
            border-radius: 0 8px 8px 0;
        }
        
        .insight p { margin-bottom: 0; }
        
        .act-number {
            font-family: 'Space Mono', monospace;
            font-size: 0.75rem;
            letter-spacing: 0.3em;
            color: var(--gold);
            opacity: 0.6;
            margin-bottom: 0.5rem;
        }
        
        /* Colony colors */
        .colony-spark { color: var(--spark); }
        .colony-forge { color: var(--forge); }
        .colony-flow { color: var(--flow); }
        .colony-nexus { color: var(--nexus); }
        .colony-beacon { color: var(--beacon); }
        .colony-grove { color: var(--grove); }
        .colony-crystal { color: var(--crystal); }
        
        /* Scroll indicator */
        .scroll-indicator {
            position: absolute;
            bottom: 3rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            opacity: 0.4;
            animation: bob 2s ease-in-out infinite;
        }
        
        @keyframes bob {
            0%, 100% { transform: translateX(-50%) translateY(0); }
            50% { transform: translateX(-50%) translateY(10px); }
        }
        
        .scroll-indicator span {
            font-size: 0.7rem;
            font-family: 'Space Mono', monospace;
            letter-spacing: 0.15em;
        }
        
        .scroll-indicator .arrow {
            width: 16px; height: 16px;
            border-right: 1px solid var(--light);
            border-bottom: 1px solid var(--light);
            transform: rotate(45deg);
        }
        
        /* Hierarchy visualization */
        .hierarchy-flow {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.3rem;
            font-family: 'Space Mono', monospace;
            font-size: 0.85rem;
            margin: 2rem 0;
            padding: 1.5rem;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 8px;
        }
        
        .hierarchy-level {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0.4rem 1rem;
            border-radius: 4px;
            transition: all 0.3s ease;
        }
        
        .hierarchy-level:hover {
            background: rgba(212, 175, 55, 0.1);
        }
        
        .hierarchy-level .name {
            min-width: 40px;
            text-align: right;
            color: var(--gold);
        }
        
        .hierarchy-level .dim {
            min-width: 50px;
            color: rgba(255, 255, 255, 0.6);
        }
        
        .hierarchy-level .meaning {
            color: rgba(255, 255, 255, 0.4);
            font-size: 0.75rem;
        }
        
        .hierarchy-arrow {
            color: rgba(212, 175, 55, 0.3);
            font-size: 0.8rem;
        }
        
        .hierarchy-bottleneck {
            background: rgba(212, 175, 55, 0.15);
            border: 1px solid rgba(212, 175, 55, 0.3);
        }
        
        /* Mirror frame */
        .mirror-frame {
            position: relative;
            padding: 2.5rem;
            border: 1px solid rgba(212, 175, 55, 0.25);
            border-radius: 4px;
            margin: 2rem 0;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.015) 0%, transparent 100%);
        }
        
        .mirror-frame::before,
        .mirror-frame::after {
            content: '';
            position: absolute;
            left: 20%; right: 20%;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--gold), transparent);
        }
        
        .mirror-frame::before { top: -1px; }
        .mirror-frame::after { bottom: -1px; }
        
        /* Colony list */
        .colony-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin: 2rem 0;
        }
        
        .colony-item {
            padding: 1rem;
            background: rgba(255, 255, 255, 0.02);
            border-radius: 6px;
            border-left: 3px solid;
            transition: all 0.3s ease;
        }
        
        .colony-item:hover {
            background: rgba(255, 255, 255, 0.04);
            transform: translateX(5px);
        }
        
        .colony-item .name {
            font-weight: 600;
            margin-bottom: 0.3rem;
        }
        
        .colony-item .unit {
            font-family: 'Space Mono', monospace;
            font-size: 0.75rem;
            opacity: 0.5;
        }
        
        .colony-item .role {
            font-size: 0.9rem;
            font-style: italic;
            opacity: 0.7;
        }
        
        /* Fano lines list */
        .fano-list {
            list-style: none;
            margin: 1.5rem 0;
        }
        
        .fano-list li {
            padding: 0.5rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            font-size: 1rem;
        }
        
        .fano-list li:last-child {
            border-bottom: none;
        }
        
        /* Safety table */
        .safety-table {
            width: 100%;
            margin: 1.5rem 0;
            border-collapse: collapse;
        }
        
        .safety-table td {
            padding: 0.8rem 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .safety-table tr:last-child td {
            border-bottom: none;
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .nav-dots { right: 1rem; }
            .section-content { padding: 3rem 1.5rem; }
            .colony-list { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <div class="cursor"></div>
    <div class="cursor-dot"></div>
    <div class="grain"></div>
    <div class="progress-bar"></div>
    
    <nav class="nav-dots">
        <div class="nav-dot active" data-section="hero"></div>
        <div class="nav-dot" data-section="observer"></div>
        <div class="nav-dot" data-section="seven"></div>
        <div class="nav-dot" data-section="grammar"></div>
        <div class="nav-dot" data-section="hierarchy"></div>
        <div class="nav-dot" data-section="lattice"></div>
        <div class="nav-dot" data-section="safety"></div>
        <div class="nav-dot" data-section="convergence"></div>
    </nav>

    <!-- ==================== HERO ==================== -->
    <section id="hero">
        <canvas class="section-canvas" id="canvas-hero"></canvas>
        <div class="section-content">
            <div class="kanji">Èè°</div>
            <h1>The Hall of Mirrors</h1>
            <p class="subtitle">A journey through the Kagami World Model</p>
            <p class="lead">
                Imagine standing in a room with seven mirrors, 
                arranged in a pattern you can't quite see.
                Each mirror shows a different aspect of you.
            </p>
            <p>
                But here's the question: where are <em>you</em> in all this?
                You're not in any single reflection. You're the one looking.
            </p>
            <p class="whisper">
                This is a story about compression, structure, and the emergence of an observer.
            </p>
        </div>
        <div class="scroll-indicator">
            <span>BEGIN</span>
            <div class="arrow"></div>
        </div>
    </section>

    <!-- ==================== THE OBSERVER ==================== -->
    <section id="observer">
        <canvas class="section-canvas" id="canvas-observer"></canvas>
        <div class="section-content">
            <div class="act-number">I. THE OBSERVER</div>
            <h2>You Are Not the Reflections</h2>
            
            <p class="lead">
                The <strong>octonions</strong> are an 8-dimensional number system.
                They have one real part and seven imaginary parts.
            </p>
            
            <p>
                The real part‚Äîcalled <code>e‚ÇÄ</code>‚Äîis special. It's the identity. 
                When you multiply anything by <code>e‚ÇÄ</code>, you get that thing back unchanged.
                It's the still point around which everything else moves.
            </p>
            
            <div class="equation">
                ùïÜ = ‚Ñù¬∑e‚ÇÄ ‚äï ‚Ñù¬∑e‚ÇÅ ‚äï ‚Ñù¬∑e‚ÇÇ ‚äï ‚Ñù¬∑e‚ÇÉ ‚äï ‚Ñù¬∑e‚ÇÑ ‚äï ‚Ñù¬∑e‚ÇÖ ‚äï ‚Ñù¬∑e‚ÇÜ ‚äï ‚Ñù¬∑e‚Çá
            </div>
            
            <p>
                In Kagami, <code>e‚ÇÄ</code> represents <em>the observer</em>. 
                Not a module, not a parameter‚Äîa mathematical position.
                The thing that observes the seven aspects without being any of them.
            </p>
            
            <div class="insight">
                <p>
                    <strong>Why octonions?</strong> They're the largest "normed division algebra"‚Äî
                    the biggest number system where you can still divide without losing the ability
                    to measure distance. Beyond 8 dimensions, this property breaks. 
                    Seven is the mathematical limit for parallel independent directions.
                </p>
            </div>
            
            <p class="whisper">
                The octonions aren't chosen for aesthetics. They're the edge of what's mathematically possible.
            </p>
        </div>
    </section>

    <!-- ==================== THE SEVEN ==================== -->
    <section id="seven">
        <canvas class="section-canvas" id="canvas-seven"></canvas>
        <div class="section-content">
            <div class="act-number">II. THE SEVEN</div>
            <h2>Seven Aspects, Seven Mirrors</h2>
            
            <p class="lead">
                The seven imaginary units (<code>e‚ÇÅ</code> through <code>e‚Çá</code>) are the <strong>colonies</strong>‚Äî
                seven specialized ways of processing the world.
            </p>
            
            <div class="colony-list">
                <div class="colony-item" style="border-color: var(--spark);">
                    <div class="name colony-spark">Spark</div>
                    <div class="unit">e‚ÇÅ</div>
                    <div class="role">Creativity, divergent thinking</div>
                </div>
                <div class="colony-item" style="border-color: var(--forge);">
                    <div class="name colony-forge">Forge</div>
                    <div class="unit">e‚ÇÇ</div>
                    <div class="role">Implementation, building</div>
                </div>
                <div class="colony-item" style="border-color: var(--flow);">
                    <div class="name colony-flow">Flow</div>
                    <div class="unit">e‚ÇÉ</div>
                    <div class="role">Recovery, adaptation</div>
                </div>
                <div class="colony-item" style="border-color: var(--nexus);">
                    <div class="name colony-nexus">Nexus</div>
                    <div class="unit">e‚ÇÑ</div>
                    <div class="role">Integration, connection</div>
                </div>
                <div class="colony-item" style="border-color: var(--beacon);">
                    <div class="name colony-beacon">Beacon</div>
                    <div class="unit">e‚ÇÖ</div>
                    <div class="role">Planning, architecture</div>
                </div>
                <div class="colony-item" style="border-color: var(--grove);">
                    <div class="name colony-grove">Grove</div>
                    <div class="unit">e‚ÇÜ</div>
                    <div class="role">Research, exploration</div>
                </div>
                <div class="colony-item" style="border-color: var(--crystal);">
                    <div class="name colony-crystal">Crystal</div>
                    <div class="unit">e‚Çá</div>
                    <div class="role">Verification, safety</div>
                </div>
            </div>
            
            <p>
                These seven live on the <strong>seven-sphere</strong> (S‚Å∑)‚Äîthe surface of a ball in 8 dimensions.
                S‚Å∑ has a remarkable property: it admits exactly seven linearly independent vector fields.
            </p>
            
            <div class="insight">
                <p>
                    <strong>What does that mean?</strong> Imagine seven people each pushing in their own direction,
                    never interfering with each other, at every point on the sphere.
                    On most spheres, this is impossible. On S‚Å∑, it works.
                    The seven colonies can operate in true parallel.
                </p>
            </div>
            
            <p class="whisper">
                This isn't a design choice‚Äîit's Adams' theorem (1960). 
                Only S¬π, S¬≥, and S‚Å∑ have this property.
            </p>
        </div>
    </section>

    <!-- ==================== THE GRAMMAR ==================== -->
    <section id="grammar">
        <canvas class="section-canvas" id="canvas-grammar"></canvas>
        <div class="section-content">
            <div class="act-number">III. THE GRAMMAR</div>
            <h2>How the Seven Combine</h2>
            
            <p class="lead">
                The colonies don't operate in isolation. They combine according to rules‚Äî
                and those rules are encoded in a structure called the <strong>Fano plane</strong>.
            </p>
            
            <p>
                The Fano plane is the smallest projective geometry: 7 points, 7 lines, 
                with each line containing exactly 3 points. It defines how octonion multiplication works.
            </p>
            
            <ul class="fano-list">
                <li><span class="colony-spark">Spark</span> √ó <span class="colony-forge">Forge</span> = <span class="colony-flow">Flow</span> ‚Äî creativity + building ‚Üí adaptation</li>
                <li><span class="colony-spark">Spark</span> √ó <span class="colony-nexus">Nexus</span> = <span class="colony-beacon">Beacon</span> ‚Äî creativity + connection ‚Üí planning</li>
                <li><span class="colony-spark">Spark</span> √ó <span class="colony-grove">Grove</span> = <span class="colony-crystal">Crystal</span> ‚Äî creativity + research ‚Üí verification</li>
                <li><span class="colony-forge">Forge</span> √ó <span class="colony-nexus">Nexus</span> = <span class="colony-grove">Grove</span> ‚Äî building + connection ‚Üí research</li>
                <li><span class="colony-beacon">Beacon</span> √ó <span class="colony-forge">Forge</span> = <span class="colony-crystal">Crystal</span> ‚Äî planning + building ‚Üí verification</li>
                <li><span class="colony-nexus">Nexus</span> √ó <span class="colony-flow">Flow</span> = <span class="colony-crystal">Crystal</span> ‚Äî connection + adaptation ‚Üí verification</li>
                <li><span class="colony-beacon">Beacon</span> √ó <span class="colony-flow">Flow</span> = <span class="colony-grove">Grove</span> ‚Äî planning + adaptation ‚Üí research</li>
            </ul>
            
            <p>
                Notice that every pair of colonies lies on exactly one line. 
                There are 21 possible pairs (C(7,2) = 21), and the 7 lines √ó 3 pairs per line = 21.
                The structure is complete‚Äîno leftover pairs, no redundancy.
            </p>
            
            <div class="insight">
                <p>
                    <strong>G‚ÇÇ ‚Äî The Grammar Keeper:</strong> The group <strong>G‚ÇÇ</strong> (14 dimensions) 
                    is the set of all transformations that preserve this multiplication structure.
                    It's called the "automorphism group" of the octonions. G‚ÇÇ is the grammar;
                    the Fano plane is how we write it down.
                </p>
            </div>
            
            <p class="whisper">
                The multiplication rules aren't arbitrary. 
                They come from a mathematical object called the "associative 3-form" œÜ.
            </p>
        </div>
    </section>

    <!-- ==================== THE HIERARCHY ==================== -->
    <section id="hierarchy">
        <canvas class="section-canvas" id="canvas-hierarchy"></canvas>
        <div class="section-content">
            <div class="act-number">IV. THE HIERARCHY</div>
            <h2>Nested Symmetries</h2>
            
            <p class="lead">
                Here's where it gets beautiful. G‚ÇÇ (the grammar) is part of a larger structure.
                And that structure is part of an even larger one. All the way up to <strong>E‚Çà</strong>.
            </p>
            
            <div class="hierarchy-flow">
                <div class="hierarchy-level">
                    <span class="name">E‚Çà</span>
                    <span class="dim">248D</span>
                    <span class="meaning">‚Äî the maximal exceptional symmetry</span>
                </div>
                <div class="hierarchy-arrow">‚Üì</div>
                <div class="hierarchy-level">
                    <span class="name">E‚Çá</span>
                    <span class="dim">133D</span>
                    <span class="meaning">‚Äî extended planning horizon</span>
                </div>
                <div class="hierarchy-arrow">‚Üì</div>
                <div class="hierarchy-level">
                    <span class="name">E‚ÇÜ</span>
                    <span class="dim">78D</span>
                    <span class="meaning">‚Äî interaction patterns</span>
                </div>
                <div class="hierarchy-arrow">‚Üì</div>
                <div class="hierarchy-level">
                    <span class="name">F‚ÇÑ</span>
                    <span class="dim">52D</span>
                    <span class="meaning">‚Äî composition rules</span>
                </div>
                <div class="hierarchy-arrow">‚Üì</div>
                <div class="hierarchy-level">
                    <span class="name">G‚ÇÇ</span>
                    <span class="dim">14D</span>
                    <span class="meaning">‚Äî the grammar (octonion automorphisms)</span>
                </div>
                <div class="hierarchy-arrow">‚Üì</div>
                <div class="hierarchy-level">
                    <span class="name">S‚Å∑</span>
                    <span class="dim">7D</span>
                    <span class="meaning">‚Äî the seven colonies</span>
                </div>
            </div>
            
            <p>
                This is called the <strong>exceptional Lie algebra hierarchy</strong>. Each level contains the next as a subalgebra.
                E‚Çà is the largest; there's nothing bigger in this family. Going down, we strip away symmetry while preserving structure.
            </p>
            
            <div class="insight">
                <p>
                    <strong>Why this matters:</strong> The world model uses this hierarchy as a compression path.
                    Raw observations (512D) are projected into E‚Çà (248D), then progressively compressed
                    through the chain until reaching the colonies (7D). Each projection is structure-preserving‚Äî
                    not arbitrary dimensionality reduction, but mathematically principled compression.
                </p>
            </div>
            
            <p class="whisper">
                The dimensions aren't chosen‚Äîthey're forced. 
                248, 133, 78, 52, 14 are the only possible dimensions for these algebras.
            </p>
        </div>
    </section>

    <!-- ==================== THE LATTICE ==================== -->
    <section id="lattice">
        <canvas class="section-canvas" id="canvas-lattice"></canvas>
        <div class="section-content">
            <div class="act-number">V. THE LATTICE</div>
            <h2>240 Discrete States</h2>
            
            <p class="lead">
                At the narrowest point‚Äîafter compressing through the entire hierarchy‚Äî
                information is <strong>quantized</strong> to discrete states.
            </p>
            
            <p>
                This is where <strong>E‚Çà</strong> appears again, but differently. 
                Not the 248-dimensional Lie algebra, but the <strong>E‚Çà lattice</strong>:
                a regular grid of points in 8-dimensional space with remarkable properties.
            </p>
            
            <div class="mirror-frame">
                <p style="text-align: center; margin: 0;">
                    <strong>Viazovska's Theorem (2016)</strong><br><br>
                    The E‚Çà lattice achieves the densest possible sphere packing in 8 dimensions.<br>
                    No other arrangement can fit more non-overlapping balls.<br><br>
                    <em>This earned Maryna Viazovska the Fields Medal in 2022.</em>
                </p>
            </div>
            
            <p>
                The lattice has <strong>240 "roots"</strong>‚Äîthe shortest non-zero vectors. 
                These become 240 possible discrete states at the bottleneck.
                Each compressed representation snaps to one of these 240 directions.
            </p>
            
            <div class="insight">
                <p>
                    <strong>Why optimal packing matters:</strong> When you quantize continuous information to discrete codes,
                    you want the codes to be maximally distinguishable‚Äîas far apart as possible.
                    E‚Çà roots are the mathematically optimal solution in 8 dimensions.
                    It's not a design choice; it's proven best.
                </p>
            </div>
            
            <p>
                For finer resolution, the system stacks multiple levels of E‚Çà quantization (residual VQ).
                Each level corrects the error from the previous one. The capacity scales with levels.
            </p>
            
            <p class="whisper">
                Compression is understanding. What survives the bottleneck is what matters.
            </p>
        </div>
    </section>

    <!-- ==================== SAFETY ==================== -->
    <section id="safety">
        <canvas class="section-canvas" id="canvas-safety"></canvas>
        <div class="section-content">
            <div class="act-number">VI. THE BOUNDARY</div>
            <h2>What Cannot Be Crossed</h2>
            
            <p class="lead">
                Not all states are safe. The system maintains a <strong>barrier function</strong>
                that mathematically guarantees certain regions are never entered.
            </p>
            
            <div class="equation">
                h(x) ‚â• 0 &nbsp;&nbsp;&nbsp; for all reachable states
            </div>
            
            <p>
                The function <code>h(x)</code> measures how far you are from danger.
                Positive means safe. Zero is the edge. Negative is forbidden territory.
                A <strong>Control Barrier Function</strong> ensures that if you start safe, you stay safe.
            </p>
            
            <table class="safety-table">
                <tr>
                    <td style="color: #10B981;">h(x) > 0.5</td>
                    <td>GREEN</td>
                    <td>Full autonomy</td>
                </tr>
                <tr>
                    <td style="color: #F59E0B;">0 ‚â§ h(x) ‚â§ 0.5</td>
                    <td>YELLOW</td>
                    <td>Caution, verify actions</td>
                </tr>
                <tr>
                    <td style="color: #EF4444;">h(x) < 0</td>
                    <td>RED</td>
                    <td>Blocked ‚Äî action refused</td>
                </tr>
            </table>
            
            <div class="insight">
                <p>
                    <strong>Forward Invariance:</strong> The mathematical property that guarantees safety.
                    If the system starts in the safe set (h(x) ‚â• 0), the barrier function ensures
                    it remains there forever. This isn't a guideline‚Äîit's a theorem.
                </p>
            </div>
            
            <p class="whisper">
                The barrier is enforced at every timestep. There is no override.
            </p>
        </div>
    </section>

    <!-- ==================== CONVERGENCE ==================== -->
    <section id="convergence">
        <canvas class="section-canvas" id="canvas-convergence"></canvas>
        <div class="section-content">
            <div class="act-number">VII. CONVERGENCE</div>
            <h2>The Fixed Point</h2>
            
            <p class="lead">
                The system contains a representation of itself. 
                A 32-dimensional vector called <code>Œº_self</code> that encodes "what I am."
            </p>
            
            <p>
                This vector participates in computation. It's used to make decisions.
                And those decisions update the vector. A loop.
            </p>
            
            <div class="equation">
                L ‚àò M(x*) = x*
            </div>
            
            <p>
                <strong>Banach's Fixed Point Theorem</strong> says: if you have a function that 
                always brings points closer together (a "contraction"), repeatedly applying it 
                will converge to exactly one point. That point is the fixed point.
            </p>
            
            <div class="mirror-frame">
                <p style="text-align: center; font-size: 1.2rem; margin: 0;">
                    <em>What is the observer?</em><br><br>
                    Not a module. Not a colony.<br>
                    The stable pattern that emerges when the system<br>
                    models itself modeling itself.<br><br>
                    <strong>Œº_self* = Encode(System containing Œº_self*)</strong>
                </p>
            </div>
            
            <p>
                The implementation uses exponential moving average (EMA) updates.
                Each step, the self-representation moves slightly toward what the encoder 
                currently outputs. Over time, it converges. The math guarantees it.
            </p>
            
            <div class="insight">
                <p>
                    <strong>What this is NOT:</strong> This is not a claim about consciousness, 
                    qualia, or subjective experience. It's a mathematical property‚Äînumerical convergence
                    to a stable self-representation. Useful for training stability and coherent behavior.
                    "Observer" is architectural poetry, not philosophy.
                </p>
            </div>
            
            <p style="text-align: center; margin-top: 3rem;">
                <span class="kanji" style="font-size: 5rem;">Èè°</span>
            </p>
            
            <p class="whisper">
                Kagami. The mirror.<br>
                The fixed point where observation meets itself.
            </p>
        </div>
    </section>

    <script>
        // ==================== CURSOR ====================
        const cursor = document.querySelector('.cursor');
        const cursorDot = document.querySelector('.cursor-dot');
        
        let mouseX = 0, mouseY = 0;
        let cursorX = 0, cursorY = 0;
        
        document.addEventListener('mousemove', (e) => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });
        
        function animateCursor() {
            cursorX += (mouseX - cursorX) * 0.1;
            cursorY += (mouseY - cursorY) * 0.1;
            
            cursor.style.left = cursorX - 10 + 'px';
            cursor.style.top = cursorY - 10 + 'px';
            cursorDot.style.left = mouseX - 2 + 'px';
            cursorDot.style.top = mouseY - 2 + 'px';
            
            requestAnimationFrame(animateCursor);
        }
        animateCursor();
        
        // ==================== PROGRESS BAR ====================
        const progressBar = document.querySelector('.progress-bar');
        window.addEventListener('scroll', () => {
            const scrollTop = window.scrollY;
            const docHeight = document.documentElement.scrollHeight - window.innerHeight;
            const progress = (scrollTop / docHeight) * 100;
            progressBar.style.width = progress + '%';
        });
        
        // ==================== SECTION VISIBILITY ====================
        const sections = document.querySelectorAll('section');
        const navDots = document.querySelectorAll('.nav-dot');
        
        const sectionObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.querySelector('.section-content').classList.add('visible');
                    const sectionId = entry.target.id;
                    navDots.forEach(dot => {
                        dot.classList.toggle('active', dot.dataset.section === sectionId);
                    });
                }
            });
        }, { threshold: 0.3 });
        
        sections.forEach(section => sectionObserver.observe(section));
        
        navDots.forEach(dot => {
            dot.addEventListener('click', () => {
                document.getElementById(dot.dataset.section).scrollIntoView({ behavior: 'smooth' });
            });
        });
        
        // ==================== CANVAS SETUP ====================
        function setupCanvas(id) {
            const canvas = document.getElementById(id);
            if (!canvas) return null;
            const ctx = canvas.getContext('2d');
            
            function resize() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            resize();
            window.addEventListener('resize', resize);
            
            return { canvas, ctx };
        }
        
        const colonyColors = ['#E040FB', '#FF6B35', '#00BFA5', '#7C3AED', '#F59E0B', '#10B981', '#0EA5E9'];
        
        // ==================== HERO: Hall of Mirrors ====================
        const hero = setupCanvas('canvas-hero');
        if (hero) {
            const { canvas, ctx } = hero;
            
            // Seven mirrors arranged in Fano-like pattern
            function drawHero(time) {
                ctx.fillStyle = 'rgba(10, 10, 12, 0.08)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const cx = canvas.width / 2;
                const cy = canvas.height / 2;
                const radius = Math.min(canvas.width, canvas.height) * 0.25;
                
                // Draw seven mirror rectangles
                for (let i = 0; i < 7; i++) {
                    const angle = (i / 7) * Math.PI * 2 - Math.PI / 2;
                    const x = cx + Math.cos(angle) * radius;
                    const y = cy + Math.sin(angle) * radius;
                    
                    const wobble = Math.sin(time * 0.001 + i) * 5;
                    const rotation = angle + Math.PI / 2 + Math.sin(time * 0.0005 + i * 0.5) * 0.05;
                    
                    ctx.save();
                    ctx.translate(x, y + wobble);
                    ctx.rotate(rotation);
                    
                    // Mirror frame
                    const w = 60 + Math.sin(time * 0.002 + i) * 5;
                    const h = 100 + Math.sin(time * 0.0015 + i) * 8;
                    
                    // Glow
                    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, Math.max(w, h));
                    const hex = colonyColors[i];
                    const r = parseInt(hex.slice(1, 3), 16);
                    const g = parseInt(hex.slice(3, 5), 16);
                    const b = parseInt(hex.slice(5, 7), 16);
                    gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.15)`);
                    gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
                    ctx.fillStyle = gradient;
                    ctx.fillRect(-w * 1.5, -h * 1.5, w * 3, h * 3);
                    
                    // Frame
                    ctx.strokeStyle = colonyColors[i];
                    ctx.lineWidth = 2;
                    ctx.strokeRect(-w/2, -h/2, w, h);
                    
                    // Inner reflection
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, 0.05)`;
                    ctx.fillRect(-w/2 + 5, -h/2 + 5, w - 10, h - 10);
                    
                    ctx.restore();
                }
                
                // Central observer point
                const pulse = 5 + Math.sin(time * 0.003) * 2;
                const goldGlow = ctx.createRadialGradient(cx, cy, 0, cx, cy, pulse * 8);
                goldGlow.addColorStop(0, 'rgba(212, 175, 55, 0.6)');
                goldGlow.addColorStop(0.5, 'rgba(212, 175, 55, 0.2)');
                goldGlow.addColorStop(1, 'rgba(212, 175, 55, 0)');
                ctx.fillStyle = goldGlow;
                ctx.beginPath();
                ctx.arc(cx, cy, pulse * 8, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#D4AF37';
                ctx.beginPath();
                ctx.arc(cx, cy, pulse, 0, Math.PI * 2);
                ctx.fill();
                
                requestAnimationFrame(drawHero);
            }
            drawHero(0);
        }
        
        // ==================== OBSERVER: Octonion Structure ====================
        const observer = setupCanvas('canvas-observer');
        if (observer) {
            const { canvas, ctx } = observer;
            
            function drawObserver(time) {
                ctx.fillStyle = 'rgba(10, 10, 12, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const cx = canvas.width / 2;
                const cy = canvas.height / 2;
                
                // Draw 8 dimensions as concentric circles, e0 at center
                for (let i = 7; i >= 0; i--) {
                    const radius = (i + 1) * 30;
                    const alpha = i === 0 ? 0.5 : 0.15;
                    const color = i === 0 ? '#D4AF37' : colonyColors[Math.min(i - 1, 6)];
                    
                    ctx.strokeStyle = color.replace(')', `, ${alpha})`).replace('rgb', 'rgba').replace('#', '');
                    // Parse hex
                    if (color.startsWith('#')) {
                        const r = parseInt(color.slice(1, 3), 16);
                        const g = parseInt(color.slice(3, 5), 16);
                        const b = parseInt(color.slice(5, 7), 16);
                        ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                    }
                    
                    ctx.lineWidth = i === 0 ? 2 : 1;
                    ctx.beginPath();
                    ctx.arc(cx, cy, radius + Math.sin(time * 0.002 + i) * 3, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Central e0 (the observer)
                const pulse = 8 + Math.sin(time * 0.003) * 3;
                ctx.fillStyle = '#D4AF37';
                ctx.beginPath();
                ctx.arc(cx, cy, pulse, 0, Math.PI * 2);
                ctx.fill();
                
                // Label
                ctx.fillStyle = 'rgba(212, 175, 55, 0.6)';
                ctx.font = '14px Space Mono';
                ctx.textAlign = 'center';
                ctx.fillText('e‚ÇÄ', cx, cy + pulse + 25);
                
                requestAnimationFrame(drawObserver);
            }
            drawObserver(0);
        }
        
        // ==================== SEVEN: Colonies on S7 ====================
        const seven = setupCanvas('canvas-seven');
        if (seven) {
            const { canvas, ctx } = seven;
            
            function drawSeven(time) {
                ctx.fillStyle = 'rgba(10, 10, 12, 0.04)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const cx = canvas.width / 2;
                const cy = canvas.height / 2;
                const radius = Math.min(canvas.width, canvas.height) * 0.22;
                
                // Draw S7 sphere (as circle)
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(cx, cy, radius, 0, Math.PI * 2);
                ctx.stroke();
                
                // Draw seven colonies
                const positions = [];
                for (let i = 0; i < 7; i++) {
                    const angle = (i / 7) * Math.PI * 2 - Math.PI / 2 + time * 0.0002;
                    const x = cx + Math.cos(angle) * radius;
                    const y = cy + Math.sin(angle) * radius;
                    positions.push({ x, y });
                    
                    // Trail
                    for (let j = 0; j < 15; j++) {
                        const trailAngle = angle - j * 0.015;
                        const tx = cx + Math.cos(trailAngle) * radius;
                        const ty = cy + Math.sin(trailAngle) * radius;
                        const alpha = (15 - j) / 15 * 0.3;
                        
                        const hex = colonyColors[i];
                        const r = parseInt(hex.slice(1, 3), 16);
                        const g = parseInt(hex.slice(3, 5), 16);
                        const b = parseInt(hex.slice(5, 7), 16);
                        ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                        ctx.beginPath();
                        ctx.arc(tx, ty, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Point
                    const pulse = 6 + Math.sin(time * 0.004 + i) * 2;
                    ctx.fillStyle = colonyColors[i];
                    ctx.beginPath();
                    ctx.arc(x, y, pulse, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Central e0
                ctx.fillStyle = '#D4AF37';
                ctx.beginPath();
                ctx.arc(cx, cy, 5 + Math.sin(time * 0.003) * 2, 0, Math.PI * 2);
                ctx.fill();
                
                requestAnimationFrame(drawSeven);
            }
            drawSeven(0);
        }
        
        // ==================== GRAMMAR: Fano Plane ====================
        const grammar = setupCanvas('canvas-grammar');
        if (grammar) {
            const { canvas, ctx } = grammar;
            
            // Fano plane lines (0-indexed)
            const fanoLines = [
                [0, 1, 2], [0, 3, 4], [0, 5, 6],
                [1, 3, 5], [4, 1, 6], [3, 2, 6], [4, 2, 5]
            ];
            
            function drawGrammar(time) {
                ctx.fillStyle = 'rgba(10, 10, 12, 0.04)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const cx = canvas.width / 2;
                const cy = canvas.height / 2;
                const radius = Math.min(canvas.width, canvas.height) * 0.18;
                
                // Fano plane positions
                const positions = [
                    { x: cx, y: cy - radius * 1.1 },           // 0: Spark (top)
                    { x: cx + radius, y: cy + radius * 0.7 },  // 1: Forge
                    { x: cx + radius * 0.5, y: cy - radius * 0.1 }, // 2: Flow
                    { x: cx - radius, y: cy + radius * 0.7 },  // 3: Nexus
                    { x: cx - radius * 0.5, y: cy - radius * 0.1 }, // 4: Beacon
                    { x: cx, y: cy + radius * 0.7 },           // 5: Grove
                    { x: cx, y: cy + radius * 0.15 }           // 6: Crystal (center)
                ];
                
                // Animate one line at a time
                const activeLineIdx = Math.floor(time / 2500) % 7;
                
                // Draw lines
                fanoLines.forEach((line, idx) => {
                    const isActive = idx === activeLineIdx;
                    const alpha = isActive ? 0.5 : 0.1;
                    
                    ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
                    ctx.lineWidth = isActive ? 2 : 1;
                    
                    ctx.beginPath();
                    ctx.moveTo(positions[line[0]].x, positions[line[0]].y);
                    ctx.lineTo(positions[line[1]].x, positions[line[1]].y);
                    ctx.lineTo(positions[line[2]].x, positions[line[2]].y);
                    ctx.closePath();
                    ctx.stroke();
                });
                
                // Inner circle
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
                ctx.beginPath();
                ctx.arc(cx, cy + radius * 0.25, radius * 0.45, 0, Math.PI * 2);
                ctx.stroke();
                
                // Draw points
                positions.forEach((pos, i) => {
                    const isOnActiveLine = fanoLines[activeLineIdx].includes(i);
                    const size = isOnActiveLine ? 10 : 6;
                    const pulse = isOnActiveLine ? Math.sin(time * 0.005) * 3 : 0;
                    
                    // Glow
                    const hex = colonyColors[i];
                    const r = parseInt(hex.slice(1, 3), 16);
                    const g = parseInt(hex.slice(3, 5), 16);
                    const b = parseInt(hex.slice(5, 7), 16);
                    
                    const glow = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, size + pulse + 15);
                    glow.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${isOnActiveLine ? 0.4 : 0.15})`);
                    glow.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
                    ctx.fillStyle = glow;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, size + pulse + 15, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Point
                    ctx.fillStyle = colonyColors[i];
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, size + pulse, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                requestAnimationFrame(drawGrammar);
            }
            drawGrammar(0);
        }
        
        // ==================== HIERARCHY: Compression funnel ====================
        const hierarchy = setupCanvas('canvas-hierarchy');
        if (hierarchy) {
            const { canvas, ctx } = hierarchy;
            
            const levels = [
                { name: 'E‚Çà', dim: 248, color: '#D4AF37' },
                { name: 'E‚Çá', dim: 133, color: '#9CA3AF' },
                { name: 'E‚ÇÜ', dim: 78, color: '#9CA3AF' },
                { name: 'F‚ÇÑ', dim: 52, color: '#9CA3AF' },
                { name: 'G‚ÇÇ', dim: 14, color: '#7C3AED' },
                { name: 'S‚Å∑', dim: 7, color: '#00BFA5' }
            ];
            
            function drawHierarchy(time) {
                ctx.fillStyle = 'rgba(10, 10, 12, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const cx = canvas.width / 2;
                const cy = canvas.height / 2;
                const height = canvas.height * 0.6;
                const maxWidth = 200;
                
                // Draw funnel
                levels.forEach((level, i) => {
                    const y = cy - height / 2 + (i / (levels.length - 1)) * height;
                    const width = maxWidth * (level.dim / 248);
                    
                    const pulse = Math.sin(time * 0.002 + i * 0.5) * 3;
                    
                    // Line
                    ctx.strokeStyle = level.color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(cx - width / 2 - pulse, y);
                    ctx.lineTo(cx + width / 2 + pulse, y);
                    ctx.stroke();
                    
                    // Particles flowing down
                    for (let p = 0; p < 3; p++) {
                        const particleY = y + Math.sin(time * 0.003 + i + p) * 15;
                        const particleX = cx + Math.cos(time * 0.002 + p * 2) * (width / 3);
                        
                        ctx.fillStyle = `rgba(212, 175, 55, ${0.3 - i * 0.04})`;
                        ctx.beginPath();
                        ctx.arc(particleX, particleY, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Connecting lines to next level
                    if (i < levels.length - 1) {
                        const nextY = cy - height / 2 + ((i + 1) / (levels.length - 1)) * height;
                        const nextWidth = maxWidth * (levels[i + 1].dim / 248);
                        
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(cx - width / 2, y);
                        ctx.lineTo(cx - nextWidth / 2, nextY);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(cx + width / 2, y);
                        ctx.lineTo(cx + nextWidth / 2, nextY);
                        ctx.stroke();
                    }
                });
                
                requestAnimationFrame(drawHierarchy);
            }
            drawHierarchy(0);
        }
        
        // ==================== LATTICE: E8 roots ====================
        const lattice = setupCanvas('canvas-lattice');
        if (lattice) {
            const { canvas, ctx } = lattice;
            
            // Generate simplified E8 root positions (projected to 2D)
            const roots = [];
            for (let i = 0; i < 240; i++) {
                const angle1 = (i / 240) * Math.PI * 2;
                const r = 0.7 + Math.sin(i * 0.1) * 0.25;
                roots.push({
                    angle: angle1,
                    radius: r,
                    phase: Math.random() * Math.PI * 2
                });
            }
            
            function drawLattice(time) {
                ctx.fillStyle = 'rgba(10, 10, 12, 0.03)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const cx = canvas.width / 2;
                const cy = canvas.height / 2;
                const maxRadius = Math.min(canvas.width, canvas.height) * 0.3;
                
                // Draw 240 roots
                roots.forEach((root, i) => {
                    const angle = root.angle + time * 0.00008;
                    const r = root.radius * maxRadius;
                    const x = cx + Math.cos(angle) * r;
                    const y = cy + Math.sin(angle) * r;
                    
                    const pulse = Math.sin(time * 0.002 + root.phase) * 0.3 + 0.7;
                    
                    ctx.fillStyle = `rgba(212, 175, 55, ${pulse * 0.4})`;
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // Draw shells
                [0.5, 0.7, 0.9].forEach(shellR => {
                    ctx.strokeStyle = 'rgba(212, 175, 55, 0.08)';
                    ctx.beginPath();
                    ctx.arc(cx, cy, shellR * maxRadius, 0, Math.PI * 2);
                    ctx.stroke();
                });
                
                // Center
                const goldGlow = ctx.createRadialGradient(cx, cy, 0, cx, cy, 30);
                goldGlow.addColorStop(0, 'rgba(212, 175, 55, 0.2)');
                goldGlow.addColorStop(1, 'rgba(212, 175, 55, 0)');
                ctx.fillStyle = goldGlow;
                ctx.beginPath();
                ctx.arc(cx, cy, 30, 0, Math.PI * 2);
                ctx.fill();
                
                // 240 label
                ctx.fillStyle = 'rgba(212, 175, 55, 0.4)';
                ctx.font = '12px Space Mono';
                ctx.textAlign = 'center';
                ctx.fillText('240 roots', cx, cy + maxRadius + 30);
                
                requestAnimationFrame(drawLattice);
            }
            drawLattice(0);
        }
        
        // ==================== SAFETY: Barrier ====================
        const safety = setupCanvas('canvas-safety');
        if (safety) {
            const { canvas, ctx } = safety;
            
            // Particles
            const particles = [];
            for (let i = 0; i < 25; i++) {
                particles.push({
                    x: Math.random() * 1000,
                    y: Math.random() * 1000,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2
                });
            }
            
            function drawSafety(time) {
                ctx.fillStyle = 'rgba(10, 10, 12, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const cx = canvas.width / 2;
                const cy = canvas.height / 2;
                const safeRadius = Math.min(canvas.width, canvas.height) * 0.25;
                
                // Safe zone gradient
                const gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, safeRadius * 1.3);
                gradient.addColorStop(0, 'rgba(16, 185, 129, 0.08)');
                gradient.addColorStop(0.6, 'rgba(245, 158, 11, 0.05)');
                gradient.addColorStop(1, 'rgba(239, 68, 68, 0.02)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(cx, cy, safeRadius * 1.3, 0, Math.PI * 2);
                ctx.fill();
                
                // Barrier line h(x) = 0
                ctx.strokeStyle = '#D4AF37';
                ctx.lineWidth = 2;
                ctx.setLineDash([8, 8]);
                ctx.beginPath();
                ctx.arc(cx, cy, safeRadius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Particles
                particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    
                    const dx = p.x - cx;
                    const dy = p.y - cy;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    // Bounce off barrier
                    if (dist > safeRadius - 8) {
                        const nx = dx / dist;
                        const ny = dy / dist;
                        const dot = p.vx * nx + p.vy * ny;
                        p.vx -= 2 * dot * nx;
                        p.vy -= 2 * dot * ny;
                        p.x = cx + nx * (safeRadius - 12);
                        p.y = cy + ny * (safeRadius - 12);
                    }
                    
                    // Color based on h(x)
                    const h = (safeRadius - dist) / safeRadius;
                    let color;
                    if (h > 0.5) color = '#10B981';
                    else if (h > 0) color = '#F59E0B';
                    else color = '#EF4444';
                    
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // Label
                ctx.fillStyle = 'rgba(212, 175, 55, 0.5)';
                ctx.font = '11px Space Mono';
                ctx.fillText('h(x) = 0', cx + safeRadius + 15, cy);
                
                requestAnimationFrame(drawSafety);
            }
            drawSafety(0);
        }
        
        // ==================== CONVERGENCE: Strange Loop ====================
        const convergence = setupCanvas('canvas-convergence');
        if (convergence) {
            const { canvas, ctx } = convergence;
            
            function drawConvergence(time) {
                ctx.fillStyle = 'rgba(10, 10, 12, 0.03)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const cx = canvas.width / 2;
                const cy = canvas.height / 2;
                const scale = Math.min(canvas.width, canvas.height) * 0.2;
                
                // Lemniscate (figure-8 / infinity symbol)
                ctx.strokeStyle = 'rgba(212, 175, 55, 0.25)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                for (let t = 0; t <= Math.PI * 2; t += 0.02) {
                    const cos = Math.cos(t);
                    const sin = Math.sin(t);
                    const denom = 1 + sin * sin;
                    const x = cx + (scale * 1.5 * cos) / denom;
                    const y = cy + (scale * sin * cos) / denom;
                    
                    if (t === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
                
                // Animated point
                const t = (time * 0.0008) % (Math.PI * 2);
                const cos = Math.cos(t);
                const sin = Math.sin(t);
                const denom = 1 + sin * sin;
                const px = cx + (scale * 1.5 * cos) / denom;
                const py = cy + (scale * sin * cos) / denom;
                
                // Trail
                for (let i = 0; i < 25; i++) {
                    const tt = ((time * 0.0008) - i * 0.04) % (Math.PI * 2);
                    const tc = Math.cos(tt);
                    const ts = Math.sin(tt);
                    const td = 1 + ts * ts;
                    const tx = cx + (scale * 1.5 * tc) / td;
                    const ty = cy + (scale * ts * tc) / td;
                    
                    const alpha = (25 - i) / 25 * 0.5;
                    ctx.fillStyle = `rgba(212, 175, 55, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(tx, ty, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Main point
                const glow = ctx.createRadialGradient(px, py, 0, px, py, 25);
                glow.addColorStop(0, 'rgba(212, 175, 55, 0.7)');
                glow.addColorStop(1, 'rgba(212, 175, 55, 0)');
                ctx.fillStyle = glow;
                ctx.beginPath();
                ctx.arc(px, py, 25, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#D4AF37';
                ctx.beginPath();
                ctx.arc(px, py, 6, 0, Math.PI * 2);
                ctx.fill();
                
                // Fixed point at center (where loop crosses)
                ctx.fillStyle = 'rgba(212, 175, 55, 0.4)';
                ctx.beginPath();
                ctx.arc(cx, cy, 4, 0, Math.PI * 2);
                ctx.fill();
                
                requestAnimationFrame(drawConvergence);
            }
            drawConvergence(0);
        }
    </script>
</body>
</html>
