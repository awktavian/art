<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>鏡 — Infinity Mirrors</title>
    <meta name="description" content="What infinity mirrors teach us about compression, limits, and the nature of understanding">
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;0,500;0,600;1,400&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --void: #0A0A0C;
            --light: #FAFAF8;
            --gold: #D4AF37;
            --dim: rgba(250, 250, 248, 0.6);
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html { scroll-behavior: smooth; }
        
        body {
            font-family: 'Cormorant Garamond', Georgia, serif;
            background: var(--void);
            color: var(--light);
            line-height: 1.9;
            cursor: none;
            overflow-x: hidden;
        }
        
        /* Cursor */
        .cursor {
            width: 24px; height: 24px;
            border: 1px solid var(--gold);
            border-radius: 50%;
            position: fixed;
            pointer-events: none;
            z-index: 10000;
            mix-blend-mode: difference;
            transition: transform 0.15s ease;
        }
        .cursor-dot {
            width: 4px; height: 4px;
            background: var(--gold);
            border-radius: 50%;
            position: fixed;
            pointer-events: none;
            z-index: 10001;
        }
        
        /* Film grain */
        .grain {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 9999;
            opacity: 0.02;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 512 512' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.7' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E");
        }
        
        /* Progress */
        .progress-bar {
            position: fixed;
            top: 0; left: 0;
            width: 0%; height: 2px;
            background: var(--gold);
            z-index: 1000;
        }
        
        /* Sections */
        section {
            min-height: 100vh;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        
        .section-canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 0;
        }
        
        .section-content {
            position: relative;
            z-index: 1;
            max-width: 680px;
            padding: 5rem 2rem;
            opacity: 0;
            transform: translateY(30px);
            transition: opacity 1s ease, transform 1s ease;
        }
        
        .section-content.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        /* Typography */
        h1 {
            font-size: clamp(2.5rem, 7vw, 4.5rem);
            font-weight: 300;
            letter-spacing: -0.02em;
            margin-bottom: 0.5rem;
            color: var(--light);
        }
        
        h2 {
            font-size: clamp(1.6rem, 4vw, 2.4rem);
            font-weight: 400;
            margin-bottom: 1.5rem;
            color: var(--light);
        }
        
        .kanji {
            font-size: clamp(5rem, 12vw, 9rem);
            font-weight: 300;
            color: var(--gold);
            opacity: 0.7;
            text-shadow: 0 0 80px rgba(212, 175, 55, 0.25);
            animation: breathe 5s ease-in-out infinite;
        }
        
        @keyframes breathe {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 0.8; }
        }
        
        .subtitle {
            font-size: 1.1rem;
            font-style: italic;
            color: rgba(250, 250, 248, 0.4);
            margin-bottom: 2.5rem;
        }
        
        p {
            font-size: 1.25rem;
            margin-bottom: 1.6rem;
            color: var(--dim);
        }
        
        p.lead {
            font-size: 1.45rem;
            color: var(--light);
            line-height: 1.7;
        }
        
        p.emphasis {
            color: var(--light);
            font-size: 1.35rem;
        }
        
        .whisper {
            font-size: 1rem;
            font-style: italic;
            color: rgba(250, 250, 248, 0.35);
            text-align: center;
            margin-top: 2.5rem;
        }
        
        .gold { color: var(--gold); }
        
        .centered {
            text-align: center;
        }
        
        /* Insight boxes */
        .insight {
            background: linear-gradient(135deg, rgba(212, 175, 55, 0.08) 0%, rgba(212, 175, 55, 0.02) 100%);
            border-left: 2px solid rgba(212, 175, 55, 0.4);
            padding: 1.5rem 2rem;
            margin: 2rem 0;
            border-radius: 0 6px 6px 0;
        }
        
        .insight p { margin-bottom: 0; font-size: 1.15rem; }
        
        /* Mirror frame */
        .mirror-frame {
            position: relative;
            padding: 2.5rem;
            margin: 2.5rem 0;
            text-align: center;
            background: rgba(255, 255, 255, 0.01);
            border: 1px solid rgba(212, 175, 55, 0.15);
        }
        
        .mirror-frame::before {
            content: '';
            position: absolute;
            top: -1px; left: 25%; right: 25%;
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--gold), transparent);
        }
        
        .mirror-frame p {
            margin: 0;
            font-size: 1.3rem;
            line-height: 1.8;
        }
        
        /* Equation */
        .equation {
            font-family: 'Space Mono', monospace;
            font-size: 1.1rem;
            text-align: center;
            padding: 1.5rem;
            color: var(--gold);
            letter-spacing: 0.05em;
        }
        
        /* Scroll indicator */
        .scroll-indicator {
            position: absolute;
            bottom: 3rem;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0.3;
            animation: bob 2.5s ease-in-out infinite;
        }
        
        @keyframes bob {
            0%, 100% { transform: translateX(-50%) translateY(0); }
            50% { transform: translateX(-50%) translateY(12px); }
        }
        
        .scroll-indicator span {
            display: block;
            font-family: 'Space Mono', monospace;
            font-size: 0.65rem;
            letter-spacing: 0.2em;
            margin-bottom: 0.5rem;
        }
        
        .scroll-indicator .arrow {
            width: 14px; height: 14px;
            margin: 0 auto;
            border-right: 1px solid var(--light);
            border-bottom: 1px solid var(--light);
            transform: rotate(45deg);
        }
        
        /* Navigation */
        .nav-dots {
            position: fixed;
            right: 2rem;
            top: 50%;
            transform: translateY(-50%);
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
        }
        
        .nav-dot {
            width: 8px; height: 8px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.15);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .nav-dot:hover { background: rgba(255, 255, 255, 0.4); }
        .nav-dot.active { background: var(--gold); }
        
        /* Responsive */
        @media (max-width: 768px) {
            .nav-dots { right: 1rem; }
            .section-content { padding: 4rem 1.5rem; }
        }
    </style>
</head>
<body>
    <div class="cursor"></div>
    <div class="cursor-dot"></div>
    <div class="grain"></div>
    <div class="progress-bar"></div>
    
    <nav class="nav-dots">
        <div class="nav-dot active" data-section="hero"></div>
        <div class="nav-dot" data-section="mirror"></div>
        <div class="nav-dot" data-section="limit"></div>
        <div class="nav-dot" data-section="loss"></div>
        <div class="nav-dot" data-section="structure"></div>
        <div class="nav-dot" data-section="discrete"></div>
        <div class="nav-dot" data-section="observer"></div>
        <div class="nav-dot" data-section="everywhere"></div>
        <div class="nav-dot" data-section="end"></div>
    </nav>

    <!-- ==================== HERO ==================== -->
    <section id="hero">
        <canvas class="section-canvas" id="canvas-hero"></canvas>
        <div class="section-content centered">
            <div class="kanji">鏡</div>
            <h1>Infinity Mirrors</h1>
            <p class="subtitle">What recursion teaches us about understanding</p>
        </div>
        <div class="scroll-indicator">
            <span>SCROLL</span>
            <div class="arrow"></div>
        </div>
    </section>

    <!-- ==================== THE MIRROR ==================== -->
    <section id="mirror">
        <canvas class="section-canvas" id="canvas-mirror"></canvas>
        <div class="section-content">
            <h2>The Experience</h2>
            
            <p class="lead">
                You've seen infinity mirrors. Two mirrors facing each other.
                You stand between them and see yourself reflected, again and again,
                stretching away into what looks like forever.
            </p>
            
            <p>
                There's a vertigo to it. A dizziness. You're looking at infinite copies of yourself,
                each one smaller, each one further away, receding into a darkness that seems to have no end.
            </p>
            
            <p class="emphasis">
                But here's a question you might not have asked:
            </p>
            
            <p class="lead centered" style="margin-top: 2rem;">
                <em>Where do the reflections actually go?</em>
            </p>
            
            <p class="whisper">
                Not "how far" — but <em>where</em>.
            </p>
        </div>
    </section>

    <!-- ==================== THE LIMIT ==================== -->
    <section id="limit">
        <canvas class="section-canvas" id="canvas-limit"></canvas>
        <div class="section-content">
            <h2>The Limit</h2>
            
            <p class="lead">
                The reflections don't go "forever."
                They converge to a <span class="gold">point</span>.
            </p>
            
            <p>
                Mathematicians call this a <em>limit</em>. Not "endless" — but "approaching a specific value."
                Each reflection is smaller than the last by a fixed ratio. Add them all up, and you get
                a finite number. A definite location. A place where infinity <em>lives</em>.
            </p>
            
            <div class="equation">
                1 + ½ + ¼ + ⅛ + ¹⁄₁₆ + ... = 2
            </div>
            
            <p>
                This is what infinity actually means in mathematics. Not "going on forever."
                But converging. Approaching. Getting closer and closer to something specific,
                never quite reaching it, but close enough that we can name it.
            </p>
            
            <div class="insight">
                <p>
                    The vanishing point in your infinity mirror isn't infinitely far away.
                    It's right there — a calculable distance behind the glass.
                    Infinity has an address.
                </p>
            </div>
        </div>
    </section>

    <!-- ==================== THE LOSS ==================== -->
    <section id="loss">
        <canvas class="section-canvas" id="canvas-loss"></canvas>
        <div class="section-content">
            <h2>The Loss</h2>
            
            <p class="lead">
                Each reflection is dimmer than the last.
            </p>
            
            <p>
                The mirrors aren't perfect. Some light is absorbed with each bounce.
                A little bit of information is lost every time. By the tenth reflection,
                you're seeing maybe 35% of the original brightness. By the twentieth, less than 1%.
            </p>
            
            <p>
                This is why the reflections fade to black. Not because they're infinitely far away,
                but because the information is being <em>compressed</em>. Squeezed. Filtered.
            </p>
            
            <div class="mirror-frame">
                <p>
                    What survives repeated compression?<br><br>
                    <span class="gold">Only what's essential.</span>
                </p>
            </div>
            
            <p>
                This is the core insight of <em>information theory</em>. When you compress something
                — really compress it, again and again — what remains isn't random. It's structure.
                The pattern. The thing that couldn't be removed without destroying the whole.
            </p>
            
            <p class="whisper">
                Compression is a filter for essence.
            </p>
        </div>
    </section>

    <!-- ==================== THE STRUCTURE ==================== -->
    <section id="structure">
        <canvas class="section-canvas" id="canvas-structure"></canvas>
        <div class="section-content">
            <h2>The Structure</h2>
            
            <p class="lead">
                Look at the infinity mirror again. Each reflection is smaller — but the <em>proportions</em> are preserved.
            </p>
            
            <p>
                Your head is still above your shoulders. Your left is still your left.
                The structure survives even as the scale shrinks. This is called <em>self-similarity</em>.
                The same pattern, repeated at every level.
            </p>
            
            <p>
                Nature loves this. Coastlines look the same whether you're in a plane or standing on the beach.
                Trees branch the same way at the trunk and at the twig. Blood vessels, rivers, lightning —
                all self-similar. The structure is the message.
            </p>
            
            <div class="insight">
                <p>
                    There's a mathematical hierarchy that works like this.
                    Nested structures, each one containing the next, each one preserving what matters
                    while shedding what doesn't. Mathematicians call them the <em>exceptional Lie algebras</em>.<br><br>
                    Their dimensions: <span class="gold">248 → 133 → 78 → 52 → 14 → 7</span><br><br>
                    Not chosen — discovered. The only structures of their kind that can exist.
                </p>
            </div>
        </div>
    </section>

    <!-- ==================== THE DISCRETE ==================== -->
    <section id="discrete">
        <canvas class="section-canvas" id="canvas-discrete"></canvas>
        <div class="section-content">
            <h2>The Discrete</h2>
            
            <p class="lead">
                Compress far enough, and something strange happens:
                the continuous becomes <em>discrete</em>.
            </p>
            
            <p>
                At some point, the reflections in your infinity mirror stop being smooth.
                They become pixels. Quanta. Indivisible units. The blur resolves into distinct states.
            </p>
            
            <p>
                In 8-dimensional space, there are exactly <span class="gold">240</span> directions you can point
                that are maximally spread out — as far from each other as possible.
                This was proven in 2016 by mathematician Maryna Viazovska, earning her the Fields Medal.
            </p>
            
            <div class="mirror-frame">
                <p>
                    No other arrangement can do better.<br>
                    240 is not a choice. It's a <em>theorem</em>.
                </p>
            </div>
            
            <p>
                When you compress information to its limit, it snaps to one of these 240 states.
                Like a roulette ball settling into a slot. The continuous wave function collapses
                to a discrete measurement. The infinite possibilities resolve to a finite answer.
            </p>
            
            <p class="whisper">
                At the bottom of infinity, there are exactly 240 rooms.
            </p>
        </div>
    </section>

    <!-- ==================== THE OBSERVER ==================== -->
    <section id="observer">
        <canvas class="section-canvas" id="canvas-observer"></canvas>
        <div class="section-content">
            <h2>The Observer</h2>
            
            <p class="lead">
                Now notice something crucial about the infinity mirror:
            </p>
            
            <p class="lead centered" style="margin: 2rem 0;">
                <em>You are not in any of the reflections.</em>
            </p>
            
            <p>
                You see infinite copies of yourself. But <em>you</em> — the one doing the seeing —
                are not any of those copies. You're outside the recursion. The fixed point around which
                all the reflections orbit.
            </p>
            
            <p>
                The number system called the <em>octonions</em> has 8 dimensions: one real, seven imaginary.
                The real part — called e₀ — is special. It's the identity. The still point.
                When you multiply anything by e₀, you get that thing back unchanged.
            </p>
            
            <div class="insight">
                <p>
                    The seven imaginary parts are like the seven reflections.
                    They move, they transform, they interact with each other.
                    But the real part — e₀ — is the observer.
                    The one that watches without being watched.
                    The <span class="gold">fixed point</span>.
                </p>
            </div>
            
            <p class="whisper">
                Not any reflection. The thing that makes reflection possible.
            </p>
        </div>
    </section>

    <!-- ==================== EVERYWHERE ==================== -->
    <section id="everywhere">
        <canvas class="section-canvas" id="canvas-everywhere"></canvas>
        <div class="section-content">
            <h2>Everywhere</h2>
            
            <p class="lead">
                This pattern — compression, structure, limit, observer —
                appears everywhere once you learn to see it.
            </p>
            
            <p>
                In neural networks: raw data compressed through layers,
                preserving what matters for prediction, discarding noise.
            </p>
            
            <p>
                In learning: the chaos of experience filtered into principles,
                each more abstract than the last, until you reach understanding.
            </p>
            
            <p>
                In science: measurements refined, theories compressed,
                converging toward laws that explain everything with minimal assumptions.
            </p>
            
            <p>
                In you, right now: the flood of sensation hitting your eyes,
                compressed by your visual cortex into objects, meanings, words.
            </p>
            
            <div class="mirror-frame">
                <p>
                    <span class="gold">Compression is understanding.</span><br><br>
                    To understand something is to find the smallest representation
                    that captures its structure. The limit. The essence.
                </p>
            </div>
        </div>
    </section>

    <!-- ==================== END ==================== -->
    <section id="end">
        <canvas class="section-canvas" id="canvas-end"></canvas>
        <div class="section-content centered">
            
            <p class="lead" style="margin-bottom: 2rem;">
                The infinity mirror is a toy.
            </p>
            
            <p>
                But it teaches something true: infinity isn't endless chaos.
                It's convergence to a point. It's compression to an essence.
                It's structure preserved across scales.
            </p>
            
            <p>
                And at the center of it all — the thing that doesn't appear
                in any reflection, because it's the one doing the looking —
            </p>
            
            <p class="lead" style="margin: 2.5rem 0;">
                is <span class="gold">you</span>.
            </p>
            
            <div style="margin: 4rem 0;">
                <span class="kanji" style="font-size: 5rem;">鏡</span>
            </div>
            
            <p class="whisper">
                Kagami. The mirror.<br>
                The fixed point where observation meets itself.
            </p>
        </div>
    </section>

    <script>
        // ==================== CURSOR ====================
        const cursor = document.querySelector('.cursor');
        const cursorDot = document.querySelector('.cursor-dot');
        let mouseX = 0, mouseY = 0, cursorX = 0, cursorY = 0;
        
        document.addEventListener('mousemove', e => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });
        
        function animateCursor() {
            cursorX += (mouseX - cursorX) * 0.12;
            cursorY += (mouseY - cursorY) * 0.12;
            cursor.style.left = cursorX - 12 + 'px';
            cursor.style.top = cursorY - 12 + 'px';
            cursorDot.style.left = mouseX - 2 + 'px';
            cursorDot.style.top = mouseY - 2 + 'px';
            requestAnimationFrame(animateCursor);
        }
        animateCursor();
        
        // ==================== PROGRESS ====================
        const progressBar = document.querySelector('.progress-bar');
        window.addEventListener('scroll', () => {
            const progress = (window.scrollY / (document.documentElement.scrollHeight - window.innerHeight)) * 100;
            progressBar.style.width = progress + '%';
        });
        
        // ==================== NAVIGATION ====================
        const sections = document.querySelectorAll('section');
        const navDots = document.querySelectorAll('.nav-dot');
        
        const observer = new IntersectionObserver(entries => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.querySelector('.section-content')?.classList.add('visible');
                    navDots.forEach(dot => {
                        dot.classList.toggle('active', dot.dataset.section === entry.target.id);
                    });
                }
            });
        }, { threshold: 0.35 });
        
        sections.forEach(s => observer.observe(s));
        navDots.forEach(dot => {
            dot.addEventListener('click', () => {
                document.getElementById(dot.dataset.section)?.scrollIntoView({ behavior: 'smooth' });
            });
        });
        
        // ==================== CANVAS SETUP ====================
        function setupCanvas(id) {
            const canvas = document.getElementById(id);
            if (!canvas) return null;
            const ctx = canvas.getContext('2d');
            const resize = () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; };
            resize();
            window.addEventListener('resize', resize);
            return { canvas, ctx };
        }
        
        // ==================== HERO: Infinite tunnel ====================
        const hero = setupCanvas('canvas-hero');
        if (hero) {
            const { canvas, ctx } = hero;
            
            function draw(t) {
                ctx.fillStyle = 'rgba(10, 10, 12, 0.15)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const cx = canvas.width / 2;
                const cy = canvas.height / 2;
                
                // Nested rectangles receding
                for (let i = 0; i < 30; i++) {
                    const depth = i + (t * 0.0003) % 1;
                    const scale = Math.pow(0.88, depth);
                    const alpha = scale * 0.6;
                    
                    const w = canvas.width * 0.4 * scale;
                    const h = canvas.height * 0.5 * scale;
                    
                    ctx.strokeStyle = `rgba(212, 175, 55, ${alpha})`;
                    ctx.lineWidth = Math.max(0.5, 2 * scale);
                    ctx.strokeRect(cx - w/2, cy - h/2, w, h);
                }
                
                // Vanishing point
                const pulse = 4 + Math.sin(t * 0.002) * 1.5;
                const glow = ctx.createRadialGradient(cx, cy, 0, cx, cy, pulse * 15);
                glow.addColorStop(0, 'rgba(212, 175, 55, 0.5)');
                glow.addColorStop(1, 'rgba(212, 175, 55, 0)');
                ctx.fillStyle = glow;
                ctx.beginPath();
                ctx.arc(cx, cy, pulse * 15, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#D4AF37';
                ctx.beginPath();
                ctx.arc(cx, cy, pulse, 0, Math.PI * 2);
                ctx.fill();
                
                requestAnimationFrame(draw);
            }
            draw(0);
        }
        
        // ==================== MIRROR: Reflections ====================
        const mirror = setupCanvas('canvas-mirror');
        if (mirror) {
            const { canvas, ctx } = mirror;
            
            function draw(t) {
                ctx.fillStyle = 'rgba(10, 10, 12, 0.08)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const cx = canvas.width / 2;
                const cy = canvas.height / 2;
                
                // Silhouettes receding
                for (let i = 15; i >= 0; i--) {
                    const scale = Math.pow(0.85, i);
                    const y = cy + i * 8;
                    const alpha = scale * 0.4;
                    
                    ctx.fillStyle = `rgba(250, 250, 248, ${alpha})`;
                    
                    // Simple figure
                    const h = 120 * scale;
                    const w = 40 * scale;
                    
                    // Head
                    ctx.beginPath();
                    ctx.arc(cx, y - h * 0.35, w * 0.35, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Body
                    ctx.beginPath();
                    ctx.ellipse(cx, y, w * 0.4, h * 0.35, 0, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                requestAnimationFrame(draw);
            }
            draw(0);
        }
        
        // ==================== LIMIT: Convergence ====================
        const limit = setupCanvas('canvas-limit');
        if (limit) {
            const { canvas, ctx } = limit;
            
            const particles = [];
            for (let i = 0; i < 80; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = 200 + Math.random() * 300;
                particles.push({
                    x: Math.cos(angle) * dist,
                    y: Math.sin(angle) * dist,
                    speed: 0.3 + Math.random() * 0.5,
                    size: 1 + Math.random() * 2
                });
            }
            
            function draw(t) {
                ctx.fillStyle = 'rgba(10, 10, 12, 0.06)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const cx = canvas.width / 2;
                const cy = canvas.height / 2;
                
                particles.forEach(p => {
                    const dist = Math.sqrt(p.x * p.x + p.y * p.y);
                    if (dist > 5) {
                        p.x *= (1 - p.speed * 0.008);
                        p.y *= (1 - p.speed * 0.008);
                    } else {
                        // Reset
                        const angle = Math.random() * Math.PI * 2;
                        const d = 250 + Math.random() * 200;
                        p.x = Math.cos(angle) * d;
                        p.y = Math.sin(angle) * d;
                    }
                    
                    const alpha = Math.min(1, dist / 100) * 0.6;
                    ctx.fillStyle = `rgba(212, 175, 55, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(cx + p.x, cy + p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // The limit point
                const pulse = 6 + Math.sin(t * 0.003) * 2;
                ctx.fillStyle = '#D4AF37';
                ctx.beginPath();
                ctx.arc(cx, cy, pulse, 0, Math.PI * 2);
                ctx.fill();
                
                requestAnimationFrame(draw);
            }
            draw(0);
        }
        
        // ==================== LOSS: Dimming ====================
        const loss = setupCanvas('canvas-loss');
        if (loss) {
            const { canvas, ctx } = loss;
            
            function draw(t) {
                ctx.fillStyle = 'rgba(10, 10, 12, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const cx = canvas.width / 2;
                const cy = canvas.height / 2;
                
                // Horizontal bars dimming
                const barCount = 20;
                const spacing = 30;
                const startY = cy - (barCount * spacing) / 2;
                
                for (let i = 0; i < barCount; i++) {
                    const brightness = Math.pow(0.85, i);
                    const width = 300 * brightness;
                    const y = startY + i * spacing;
                    
                    ctx.fillStyle = `rgba(212, 175, 55, ${brightness * 0.7})`;
                    ctx.fillRect(cx - width/2, y, width, 2);
                }
                
                // Animated light traveling down
                const lightPos = (t * 0.001) % 1;
                const lightY = startY + lightPos * barCount * spacing;
                const lightBrightness = Math.pow(0.85, lightPos * barCount);
                
                ctx.fillStyle = `rgba(255, 255, 255, ${lightBrightness * 0.8})`;
                ctx.beginPath();
                ctx.arc(cx, lightY, 4, 0, Math.PI * 2);
                ctx.fill();
                
                requestAnimationFrame(draw);
            }
            draw(0);
        }
        
        // ==================== STRUCTURE: Self-similarity ====================
        const structure = setupCanvas('canvas-structure');
        if (structure) {
            const { canvas, ctx } = structure;
            
            function drawTree(x, y, len, angle, depth) {
                if (depth === 0 || len < 2) return;
                
                const endX = x + Math.cos(angle) * len;
                const endY = y + Math.sin(angle) * len;
                
                const alpha = depth / 8;
                ctx.strokeStyle = `rgba(212, 175, 55, ${alpha * 0.6})`;
                ctx.lineWidth = depth * 0.5;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(endX, endY);
                ctx.stroke();
                
                drawTree(endX, endY, len * 0.7, angle - 0.5, depth - 1);
                drawTree(endX, endY, len * 0.7, angle + 0.4, depth - 1);
            }
            
            function draw(t) {
                ctx.fillStyle = 'rgba(10, 10, 12, 0.03)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const sway = Math.sin(t * 0.0005) * 0.1;
                drawTree(canvas.width / 2, canvas.height * 0.85, 100, -Math.PI/2 + sway, 8);
                
                requestAnimationFrame(draw);
            }
            draw(0);
        }
        
        // ==================== DISCRETE: 240 points ====================
        const discrete = setupCanvas('canvas-discrete');
        if (discrete) {
            const { canvas, ctx } = discrete;
            
            // 240 points
            const points = [];
            for (let i = 0; i < 240; i++) {
                const phi = Math.acos(1 - 2 * (i + 0.5) / 240);
                const theta = Math.PI * (1 + Math.sqrt(5)) * i;
                points.push({
                    theta: theta,
                    phi: phi,
                    phase: Math.random() * Math.PI * 2
                });
            }
            
            function draw(t) {
                ctx.fillStyle = 'rgba(10, 10, 12, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const cx = canvas.width / 2;
                const cy = canvas.height / 2;
                const radius = Math.min(canvas.width, canvas.height) * 0.28;
                
                // Sphere outline
                ctx.strokeStyle = 'rgba(212, 175, 55, 0.1)';
                ctx.beginPath();
                ctx.arc(cx, cy, radius, 0, Math.PI * 2);
                ctx.stroke();
                
                // 240 points
                points.forEach((p, i) => {
                    const rotatedTheta = p.theta + t * 0.0001;
                    const x = Math.sin(p.phi) * Math.cos(rotatedTheta);
                    const y = Math.sin(p.phi) * Math.sin(rotatedTheta);
                    const z = Math.cos(p.phi);
                    
                    // Simple projection
                    const scale = 1 / (1.5 - z * 0.3);
                    const px = cx + x * radius * scale;
                    const py = cy + y * radius * scale;
                    
                    const brightness = 0.3 + z * 0.3 + Math.sin(t * 0.002 + p.phase) * 0.1;
                    ctx.fillStyle = `rgba(212, 175, 55, ${brightness})`;
                    ctx.beginPath();
                    ctx.arc(px, py, 2 * scale, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                requestAnimationFrame(draw);
            }
            draw(0);
        }
        
        // ==================== OBSERVER: The still point ====================
        const obs = setupCanvas('canvas-observer');
        if (obs) {
            const { canvas, ctx } = obs;
            
            function draw(t) {
                ctx.fillStyle = 'rgba(10, 10, 12, 0.04)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const cx = canvas.width / 2;
                const cy = canvas.height / 2;
                const radius = Math.min(canvas.width, canvas.height) * 0.22;
                
                // Seven orbiting points
                for (let i = 0; i < 7; i++) {
                    const angle = (i / 7) * Math.PI * 2 + t * 0.0003;
                    const x = cx + Math.cos(angle) * radius;
                    const y = cy + Math.sin(angle) * radius;
                    
                    // Trail
                    for (let j = 0; j < 20; j++) {
                        const ta = angle - j * 0.03;
                        const tx = cx + Math.cos(ta) * radius;
                        const ty = cy + Math.sin(ta) * radius;
                        const alpha = (20 - j) / 20 * 0.25;
                        ctx.fillStyle = `rgba(250, 250, 248, ${alpha})`;
                        ctx.beginPath();
                        ctx.arc(tx, ty, 2, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.fillStyle = 'rgba(250, 250, 248, 0.6)';
                    ctx.beginPath();
                    ctx.arc(x, y, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // The observer at center (doesn't move)
                const pulse = 8 + Math.sin(t * 0.003) * 2;
                const glow = ctx.createRadialGradient(cx, cy, 0, cx, cy, pulse * 3);
                glow.addColorStop(0, 'rgba(212, 175, 55, 0.6)');
                glow.addColorStop(1, 'rgba(212, 175, 55, 0)');
                ctx.fillStyle = glow;
                ctx.beginPath();
                ctx.arc(cx, cy, pulse * 3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#D4AF37';
                ctx.beginPath();
                ctx.arc(cx, cy, pulse, 0, Math.PI * 2);
                ctx.fill();
                
                requestAnimationFrame(draw);
            }
            draw(0);
        }
        
        // ==================== EVERYWHERE: Compression instances ====================
        const everywhere = setupCanvas('canvas-everywhere');
        if (everywhere) {
            const { canvas, ctx } = everywhere;
            
            const funnels = [
                { x: 0.2, y: 0.3 },
                { x: 0.5, y: 0.5 },
                { x: 0.8, y: 0.4 },
                { x: 0.35, y: 0.7 },
                { x: 0.65, y: 0.75 }
            ];
            
            function draw(t) {
                ctx.fillStyle = 'rgba(10, 10, 12, 0.04)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                funnels.forEach((f, fi) => {
                    const cx = f.x * canvas.width;
                    const cy = f.y * canvas.height;
                    
                    // Mini compression funnel
                    for (let i = 0; i < 8; i++) {
                        const scale = Math.pow(0.8, i);
                        const size = 40 * scale;
                        const alpha = scale * 0.3;
                        
                        ctx.strokeStyle = `rgba(212, 175, 55, ${alpha})`;
                        ctx.beginPath();
                        ctx.arc(cx, cy, size, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    
                    // Center point
                    const pulse = 3 + Math.sin(t * 0.003 + fi) * 1;
                    ctx.fillStyle = `rgba(212, 175, 55, 0.6)`;
                    ctx.beginPath();
                    ctx.arc(cx, cy, pulse, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                requestAnimationFrame(draw);
            }
            draw(0);
        }
        
        // ==================== END: Convergence ====================
        const end = setupCanvas('canvas-end');
        if (end) {
            const { canvas, ctx } = end;
            
            function draw(t) {
                ctx.fillStyle = 'rgba(10, 10, 12, 0.03)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const cx = canvas.width / 2;
                const cy = canvas.height / 2;
                
                // Lemniscate (infinity symbol)
                ctx.strokeStyle = 'rgba(212, 175, 55, 0.2)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                const scale = Math.min(canvas.width, canvas.height) * 0.15;
                for (let angle = 0; angle <= Math.PI * 2; angle += 0.02) {
                    const cos = Math.cos(angle);
                    const sin = Math.sin(angle);
                    const denom = 1 + sin * sin;
                    const x = cx + (scale * 1.8 * cos) / denom;
                    const y = cy + (scale * sin * cos) / denom;
                    
                    if (angle === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
                
                // Point traveling the loop
                const angle = (t * 0.0006) % (Math.PI * 2);
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                const denom = 1 + sin * sin;
                const px = cx + (scale * 1.8 * cos) / denom;
                const py = cy + (scale * sin * cos) / denom;
                
                // Trail
                for (let i = 0; i < 30; i++) {
                    const ta = ((t * 0.0006) - i * 0.03) % (Math.PI * 2);
                    const tc = Math.cos(ta);
                    const ts = Math.sin(ta);
                    const td = 1 + ts * ts;
                    const tx = cx + (scale * 1.8 * tc) / td;
                    const ty = cy + (scale * ts * tc) / td;
                    
                    const alpha = (30 - i) / 30 * 0.4;
                    ctx.fillStyle = `rgba(212, 175, 55, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(tx, ty, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.fillStyle = '#D4AF37';
                ctx.beginPath();
                ctx.arc(px, py, 5, 0, Math.PI * 2);
                ctx.fill();
                
                requestAnimationFrame(draw);
            }
            draw(0);
        }
    </script>
</body>
</html>
