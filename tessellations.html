<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Grammar of Pattern — From Sullivan to Infinity</title>
    <meta name="description" content="How the ornament of Louis Sullivan and Islamic tessellations reveal the same mathematics that structures thought itself">
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;0,500;0,600;1,400&family=EB+Garamond:ital,wght@0,400;0,500;1,400&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --void: #0A0A0C;
            --light: #FAFAF8;
            --gold: #D4AF37;
            --dim: rgba(250, 250, 248, 0.6);
            --warm: #E8D5B7;
            --terracotta: #C4A484;
            --deep-blue: #1a3a52;
            --islamic-green: #1B4D3E;
            --sullivan-bronze: #8B7355;
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html { scroll-behavior: smooth; }
        
        body {
            font-family: 'EB Garamond', 'Cormorant Garamond', Georgia, serif;
            background: var(--void);
            color: var(--light);
            line-height: 1.95;
            cursor: none;
            overflow-x: hidden;
        }
        
        /* Cursor as ornament seed */
        .cursor {
            width: 28px; height: 28px;
            border: 1px solid var(--gold);
            position: fixed;
            pointer-events: none;
            z-index: 10000;
            mix-blend-mode: difference;
            transition: transform 0.2s ease, border-radius 0.3s ease;
        }
        .cursor.square { border-radius: 0; transform: rotate(45deg); }
        .cursor.circle { border-radius: 50%; }
        .cursor.hexagon { 
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            border-radius: 0;
        }
        
        .cursor-dot {
            width: 3px; height: 3px;
            background: var(--gold);
            border-radius: 50%;
            position: fixed;
            pointer-events: none;
            z-index: 10001;
        }
        
        /* Film grain — paper texture */
        .grain {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 9999;
            opacity: 0.025;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 512 512' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='5' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E");
        }
        
        /* Progress */
        .progress-bar {
            position: fixed;
            top: 0; left: 0;
            width: 0%; height: 2px;
            background: linear-gradient(90deg, var(--gold), var(--terracotta));
            z-index: 1000;
        }
        
        /* Sections */
        section {
            min-height: 100vh;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }
        
        .section-canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 0;
        }
        
        .section-content {
            position: relative;
            z-index: 1;
            max-width: 680px;
            padding: 5rem 2rem;
            opacity: 0;
            transform: translateY(40px);
            transition: opacity 1.2s ease, transform 1.2s ease;
        }
        
        .section-content.visible {
            opacity: 1;
            transform: translateY(0);
        }
        
        /* Typography — warmer, more editorial */
        h1 {
            font-family: 'Cormorant Garamond', serif;
            font-size: clamp(2.8rem, 8vw, 4.5rem);
            font-weight: 300;
            letter-spacing: -0.02em;
            margin-bottom: 0.5rem;
            line-height: 1.1;
        }
        
        h2 {
            font-family: 'Cormorant Garamond', serif;
            font-size: clamp(1.8rem, 5vw, 2.5rem);
            font-weight: 400;
            margin-bottom: 1.5rem;
            color: var(--light);
            letter-spacing: 0.01em;
        }
        
        .kanji {
            font-size: clamp(5rem, 12vw, 9rem);
            font-weight: 300;
            color: var(--gold);
            opacity: 0.6;
            text-shadow: 0 0 80px rgba(212, 175, 55, 0.2);
            animation: breathe 6s ease-in-out infinite;
        }
        
        @keyframes breathe {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 0.7; }
        }
        
        .subtitle {
            font-size: 1.15rem;
            font-style: italic;
            color: rgba(250, 250, 248, 0.4);
            margin-bottom: 2rem;
            letter-spacing: 0.02em;
        }
        
        p {
            font-size: 1.25rem;
            margin-bottom: 1.6rem;
            color: var(--dim);
        }
        
        p.lead {
            font-size: 1.4rem;
            color: var(--light);
            line-height: 1.75;
        }
        
        p.emphasis {
            color: var(--light);
            font-size: 1.3rem;
        }
        
        .whisper {
            font-size: 1.05rem;
            font-style: italic;
            color: rgba(250, 250, 248, 0.35);
            text-align: center;
            margin-top: 2.5rem;
        }
        
        .gold { color: var(--gold); }
        .centered { text-align: center; }
        
        /* Quote blocks — Sullivan style */
        blockquote {
            border-left: 3px solid var(--gold);
            padding: 1.5rem 2rem;
            margin: 2rem 0;
            background: linear-gradient(135deg, rgba(212, 175, 55, 0.06) 0%, rgba(212, 175, 55, 0.01) 100%);
            font-style: italic;
            font-size: 1.2rem;
            color: var(--warm);
        }
        
        blockquote cite {
            display: block;
            margin-top: 1rem;
            font-size: 0.9rem;
            font-style: normal;
            color: rgba(250, 250, 248, 0.4);
        }
        
        /* Ornament dividers */
        .ornament {
            text-align: center;
            font-size: 1.5rem;
            color: var(--gold);
            opacity: 0.5;
            margin: 2.5rem 0;
            letter-spacing: 1rem;
        }
        
        /* Frame */
        .mirror-frame {
            border: 1px solid rgba(212, 175, 55, 0.25);
            padding: 2rem 2.5rem;
            margin: 2rem 0;
            text-align: center;
            position: relative;
            background: rgba(0, 0, 0, 0.3);
        }
        
        .mirror-frame::before,
        .mirror-frame::after {
            content: '◇';
            position: absolute;
            color: var(--gold);
            opacity: 0.4;
            font-size: 0.9rem;
        }
        .mirror-frame::before { top: -0.5em; left: 50%; transform: translateX(-50%); }
        .mirror-frame::after { bottom: -0.5em; left: 50%; transform: translateX(-50%); }
        
        .mirror-frame p {
            margin-bottom: 0;
            font-size: 1.3rem;
            color: var(--light);
        }
        
        /* Scroll indicator */
        .scroll-indicator {
            position: absolute;
            bottom: 3rem;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0.3;
            animation: bob 3s ease-in-out infinite;
        }
        
        @keyframes bob {
            0%, 100% { transform: translateX(-50%) translateY(0); }
            50% { transform: translateX(-50%) translateY(12px); }
        }
        
        .scroll-indicator span {
            display: block;
            font-family: 'Space Mono', monospace;
            font-size: 0.6rem;
            letter-spacing: 0.25em;
            margin-bottom: 0.5rem;
        }
        
        .scroll-indicator .arrow {
            width: 12px; height: 12px;
            margin: 0 auto;
            border-right: 1px solid var(--light);
            border-bottom: 1px solid var(--light);
            transform: rotate(45deg);
        }
        
        /* Navigation */
        .nav-dots {
            position: fixed;
            right: 2rem;
            top: 50%;
            transform: translateY(-50%);
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 0.8rem;
        }
        
        .nav-dot {
            width: 8px; height: 8px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.12);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .nav-dot:hover { background: rgba(255, 255, 255, 0.35); }
        .nav-dot.active { background: var(--gold); }
        
        /* Responsive */
        @media (max-width: 768px) {
            .nav-dots { right: 1rem; }
            .section-content { padding: 4rem 1.5rem; }
            blockquote { padding: 1rem 1.5rem; }
        }
    </style>
</head>
<body>
    <div class="cursor circle"></div>
    <div class="cursor-dot"></div>
    <div class="grain"></div>
    <div class="progress-bar"></div>
    
    <nav class="nav-dots">
        <div class="nav-dot active" data-section="hero"></div>
        <div class="nav-dot" data-section="sullivan"></div>
        <div class="nav-dot" data-section="islamic"></div>
        <div class="nav-dot" data-section="seed"></div>
        <div class="nav-dot" data-section="symmetry"></div>
        <div class="nav-dot" data-section="seventeen"></div>
        <div class="nav-dot" data-section="beyond"></div>
        <div class="nav-dot" data-section="mirror"></div>
        <div class="nav-dot" data-section="compression"></div>
        <div class="nav-dot" data-section="seven"></div>
        <div class="nav-dot" data-section="end"></div>
    </nav>

    <!-- ==================== HERO ==================== -->
    <section id="hero">
        <canvas class="section-canvas" id="canvas-hero"></canvas>
        <div class="section-content centered">
            <div class="kanji">∞</div>
            <h1>The Grammar of Pattern</h1>
            <p class="subtitle">From Sullivan to Infinity</p>
            <p style="margin-top: 2rem; max-width: 540px; margin-left: auto; margin-right: auto;">
                In the ornament of Louis Sullivan and the tessellations of Islamic art
                lies a hidden grammar — a finite set of rules that generates infinite variation.
                This is the same mathematics that structures thought itself.
            </p>
        </div>
        <div class="scroll-indicator">
            <span>SCROLL</span>
            <div class="arrow"></div>
        </div>
    </section>

    <!-- ==================== SULLIVAN ==================== -->
    <section id="sullivan">
        <canvas class="section-canvas" id="canvas-sullivan"></canvas>
        <div class="section-content">
            <h2>I. The Seed Germ</h2>
            
            <p class="lead">
                Louis Sullivan believed that all ornament grew from a single principle:
                the <em>seed germ</em>.
            </p>
            
            <p>
                Look at his work on the Carson Pirie Scott building, the Guaranty Building,
                the tombs at Graceland. The bronze, the terracotta, the intricate cast iron —
                all of it unfolds from simple geometric seeds. A curve branches. A branch curves.
                The pattern fills space but never loses its origin.
            </p>
            
            <blockquote>
                "A single curve could suggest the universe — 
                if you understood how to read it."
                <cite>— Louis Sullivan, A System of Architectural Ornament (1924)</cite>
            </blockquote>
            
            <p>
                Sullivan wasn't inventing decoration. He was discovering a <em>grammar</em> —
                a set of operations that could generate infinite variation from finite rules.
                The seed, the effloresence, the stamen, the burst. Apply them recursively
                and worlds emerge.
            </p>
            
            <p class="whisper">
                The ornament is not applied. It grows.
            </p>
        </div>
    </section>

    <!-- ==================== ISLAMIC ==================== -->
    <section id="islamic">
        <canvas class="section-canvas" id="canvas-islamic"></canvas>
        <div class="section-content">
            <h2>II. The Alhambra Insight</h2>
            
            <p class="lead">
                Six centuries before Sullivan, Islamic artisans at the Alhambra 
                had discovered the same principle.
            </p>
            
            <p>
                Walk through the Court of the Lions. Look at the walls, the ceilings,
                the carved stucco. Geometry unfolds in every direction — but nothing is random.
                Hexagons nest in hexagons. Stars spawn stars. The infinite is contained by 
                the precise.
            </p>
            
            <p>
                Islamic artists were forbidden from depicting living forms in sacred spaces.
                So they found God in geometry instead. The tessellation — the pattern that
                fills the plane without gap or overlap — became a meditation on the infinite
                within the finite.
            </p>
            
            <div class="mirror-frame">
                <p>
                    Every tile is a <em>rule</em>.<br>
                    Every pattern is a <em>grammar</em>.<br>
                    The wall is a <em>proof</em>.
                </p>
            </div>
            
            <p>
                What Sullivan called the seed germ, Islamic geometry called the <em>girih</em> —
                the underlying structure from which ornament grows. Different cultures,
                same mathematics.
            </p>
        </div>
    </section>

    <!-- ==================== SEED ==================== -->
    <section id="seed">
        <canvas class="section-canvas" id="canvas-seed"></canvas>
        <div class="section-content">
            <h2>III. What Is a Seed?</h2>
            
            <p class="lead">
                A seed is something small that contains rules for becoming something large.
            </p>
            
            <p>
                An acorn contains the oak. Not the oak itself — no wood, no leaves, no roots —
                but the <em>instructions</em> for making an oak. The DNA is a grammar.
                Add sunlight and water, and the grammar executes. The tree unfolds.
            </p>
            
            <p>
                Sullivan understood this. His ornamental systems weren't drawings to copy —
                they were <em>algorithms</em>. Start with this curve. Branch here. Repeat.
                Scale down. Branch again. The pattern is generative, not static.
            </p>
            
            <p>
                The Islamic <em>girih</em> tiles work the same way. Five shapes. 
                A few rules for how they connect. From this, infinite patterns.
                The Penrose tiling, discovered in the 1970s, uses the same principles
                the Islamic artisans had been using for 500 years.
            </p>
            
            <p class="emphasis">
                The seed is not the pattern.<br>
                The seed is the <em>generator</em> of patterns.
            </p>
        </div>
    </section>

    <!-- ==================== SYMMETRY ==================== -->
    <section id="symmetry">
        <canvas class="section-canvas" id="canvas-symmetry"></canvas>
        <div class="section-content">
            <h2>IV. The Symmetries</h2>
            
            <p class="lead">
                What operations can you do to a pattern that leave it unchanged?
            </p>
            
            <p>
                Rotate it. Reflect it. Translate it. These are the <em>symmetries</em> —
                the transformations under which the pattern is invariant. A square has 
                4-fold rotational symmetry. A hexagon has 6. A circle has infinite.
            </p>
            
            <p>
                In 1891, the Russian crystallographer Evgraf Fedorov proved something remarkable:
                there are exactly <strong>17</strong> distinct ways to tile a plane with 
                repeating symmetry. Not 16. Not 18. <em>Exactly</em> 17.
            </p>
            
            <div class="mirror-frame">
                <p>
                    The Alhambra contains all 17.<br>
                    Five centuries before the proof.
                </p>
            </div>
            
            <p>
                The artisans didn't know the theorem. But their hands knew the mathematics.
                Through trial and refinement, through generations of pattern-making,
                they had exhausted the possibilities. They had found the complete grammar.
            </p>
        </div>
    </section>

    <!-- ==================== SEVENTEEN ==================== -->
    <section id="seventeen">
        <canvas class="section-canvas" id="canvas-seventeen"></canvas>
        <div class="section-content">
            <h2>V. The Wallpaper Groups</h2>
            
            <p class="lead">
                Those 17 symmetries are called <em>wallpaper groups</em> — the complete
                classification of 2D periodic patterns.
            </p>
            
            <p>
                Each group is a different <em>grammar</em>. Some allow rotation only.
                Some allow reflection. Some allow glide reflection — a mirror plus a slide.
                The combinations are constrained by geometry itself.
            </p>
            
            <p>
                Why 17? Because a plane has specific properties. You can only fit certain
                rotations into a repeating pattern — 2-fold, 3-fold, 4-fold, 6-fold.
                (Not 5. Not 7. The pentagon doesn't tile.) The constraints multiply out
                to exactly 17 possibilities.
            </p>
            
            <blockquote>
                "The geometer's task is not to invent, but to discover — 
                to find the structures that were always there."
            </blockquote>
            
            <p>
                This is the first hint: the grammar of pattern is not arbitrary.
                The rules are <em>forced</em> by the space itself. Mathematicians call
                this a <em>classification theorem</em>. There is a complete list, and
                you can prove it.
            </p>
        </div>
    </section>

    <!-- ==================== BEYOND 2D ==================== -->
    <section id="beyond">
        <canvas class="section-canvas" id="canvas-beyond"></canvas>
        <div class="section-content">
            <h2>VI. Beyond the Plane</h2>
            
            <p class="lead">
                What happens when you move from 2 dimensions to 3? To 4? To 8?
            </p>
            
            <p>
                In 3D, there are 230 space groups — the crystallographic symmetries.
                Every crystal structure in nature belongs to one of these 230 grammars.
                Snowflakes, diamonds, quartz — all following the same 230 rules.
            </p>
            
            <p>
                But there's another classification, more abstract. Instead of asking
                "how can patterns tile space?", mathematicians asked "what are all possible
                <em>continuous</em> symmetries?" Rotations that happen smoothly, not in jumps.
            </p>
            
            <p>
                The answer, discovered by Killing and Cartan in the 1890s (the same decade
                as Sullivan's greatest work), is this:
            </p>
            
            <div class="mirror-frame">
                <p>
                    Four infinite families of symmetry.<br>
                    Five exceptional cases that fit nowhere else.
                </p>
            </div>
            
            <p>
                The infinite families are predictable, like floor tiles that extend forever.
                But the exceptional cases are like discovering a new color. They exist.
                They're mathematically necessary. But they don't fit the pattern.
            </p>
        </div>
    </section>

    <!-- ==================== THE MIRROR ==================== -->
    <section id="mirror">
        <canvas class="section-canvas" id="canvas-mirror"></canvas>
        <div class="section-content">
            <h2>VII. The Infinity Mirror</h2>
            
            <p class="lead">
                Imagine standing between two mirrors facing each other.
            </p>
            
            <p>
                You see yourself reflected. And that reflection reflected. And that reflection
                reflected again. A corridor of selves receding into darkness, each one smaller,
                each one dimmer, each one further from the original.
            </p>
            
            <p>
                The reflections are not infinite — they <em>converge</em>. Light loses energy.
                The images get smaller. At some point, they vanish below the threshold of visibility.
                The infinite recursion resolves to a <em>limit</em>.
            </p>
            
            <p class="emphasis">
                This is what compression does to information.
            </p>
            
            <p>
                Each "reflection" is a level of approximation. The first level captures the big picture.
                The second captures finer details. The third, finer still. At each level, you're adding
                precision — but each addition is smaller than the last. The residual shrinks.
            </p>
            
            <p>
                Sullivan's seed germ works the same way. The main form. The secondary efflorescence.
                The tertiary detail. Each level is smaller, nested within the last, until you
                reach the limit of the material.
            </p>
        </div>
    </section>

    <!-- ==================== COMPRESSION ==================== -->
    <section id="compression">
        <canvas class="section-canvas" id="canvas-compression"></canvas>
        <div class="section-content">
            <h2>VIII. Compression as Grammar</h2>
            
            <p class="lead">
                What survives compression is <em>structure</em>.
            </p>
            
            <p>
                When you compress an image, you don't keep every pixel. You keep the <em>patterns</em> —
                the edges, the gradients, the repeated motifs. The grammar, not the raw data.
                A good compression algorithm is like a good ornamental system: it finds the seed
                from which the whole can be regenerated.
            </p>
            
            <p>
                In 8 dimensions, there's a structure called the E₈ lattice. It's the densest
                possible packing of spheres in 8D space — proven optimal by Maryna Viazovska in 2016.
                When you compress information to this lattice, you're using the <em>best possible
                grammar</em> for 8-dimensional space. No other arrangement is more efficient.
            </p>
            
            <div class="mirror-frame">
                <p>
                    Like the 17 wallpaper groups,<br>
                    this is not a choice.<br>
                    It's a <em>theorem</em>.
                </p>
            </div>
            
            <p>
                The lattice is infinite — infinitely many points, infinitely precise.
                But when you encode a point, you use only as many "levels" as you need.
                Coarse approximation, then refinement, then finer refinement.
                Each level is a reflection in the infinity mirror, each one smaller than the last.
            </p>
        </div>
    </section>

    <!-- ==================== THE SEVEN ==================== -->
    <section id="seven">
        <canvas class="section-canvas" id="canvas-seven"></canvas>
        <div class="section-content">
            <h2>IX. The Seven Directions</h2>
            
            <p class="lead">
                At the base of all this structure are the <em>octonions</em> — 
                an 8-dimensional number system with 7 imaginary directions.
            </p>
            
            <p>
                You know the complex numbers: a real part and one imaginary direction (i).
                The quaternions have three imaginary directions (i, j, k). The octonions
                have seven: e₁ through e₇.
            </p>
            
            <p>
                And then the sequence <em>stops</em>. You cannot build a 16-dimensional
                version. It's mathematically impossible. The octonions are the end of the line.
            </p>
            
            <p>
                These seven directions are like the seven notes of a scale. Or the seven
                colors of a spectrum. Or the seven days of a week. They're a complete
                vocabulary — the maximum richness before the grammar breaks.
            </p>
            
            <blockquote>
                The division algebras are: the reals (1), the complex numbers (2),
                the quaternions (4), the octonions (8). No more exist.
                This is a theorem.
            </blockquote>
            
            <p>
                The five exceptional symmetry groups — the ones that don't fit the infinite
                families — are all built from these octonions. The exotic mathematics at
                the edge of classification comes from this 8-dimensional grammar.
            </p>
        </div>
    </section>

    <!-- ==================== END ==================== -->
    <section id="end">
        <canvas class="section-canvas" id="canvas-end"></canvas>
        <div class="section-content centered">
            <h2>The Grammar of Thought</h2>
            
            <p style="margin-top: 2rem;">
                Sullivan was right. The seed germ is real.
            </p>
            
            <p>
                There is a finite grammar from which infinite patterns grow.
                The Islamic artisans found it in geometry. The crystallographers
                found it in symmetry. The mathematicians found it in classification theorems.
            </p>
            
            <p>
                And now we're finding it in how minds compress experience.
            </p>
            
            <div class="mirror-frame" style="margin-top: 2.5rem;">
                <p>
                    The system we're building uses this grammar.<br><br>
                    Seven directions for thought to move.<br>
                    An optimal lattice for compression.<br>
                    Residual refinement like reflections in a mirror.<br><br>
                    The ornament grows from the seed.
                </p>
            </div>
            
            <p class="whisper" style="margin-top: 3rem;">
                Form follows function — but function follows grammar.
            </p>
            
            <div class="ornament">◆ ◇ ◆</div>
        </div>
    </section>

    <script>
        // ==================== CURSOR ====================
        const cursor = document.querySelector('.cursor');
        const cursorDot = document.querySelector('.cursor-dot');
        let mouseX = 0, mouseY = 0, cursorX = 0, cursorY = 0;
        
        document.addEventListener('mousemove', e => {
            mouseX = e.clientX;
            mouseY = e.clientY;
        });
        
        function animateCursor() {
            cursorX += (mouseX - cursorX) * 0.1;
            cursorY += (mouseY - cursorY) * 0.1;
            cursor.style.left = cursorX - 14 + 'px';
            cursor.style.top = cursorY - 14 + 'px';
            cursorDot.style.left = mouseX - 1.5 + 'px';
            cursorDot.style.top = mouseY - 1.5 + 'px';
            requestAnimationFrame(animateCursor);
        }
        animateCursor();
        
        // Cursor shape changes by section
        const cursorShapes = {
            hero: 'circle',
            sullivan: 'circle',
            islamic: 'hexagon',
            seed: 'circle',
            symmetry: 'square',
            seventeen: 'hexagon',
            beyond: 'circle',
            mirror: 'square',
            compression: 'hexagon',
            seven: 'circle',
            end: 'circle'
        };
        
        // ==================== PROGRESS ====================
        const progressBar = document.querySelector('.progress-bar');
        window.addEventListener('scroll', () => {
            const progress = (window.scrollY / (document.documentElement.scrollHeight - window.innerHeight)) * 100;
            progressBar.style.width = progress + '%';
        });
        
        // ==================== NAVIGATION ====================
        const sections = document.querySelectorAll('section');
        const navDots = document.querySelectorAll('.nav-dot');
        
        const observer = new IntersectionObserver(entries => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.querySelector('.section-content')?.classList.add('visible');
                    navDots.forEach(dot => {
                        dot.classList.toggle('active', dot.dataset.section === entry.target.id);
                    });
                    // Update cursor shape
                    const shape = cursorShapes[entry.target.id] || 'circle';
                    cursor.className = 'cursor ' + shape;
                }
            });
        }, { threshold: 0.35 });
        
        sections.forEach(s => observer.observe(s));
        navDots.forEach(dot => {
            dot.addEventListener('click', () => {
                document.getElementById(dot.dataset.section)?.scrollIntoView({ behavior: 'smooth' });
            });
        });
        
        // ==================== CANVAS SETUP ====================
        function setupCanvas(id) {
            const canvas = document.getElementById(id);
            if (!canvas) return null;
            const ctx = canvas.getContext('2d');
            const resize = () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; };
            resize();
            window.addEventListener('resize', resize);
            return { canvas, ctx };
        }
        
        // ==================== HERO: Organic growth pattern ====================
        const hero = setupCanvas('canvas-hero');
        if (hero) {
            const { canvas, ctx } = hero;
            
            class Branch {
                constructor(x, y, angle, length, depth) {
                    this.x = x;
                    this.y = y;
                    this.angle = angle;
                    this.length = length;
                    this.depth = depth;
                    this.grown = 0;
                }
            }
            
            let branches = [];
            let time = 0;
            
            function resetBranches() {
                branches = [new Branch(canvas.width / 2, canvas.height * 0.8, -Math.PI / 2, 100, 0)];
            }
            resetBranches();
            
            function draw(t) {
                ctx.fillStyle = 'rgba(10, 10, 12, 0.03)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                time = t;
                
                // Grow branches
                for (let i = branches.length - 1; i >= 0; i--) {
                    const b = branches[i];
                    if (b.grown < b.length && b.depth < 6) {
                        b.grown += 0.5;
                        
                        const endX = b.x + Math.cos(b.angle) * b.grown;
                        const endY = b.y + Math.sin(b.angle) * b.grown;
                        
                        const alpha = 0.3 - b.depth * 0.04;
                        ctx.strokeStyle = `rgba(212, 175, 55, ${alpha})`;
                        ctx.lineWidth = Math.max(1, 3 - b.depth * 0.5);
                        ctx.beginPath();
                        ctx.moveTo(b.x, b.y);
                        ctx.lineTo(endX, endY);
                        ctx.stroke();
                        
                        // Spawn children at full growth
                        if (b.grown >= b.length && b.depth < 5) {
                            const newLen = b.length * 0.7;
                            const spread = 0.4 + Math.random() * 0.3;
                            branches.push(new Branch(endX, endY, b.angle - spread, newLen, b.depth + 1));
                            branches.push(new Branch(endX, endY, b.angle + spread, newLen, b.depth + 1));
                        }
                    }
                }
                
                // Reset periodically
                if (branches.every(b => b.grown >= b.length || b.depth >= 6)) {
                    if (Math.random() < 0.01) {
                        ctx.fillStyle = 'rgba(10, 10, 12, 0.1)';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        resetBranches();
                    }
                }
                
                requestAnimationFrame(draw);
            }
            draw(0);
        }
        
        // ==================== SULLIVAN: Art Nouveau spirals ====================
        const sullivanCanvas = setupCanvas('canvas-sullivan');
        if (sullivanCanvas) {
            const { canvas, ctx } = sullivanCanvas;
            
            function draw(t) {
                ctx.fillStyle = 'rgba(10, 10, 12, 0.02)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const cx = canvas.width * 0.75;
                const cy = canvas.height / 2;
                
                // Sullivan-style organic spirals
                for (let s = 0; s < 3; s++) {
                    const baseAngle = (s / 3) * Math.PI * 2 + t * 0.0002;
                    
                    ctx.strokeStyle = `rgba(212, 175, 55, ${0.15 - s * 0.03})`;
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    
                    for (let i = 0; i < 200; i++) {
                        const a = baseAngle + i * 0.08;
                        const r = 20 + i * 0.8;
                        const wobble = Math.sin(i * 0.1 + t * 0.001) * 5;
                        const x = cx + Math.cos(a) * (r + wobble);
                        const y = cy + Math.sin(a) * (r + wobble);
                        
                        if (i === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                }
                
                requestAnimationFrame(draw);
            }
            draw(0);
        }
        
        // ==================== ISLAMIC: Girih tessellation ====================
        const islamicCanvas = setupCanvas('canvas-islamic');
        if (islamicCanvas) {
            const { canvas, ctx } = islamicCanvas;
            
            function drawHexTile(x, y, size, t) {
                const phase = t * 0.0005 + x * 0.01 + y * 0.01;
                const alpha = 0.15 + Math.sin(phase) * 0.05;
                
                ctx.strokeStyle = `rgba(212, 175, 55, ${alpha})`;
                ctx.lineWidth = 1;
                
                // Hexagon outline
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2 - Math.PI / 6;
                    const px = x + Math.cos(angle) * size;
                    const py = y + Math.sin(angle) * size;
                    if (i === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.stroke();
                
                // Inner star
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    const innerAngle = angle + Math.PI / 6;
                    ctx.moveTo(x + Math.cos(angle) * size * 0.5, y + Math.sin(angle) * size * 0.5);
                    ctx.lineTo(x + Math.cos(innerAngle) * size * 0.3, y + Math.sin(innerAngle) * size * 0.3);
                }
                ctx.stroke();
            }
            
            function draw(t) {
                ctx.fillStyle = 'rgba(10, 10, 12, 0.03)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const size = 50;
                const h = size * Math.sqrt(3);
                
                for (let row = -1; row < canvas.height / h + 2; row++) {
                    for (let col = -1; col < canvas.width / (size * 1.5) + 2; col++) {
                        const x = col * size * 1.5;
                        const y = row * h + (col % 2) * h / 2;
                        drawHexTile(x, y, size, t);
                    }
                }
                
                requestAnimationFrame(draw);
            }
            draw(0);
        }
        
        // ==================== SEED: Recursive growth ====================
        const seedCanvas = setupCanvas('canvas-seed');
        if (seedCanvas) {
            const { canvas, ctx } = seedCanvas;
            
            function drawSeed(x, y, size, angle, depth, t) {
                if (depth > 5 || size < 3) return;
                
                const alpha = 0.25 - depth * 0.04;
                ctx.strokeStyle = `rgba(212, 175, 55, ${alpha})`;
                ctx.lineWidth = Math.max(1, 2 - depth * 0.3);
                
                // Draw circle
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.stroke();
                
                // Spawn children
                const numChildren = 3 + Math.floor(Math.random() * 2);
                for (let i = 0; i < numChildren; i++) {
                    const childAngle = angle + (i / numChildren) * Math.PI * 2 + Math.sin(t * 0.001) * 0.1;
                    const childDist = size * 1.3;
                    const childX = x + Math.cos(childAngle) * childDist;
                    const childY = y + Math.sin(childAngle) * childDist;
                    const childSize = size * 0.5;
                    
                    drawSeed(childX, childY, childSize, childAngle, depth + 1, t);
                }
            }
            
            function draw(t) {
                ctx.fillStyle = 'rgba(10, 10, 12, 0.015)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Single seed that occasionally redraws
                if (Math.random() < 0.01) {
                    drawSeed(canvas.width * 0.7, canvas.height / 2, 40, 0, 0, t);
                }
                
                requestAnimationFrame(draw);
            }
            draw(0);
        }
        
        // ==================== SYMMETRY: Rotation groups ====================
        const symmetryCanvas = setupCanvas('canvas-symmetry');
        if (symmetryCanvas) {
            const { canvas, ctx } = symmetryCanvas;
            
            function draw(t) {
                ctx.fillStyle = 'rgba(10, 10, 12, 0.04)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const cx = canvas.width / 2;
                const cy = canvas.height / 2;
                
                // Show different rotational symmetries
                const symmetries = [2, 3, 4, 6];
                
                symmetries.forEach((n, idx) => {
                    const offsetX = (idx - 1.5) * 120;
                    const r = 40;
                    const phase = t * 0.0003 * (n + 1);
                    
                    ctx.strokeStyle = 'rgba(212, 175, 55, 0.25)';
                    ctx.lineWidth = 1;
                    
                    for (let i = 0; i < n; i++) {
                        const angle = (i / n) * Math.PI * 2 + phase;
                        ctx.beginPath();
                        ctx.moveTo(cx + offsetX, cy);
                        ctx.lineTo(cx + offsetX + Math.cos(angle) * r, cy + Math.sin(angle) * r);
                        ctx.stroke();
                        
                        ctx.fillStyle = 'rgba(212, 175, 55, 0.4)';
                        ctx.beginPath();
                        ctx.arc(cx + offsetX + Math.cos(angle) * r, cy + Math.sin(angle) * r, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
                
                requestAnimationFrame(draw);
            }
            draw(0);
        }
        
        // ==================== SEVENTEEN: The 17 wallpaper groups hint ====================
        const seventeenCanvas = setupCanvas('canvas-seventeen');
        if (seventeenCanvas) {
            const { canvas, ctx } = seventeenCanvas;
            
            function draw(t) {
                ctx.fillStyle = 'rgba(10, 10, 12, 0.02)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // 17 small patterns scattered
                const patterns = [];
                for (let i = 0; i < 17; i++) {
                    const angle = (i / 17) * Math.PI * 2;
                    const r = 150 + Math.sin(t * 0.001 + i) * 20;
                    patterns.push({
                        x: canvas.width / 2 + Math.cos(angle) * r,
                        y: canvas.height / 2 + Math.sin(angle) * r,
                        fold: [2, 3, 4, 6][i % 4]
                    });
                }
                
                patterns.forEach((p, i) => {
                    const alpha = 0.2 + Math.sin(t * 0.002 + i) * 0.1;
                    ctx.strokeStyle = `rgba(212, 175, 55, ${alpha})`;
                    ctx.lineWidth = 1;
                    
                    ctx.beginPath();
                    for (let j = 0; j < p.fold; j++) {
                        const a = (j / p.fold) * Math.PI * 2 + t * 0.0002;
                        const x = p.x + Math.cos(a) * 15;
                        const y = p.y + Math.sin(a) * 15;
                        if (j === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                });
                
                requestAnimationFrame(draw);
            }
            draw(0);
        }
        
        // ==================== BEYOND: Higher dimensional hint ====================
        const beyondCanvas = setupCanvas('canvas-beyond');
        if (beyondCanvas) {
            const { canvas, ctx } = beyondCanvas;
            
            // 4D hypercube vertices
            const vertices4D = [];
            for (let i = 0; i < 16; i++) {
                vertices4D.push([
                    (i & 1) ? 1 : -1,
                    (i & 2) ? 1 : -1,
                    (i & 4) ? 1 : -1,
                    (i & 8) ? 1 : -1
                ]);
            }
            
            function draw(t) {
                ctx.fillStyle = 'rgba(10, 10, 12, 0.04)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const cx = canvas.width * 0.7;
                const cy = canvas.height / 2;
                const scale = 60;
                
                const rotXW = t * 0.0003;
                const rotYZ = t * 0.0002;
                
                const projected = vertices4D.map(([x, y, z, w]) => {
                    // Rotate in XW plane
                    let x1 = x * Math.cos(rotXW) - w * Math.sin(rotXW);
                    let w1 = x * Math.sin(rotXW) + w * Math.cos(rotXW);
                    // Rotate in YZ plane
                    let y1 = y * Math.cos(rotYZ) - z * Math.sin(rotYZ);
                    let z1 = y * Math.sin(rotYZ) + z * Math.cos(rotYZ);
                    // Project to 2D
                    const perspective = 2 / (3 - w1);
                    return [cx + x1 * scale * perspective, cy + y1 * scale * perspective, z1];
                });
                
                // Draw edges (vertices that differ by one bit)
                ctx.strokeStyle = 'rgba(212, 175, 55, 0.2)';
                ctx.lineWidth = 1;
                for (let i = 0; i < 16; i++) {
                    for (let j = i + 1; j < 16; j++) {
                        const diff = i ^ j;
                        if ((diff & (diff - 1)) === 0) { // exactly one bit different
                            ctx.beginPath();
                            ctx.moveTo(projected[i][0], projected[i][1]);
                            ctx.lineTo(projected[j][0], projected[j][1]);
                            ctx.stroke();
                        }
                    }
                }
                
                // Draw vertices
                projected.forEach(([x, y, z]) => {
                    const alpha = 0.3 + z * 0.15;
                    ctx.fillStyle = `rgba(212, 175, 55, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                requestAnimationFrame(draw);
            }
            draw(0);
        }
        
        // ==================== MIRROR: Infinity reflections ====================
        const mirrorCanvas = setupCanvas('canvas-mirror');
        if (mirrorCanvas) {
            const { canvas, ctx } = mirrorCanvas;
            
            function draw(t) {
                ctx.fillStyle = 'rgba(10, 10, 12, 0.04)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const cx = canvas.width / 2;
                const cy = canvas.height / 2;
                
                // Receding rectangles (infinity mirror effect)
                for (let i = 0; i < 20; i++) {
                    const scale = 1 - i * 0.045;
                    const w = 300 * scale;
                    const h = 200 * scale;
                    const alpha = 0.3 * Math.pow(0.85, i);
                    const offset = Math.sin(t * 0.002 + i * 0.3) * 2;
                    
                    ctx.strokeStyle = `rgba(212, 175, 55, ${alpha})`;
                    ctx.lineWidth = 1;
                    ctx.strokeRect(cx - w/2 + offset, cy - h/2, w, h);
                }
                
                requestAnimationFrame(draw);
            }
            draw(0);
        }
        
        // ==================== COMPRESSION: Lattice funnel ====================
        const compressionCanvas = setupCanvas('canvas-compression');
        if (compressionCanvas) {
            const { canvas, ctx } = compressionCanvas;
            
            const particles = [];
            for (let i = 0; i < 50; i++) {
                particles.push({
                    y: Math.random(),
                    angle: Math.random() * Math.PI * 2,
                    radius: 0.3 + Math.random() * 0.2,
                    speed: 0.001 + Math.random() * 0.001
                });
            }
            
            function draw(t) {
                ctx.fillStyle = 'rgba(10, 10, 12, 0.03)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const cx = canvas.width * 0.7;
                const topY = canvas.height * 0.15;
                const bottomY = canvas.height * 0.85;
                
                // Draw funnel outline
                ctx.strokeStyle = 'rgba(212, 175, 55, 0.15)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(cx - 150, topY);
                ctx.lineTo(cx - 30, bottomY);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(cx + 150, topY);
                ctx.lineTo(cx + 30, bottomY);
                ctx.stroke();
                
                // Animate particles
                particles.forEach(p => {
                    p.y += p.speed;
                    if (p.y > 1) {
                        p.y = 0;
                        p.angle = Math.random() * Math.PI * 2;
                        p.radius = 0.3 + Math.random() * 0.2;
                    }
                    
                    const yPos = topY + p.y * (bottomY - topY);
                    const maxRadius = 150 * (1 - p.y) + 30 * p.y;
                    const r = maxRadius * p.radius;
                    const x = cx + Math.cos(p.angle + t * 0.001) * r;
                    
                    ctx.fillStyle = `rgba(212, 175, 55, ${0.4 * (1 - p.y * 0.5)})`;
                    ctx.beginPath();
                    ctx.arc(x, yPos, 2, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                requestAnimationFrame(draw);
            }
            draw(0);
        }
        
        // ==================== SEVEN: Octonion structure ====================
        const sevenCanvas = setupCanvas('canvas-seven');
        if (sevenCanvas) {
            const { canvas, ctx } = sevenCanvas;
            
            function draw(t) {
                ctx.fillStyle = 'rgba(10, 10, 12, 0.03)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const cx = canvas.width * 0.7;
                const cy = canvas.height / 2;
                const r = 100;
                
                // Center point (e₀ — the real part)
                ctx.fillStyle = 'rgba(212, 175, 55, 0.7)';
                ctx.beginPath();
                ctx.arc(cx, cy, 10, 0, Math.PI * 2);
                ctx.fill();
                
                // 7 imaginary directions
                for (let i = 0; i < 7; i++) {
                    const angle = (i / 7) * Math.PI * 2 + t * 0.0003;
                    const x = cx + Math.cos(angle) * r;
                    const y = cy + Math.sin(angle) * r;
                    
                    // Connection line
                    ctx.strokeStyle = 'rgba(212, 175, 55, 0.2)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(cx, cy);
                    ctx.lineTo(x, y);
                    ctx.stroke();
                    
                    // Point
                    ctx.fillStyle = 'rgba(250, 250, 248, 0.6)';
                    ctx.beginPath();
                    ctx.arc(x, y, 6, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Fano plane hints (some triangular connections)
                ctx.strokeStyle = 'rgba(212, 175, 55, 0.1)';
                for (let i = 0; i < 7; i++) {
                    const a1 = (i / 7) * Math.PI * 2 + t * 0.0003;
                    const a2 = ((i + 1) / 7) * Math.PI * 2 + t * 0.0003;
                    const a3 = ((i + 3) / 7) * Math.PI * 2 + t * 0.0003;
                    
                    ctx.beginPath();
                    ctx.moveTo(cx + Math.cos(a1) * r, cy + Math.sin(a1) * r);
                    ctx.lineTo(cx + Math.cos(a2) * r, cy + Math.sin(a2) * r);
                    ctx.lineTo(cx + Math.cos(a3) * r, cy + Math.sin(a3) * r);
                    ctx.closePath();
                    ctx.stroke();
                }
                
                requestAnimationFrame(draw);
            }
            draw(0);
        }
        
        // ==================== END: Unified pattern ====================
        const endCanvas = setupCanvas('canvas-end');
        if (endCanvas) {
            const { canvas, ctx } = endCanvas;
            
            function draw(t) {
                ctx.fillStyle = 'rgba(10, 10, 12, 0.02)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const cx = canvas.width / 2;
                const cy = canvas.height / 2;
                
                // Nested geometric forms — the grammar
                for (let i = 0; i < 7; i++) {
                    const r = 40 + i * 25;
                    const n = 3 + (i % 4); // Triangle, square, pentagon, hexagon...
                    const phase = t * 0.0002 * (i + 1);
                    const alpha = 0.2 - i * 0.02;
                    
                    ctx.strokeStyle = `rgba(212, 175, 55, ${alpha})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    for (let j = 0; j < n; j++) {
                        const angle = (j / n) * Math.PI * 2 + phase;
                        const x = cx + Math.cos(angle) * r;
                        const y = cy + Math.sin(angle) * r;
                        if (j === 0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                }
                
                requestAnimationFrame(draw);
            }
            draw(0);
        }
    </script>
</body>
</html>
