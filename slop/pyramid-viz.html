<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Pyramid — KagamiOS Test Audit</title>
    <meta name="description" content="Interactive visualization of the inverted test pyramid.">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>鏡</text></svg>">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;600&family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">

    <style>
        :root {
            --void: #050508;
            --surface: #0a0a0f;
            --text: #f0f0f5;
            --text-dim: #6b6b78;

            --unit: #30d158;
            --integration: #af52de;
            --e2e: #ffd60a;

            --glow-unit: rgba(48, 209, 88, 0.4);
            --glow-int: rgba(175, 82, 222, 0.4);
            --glow-e2e: rgba(255, 214, 10, 0.4);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--void);
            color: var(--text);
            min-height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 40px;
        }

        h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(24px, 4vw, 40px);
            font-weight: 700;
            margin-bottom: 20px;
            text-align: center;
            background: linear-gradient(135deg, var(--text), var(--text-dim));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .subtitle {
            font-size: 14px;
            color: var(--text-dim);
            margin-bottom: 60px;
            text-align: center;
        }

        #pyramid-canvas {
            max-width: 100%;
            cursor: crosshair;
        }

        .legend {
            display: flex;
            gap: 40px;
            margin-top: 40px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 14px;
            color: var(--text-dim);
            transition: all 0.3s ease;
        }

        .legend-item:hover {
            color: var(--text);
        }

        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            box-shadow: 0 0 12px currentColor;
        }

        .legend-dot.unit { background: var(--unit); color: var(--unit); }
        .legend-dot.integration { background: var(--integration); color: var(--integration); }
        .legend-dot.e2e { background: var(--e2e); color: var(--e2e); }

        .stats {
            display: flex;
            gap: 60px;
            margin-top: 60px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .stat {
            text-align: center;
        }

        .stat-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 42px;
            font-weight: 700;
            line-height: 1;
        }

        .stat-value.unit { color: var(--unit); }
        .stat-value.integration { color: var(--integration); }
        .stat-value.e2e { color: var(--e2e); }

        .stat-label {
            font-size: 12px;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-top: 8px;
        }

        .back-link {
            position: fixed;
            top: 20px;
            left: 20px;
            color: var(--text-dim);
            text-decoration: none;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: color 0.2s;
        }

        .back-link:hover {
            color: var(--text);
        }

        .tooltip {
            position: fixed;
            background: var(--surface);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: 12px 16px;
            font-size: 13px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 100;
            max-width: 250px;
        }

        .tooltip.visible {
            opacity: 1;
        }

        .tooltip-title {
            font-weight: 600;
            margin-bottom: 4px;
        }

        .tooltip-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 24px;
            font-weight: 700;
        }

        .tooltip-desc {
            font-size: 12px;
            color: var(--text-dim);
            margin-top: 8px;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">← Back to Overview</a>

    <div class="container">
        <h1>The Inverted Pyramid</h1>
        <p class="subtitle">Hover over sections to explore. Click for details.</p>

        <canvas id="pyramid-canvas" width="600" height="500"></canvas>

        <div class="legend">
            <div class="legend-item">
                <span class="legend-dot unit"></span>
                <span>unit/ folder (23%)</span>
            </div>
            <div class="legend-item">
                <span class="legend-dot integration"></span>
                <span>core/ folder (43%)</span>
            </div>
            <div class="legend-item">
                <span class="legend-dot e2e"></span>
                <span>other/ (34%)</span>
            </div>
        </div>

        <div class="stats">
            <div class="stat">
                <div class="stat-value unit" id="unit-count">2,554</div>
                <div class="stat-label">unit/</div>
            </div>
            <div class="stat">
                <div class="stat-value integration" id="int-count">4,803</div>
                <div class="stat-label">core/</div>
            </div>
            <div class="stat">
                <div class="stat-value e2e" id="e2e-count">3,885</div>
                <div class="stat-label">other</div>
            </div>
        </div>
    </div>

    <div class="tooltip" id="tooltip">
        <div class="tooltip-title"></div>
        <div class="tooltip-value"></div>
        <div class="tooltip-desc"></div>
    </div>

    <script>
        const canvas = document.getElementById('pyramid-canvas');
        const ctx = canvas.getContext('2d');
        const tooltip = document.getElementById('tooltip');

        // Colors
        const colors = {
            unit: { fill: '#30d158', glow: 'rgba(48, 209, 88, 0.4)' },
            integration: { fill: '#af52de', glow: 'rgba(175, 82, 222, 0.4)' },
            e2e: { fill: '#ffd60a', glow: 'rgba(255, 214, 10, 0.4)' }
        };

        // Data (CORRECTED - by folder, not markers)
        const sections = [
            {
                type: 'unit',
                percent: 23,
                count: 2554,
                label: 'unit/ folder',
                desc: 'Pure unit tests - fast, isolated'
            },
            {
                type: 'integration',
                percent: 43,
                count: 4803,
                label: 'core/ folder',
                desc: 'Mixed unit + integration tests (CBF safety verified here)'
            },
            {
                type: 'e2e',
                percent: 34,
                count: 3885,
                label: 'Other folders',
                desc: 'integration/, forge/, e2e/, satellites/'
            }
        ];

        // Animation state
        let hoveredSection = null;
        let animationFrame = 0;
        let mouseX = 0;
        let mouseY = 0;

        // Pyramid geometry (inverted - widest at top)
        function getPyramidGeometry() {
            const cx = canvas.width / 2;
            const topY = 50;
            const bottomY = canvas.height - 50;
            const maxWidth = 500;
            const minWidth = 100;

            // Heights proportional to percentages
            const totalHeight = bottomY - topY;

            let currentY = topY;
            const geometries = [];

            sections.forEach((section, i) => {
                const sectionHeight = (section.percent / 100) * totalHeight;
                const startWidth = maxWidth - (currentY - topY) / totalHeight * (maxWidth - minWidth);
                const endWidth = maxWidth - (currentY + sectionHeight - topY) / totalHeight * (maxWidth - minWidth);

                geometries.push({
                    ...section,
                    path: [
                        { x: cx - startWidth / 2, y: currentY },
                        { x: cx + startWidth / 2, y: currentY },
                        { x: cx + endWidth / 2, y: currentY + sectionHeight },
                        { x: cx - endWidth / 2, y: currentY + sectionHeight }
                    ],
                    centerY: currentY + sectionHeight / 2
                });

                currentY += sectionHeight;
            });

            return geometries;
        }

        function isPointInPath(x, y, path) {
            let inside = false;
            for (let i = 0, j = path.length - 1; i < path.length; j = i++) {
                const xi = path[i].x, yi = path[i].y;
                const xj = path[j].x, yj = path[j].y;

                if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
                    inside = !inside;
                }
            }
            return inside;
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            animationFrame++;

            const geometries = getPyramidGeometry();

            // Draw glow effect behind
            geometries.forEach((geo, i) => {
                const color = colors[geo.type];
                const isHovered = hoveredSection === i;

                ctx.save();

                // Animated glow
                const glowIntensity = isHovered ? 30 : 15;
                const pulseOffset = Math.sin(animationFrame * 0.02 + i) * 5;

                ctx.shadowColor = color.glow;
                ctx.shadowBlur = glowIntensity + pulseOffset;

                ctx.beginPath();
                ctx.moveTo(geo.path[0].x, geo.path[0].y);
                geo.path.forEach(p => ctx.lineTo(p.x, p.y));
                ctx.closePath();

                // Fill with gradient
                const gradient = ctx.createLinearGradient(0, geo.path[0].y, 0, geo.path[2].y);
                gradient.addColorStop(0, color.fill);
                gradient.addColorStop(1, adjustBrightness(color.fill, isHovered ? 1.2 : 0.8));

                ctx.fillStyle = gradient;
                ctx.fill();

                // Border
                ctx.strokeStyle = isHovered ? '#fff' : 'rgba(255,255,255,0.2)';
                ctx.lineWidth = isHovered ? 2 : 1;
                ctx.stroke();

                ctx.restore();

                // Label
                const labelY = geo.centerY;
                ctx.fillStyle = '#000';
                ctx.font = `bold ${isHovered ? 16 : 14}px Inter`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`${geo.percent}%`, canvas.width / 2, labelY);
            });

            // Draw particle effects
            drawParticles(geometries);

            requestAnimationFrame(draw);
        }

        // Particles
        const particles = [];
        for (let i = 0; i < 30; i++) {
            particles.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                vx: (Math.random() - 0.5) * 0.5,
                vy: (Math.random() - 0.5) * 0.5 - 0.2,
                size: Math.random() * 2 + 1,
                alpha: Math.random() * 0.5 + 0.2,
                color: ['#30d158', '#af52de', '#ffd60a'][Math.floor(Math.random() * 3)]
            });
        }

        function drawParticles(geometries) {
            particles.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;

                // Wrap around
                if (p.x < 0) p.x = canvas.width;
                if (p.x > canvas.width) p.x = 0;
                if (p.y < 0) p.y = canvas.height;
                if (p.y > canvas.height) p.y = 0;

                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fillStyle = p.color.replace(')', `, ${p.alpha})`).replace('rgb', 'rgba');
                ctx.fill();
            });
        }

        function adjustBrightness(hex, factor) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);

            return `rgb(${Math.min(255, r * factor)}, ${Math.min(255, g * factor)}, ${Math.min(255, b * factor)})`;
        }

        // Mouse interaction
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;

            const geometries = getPyramidGeometry();
            let found = null;

            geometries.forEach((geo, i) => {
                if (isPointInPath(mouseX, mouseY, geo.path)) {
                    found = i;
                }
            });

            hoveredSection = found;

            if (found !== null) {
                const geo = geometries[found];
                const tooltipEl = document.querySelector('.tooltip-title');
                const valueEl = document.querySelector('.tooltip-value');
                const descEl = document.querySelector('.tooltip-desc');

                tooltipEl.textContent = geo.label;
                tooltipEl.style.color = colors[geo.type].fill;
                valueEl.textContent = geo.count.toLocaleString();
                valueEl.style.color = colors[geo.type].fill;
                descEl.textContent = geo.desc;

                tooltip.style.left = `${e.clientX + 15}px`;
                tooltip.style.top = `${e.clientY + 15}px`;
                tooltip.classList.add('visible');

                canvas.style.cursor = 'pointer';
            } else {
                tooltip.classList.remove('visible');
                canvas.style.cursor = 'crosshair';
            }
        });

        canvas.addEventListener('mouseleave', () => {
            hoveredSection = null;
            tooltip.classList.remove('visible');
        });

        canvas.addEventListener('click', () => {
            if (hoveredSection !== null) {
                const geo = getPyramidGeometry()[hoveredSection];
                // Could navigate to detailed view
                console.log('Clicked:', geo.label);
            }
        });

        // Start
        draw();

        // Responsive
        function resize() {
            const container = canvas.parentElement;
            const maxWidth = Math.min(600, container.clientWidth - 80);
            const scale = maxWidth / 600;

            canvas.style.width = `${600 * scale}px`;
            canvas.style.height = `${500 * scale}px`;
        }

        window.addEventListener('resize', resize);
        resize();
    </script>
</body>
</html>
