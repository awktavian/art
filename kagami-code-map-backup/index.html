<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#06060a">
    <meta name="description" content="Interactive semantic code visualization — explore your codebase in 3D">
    
    <!-- PWA -->
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/svg+xml" href="icon.svg">
    <link rel="apple-touch-icon" href="icon-192.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Code Galaxy">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500&family=IBM+Plex+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
    <title>Code Galaxy</title>
    <style>
        /* ═══════════════════════════════════════════════════════════════════════════════
           DESIGN TOKENS
           ═══════════════════════════════════════════════════════════════════════════════ */
        :root {
            --void-900: #020204;
            --void-800: #06060a;
            --void-700: #0c0c14;
            --void-600: #12121a;
            --void-500: #1a1a24;
            --void-400: #24242e;
            --void-300: #2b2b36;
            
            --text-100: #f5f2eb;
            --text-200: #e0ddd4;
            --text-300: #c8c4ba;
            --text-400: #9a978e;
            --text-500: #7a7870;
            --text-600: #5a5850;
            
            --gold-400: #f8d878;
            --gold-500: #f0c860;
            --gold-600: #d4a840;
            --gold-glow: rgba(240, 200, 96, 0.4);
            
            --border-1: rgba(255, 255, 255, 0.04);
            --border-2: rgba(255, 255, 255, 0.08);
            --border-3: rgba(255, 255, 255, 0.14);
            
            --glass-1: rgba(10, 10, 16, 0.75);
            --glass-2: rgba(12, 12, 20, 0.9);
            --shadow-1: 0 18px 50px rgba(0, 0, 0, 0.45);
            --shadow-2: 0 8px 22px rgba(0, 0, 0, 0.35);
            
            --font-sans: "IBM Plex Sans", system-ui, sans-serif;
            --font-mono: "IBM Plex Mono", "SF Mono", monospace;
            
            --ease-out: cubic-bezier(0.16, 1, 0.3, 1);
            --ease-spring: cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        /* ═══════════════════════════════════════════════════════════════════════════════
           RESET & BASE
           ═══════════════════════════════════════════════════════════════════════════════ */
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        
        html, body {
            width: 100%; height: 100%;
            background: var(--void-800);
            color: var(--text-100);
            font-family: var(--font-sans);
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            text-rendering: optimizeLegibility;
            font-feature-settings: "kern" 1, "liga" 1, "calt" 1;
        }
        
        /* Selection microdelight */
        ::selection {
            background: rgba(240, 200, 96, 0.35);
            color: var(--text-100);
        }
        
        body::before {
            content: '';
            position: fixed;
            inset: 0;
            pointer-events: none;
            background:
                radial-gradient(circle at 10% 20%, rgba(240, 200, 96, 0.05), transparent 45%),
                radial-gradient(circle at 80% 10%, rgba(68, 120, 255, 0.04), transparent 50%),
                radial-gradient(circle at 70% 80%, rgba(110, 117, 130, 0.07), transparent 55%);
            mix-blend-mode: screen;
            opacity: 0.9;
        }
        
        button { 
            border: none; 
            background: none; 
            cursor: pointer; 
            font: inherit; 
            color: inherit;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        
        /* Button ripple effect container */
        button::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: inherit;
            background: radial-gradient(circle at var(--ripple-x, 50%) var(--ripple-y, 50%), 
                rgba(255, 255, 255, 0.2) 0%, 
                transparent 60%);
            opacity: 0;
            transform: scale(0);
            transition: opacity 0.3s ease, transform 0.4s ease;
            pointer-events: none;
        }
        
        button:active::after {
            opacity: 1;
            transform: scale(2);
            transition: opacity 0s, transform 0s;
        }
        
        canvas { display: block; }
        
        /* ═══════════════════════════════════════════════════════════════════════════════
           LAYOUT
           ═══════════════════════════════════════════════════════════════════════════════ */
        #app {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        
        .header {
            height: 56px;
            display: flex;
            align-items: center;
            gap: 20px;
            padding: 0 24px;
            background: linear-gradient(180deg, var(--void-700) 0%, rgba(6, 6, 10, 0.98) 100%);
            border-bottom: 1px solid var(--border-1);
            z-index: 100;
            flex-shrink: 0;
        }
        
        /* ═══════════════════════════════════════════════════════════════════════════════
           SUB-NAVIGATION ROW — Breadcrumbs + Categories + View Toggle
           ═══════════════════════════════════════════════════════════════════════════════ */
        .sub-nav {
            height: 48px;
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 0 24px;
            background: linear-gradient(180deg, rgba(6, 6, 10, 0.98) 0%, rgba(4, 4, 8, 0.95) 100%);
            border-bottom: 1px solid var(--border-1);
            z-index: 99;
            flex-shrink: 0;
            overflow-x: auto;
            scrollbar-width: none;
        }
        
        .sub-nav::-webkit-scrollbar { display: none; }
        
        .nav-breadcrumbs {
            display: flex;
            align-items: center;
            gap: 4px;
            flex-shrink: 0;
        }
        
        .nav-crumb {
            padding: 5px 10px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            color: var(--text-400);
            cursor: pointer;
            transition: all 0.2s var(--ease-out);
            white-space: nowrap;
        }
        
        .nav-crumb:hover:not(.current) {
            color: var(--text-100);
            background: var(--void-500);
        }
        
        .nav-crumb.current {
            color: var(--gold-500);
            background: rgba(240, 200, 96, 0.1);
            cursor: default;
        }
        
        .nav-sep {
            color: var(--text-600);
            font-size: 11px;
            opacity: 0.5;
        }
        
        .nav-back {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            background: var(--void-500);
            color: var(--text-300);
            font-size: 12px;
            display: grid;
            place-items: center;
            transition: all 0.2s var(--ease-spring);
            border: 1px solid var(--border-1);
            flex-shrink: 0;
        }
        
        .nav-back:hover {
            background: var(--void-400);
            color: var(--text-100);
            transform: translateX(-2px);
        }
        
        .nav-divider {
            width: 1px;
            height: 24px;
            background: var(--border-2);
            flex-shrink: 0;
        }
        
        .nav-categories {
            display: flex;
            align-items: center;
            gap: 6px;
            flex: 1;
            overflow-x: auto;
            scrollbar-width: none;
            padding: 2px 0;
        }
        
        .nav-categories::-webkit-scrollbar { display: none; }
        
        .cat-pill {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 7px 14px;
            border-radius: 999px;
            font-size: 12px;
            font-weight: 550;
            color: var(--text-400);
            background: linear-gradient(135deg, var(--void-600) 0%, var(--void-700) 100%);
            border: 1px solid var(--border-1);
            cursor: pointer;
            transition: all 0.25s var(--ease-spring);
            white-space: nowrap;
            flex-shrink: 0;
            letter-spacing: 0.01em;
        }
        
        .cat-pill:hover {
            background: linear-gradient(135deg, var(--void-500) 0%, var(--void-600) 100%);
            color: var(--text-100);
            border-color: var(--border-3);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.25);
        }
        
        .cat-pill.active {
            background: linear-gradient(135deg, var(--cat-color, var(--gold-500)) 0%, var(--cat-color-dark, var(--gold-600)) 100%);
            color: var(--void-900);
            border-color: transparent;
            font-weight: 650;
            box-shadow: 
                0 3px 12px var(--cat-glow, rgba(240, 200, 96, 0.35)),
                inset 0 1px 0 rgba(255,255,255,0.2);
            transform: translateY(-1px);
        }
        
        .cat-pill.active:hover {
            transform: translateY(-3px);
            box-shadow: 
                0 6px 18px var(--cat-glow, rgba(240, 200, 96, 0.45)),
                inset 0 1px 0 rgba(255,255,255,0.2);
        }
        
        .cat-dot {
            width: 7px;
            height: 7px;
            border-radius: 50%;
            background: currentColor;
            flex-shrink: 0;
            box-shadow: 0 0 6px currentColor;
        }
        
        .cat-pill.active .cat-dot {
            background: var(--void-900);
            box-shadow: none;
        }
        
        .cat-count {
            font-size: 10px;
            opacity: 0.75;
            font-family: var(--font-mono);
            font-weight: 600;
        }
        
        .view-toggle {
            display: flex;
            align-items: center;
            gap: 3px;
            padding: 4px;
            background: linear-gradient(135deg, var(--void-600) 0%, var(--void-700) 100%);
            border-radius: 12px;
            border: 1px solid var(--border-2);
            flex-shrink: 0;
            margin-left: auto;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }
        
        .view-btn {
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 550;
            color: var(--text-400);
            transition: all 0.25s var(--ease-spring);
            letter-spacing: 0.02em;
        }
        
        .view-btn:hover:not(.active) {
            color: var(--text-100);
            background: rgba(255,255,255,0.06);
        }
        
        .view-btn.active {
            background: linear-gradient(135deg, var(--gold-400) 0%, var(--gold-600) 100%);
            color: var(--void-900);
            box-shadow: 
                0 3px 12px rgba(240, 200, 96, 0.35),
                inset 0 1px 0 rgba(255,255,255,0.2);
            font-weight: 650;
        }
        
        .view-btn.active:hover {
            box-shadow: 
                0 5px 16px rgba(240, 200, 96, 0.45),
                inset 0 1px 0 rgba(255,255,255,0.2);
            transform: translateY(-1px);
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 20px;
            font-weight: 600;
            color: var(--gold-500);
            letter-spacing: -0.02em;
            cursor: default;
            user-select: none;
            transition: transform 0.3s var(--ease-spring);
        }
        
        .logo:hover {
            transform: scale(1.02);
        }
        
        .logo:hover .logo-icon {
            animation-duration: 1.5s;
        }
        
        .logo-icon {
            font-size: 28px;
            filter: drop-shadow(0 0 12px var(--gold-glow));
            animation: pulse-glow 3s ease-in-out infinite, float 6s ease-in-out infinite;
            transform-origin: center;
        }
        
        @keyframes pulse-glow {
            0%, 100% { filter: drop-shadow(0 0 12px var(--gold-glow)); }
            50% { filter: drop-shadow(0 0 24px var(--gold-glow)) drop-shadow(0 0 8px rgba(240, 200, 96, 0.3)); }
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            25% { transform: translateY(-2px) rotate(-2deg); }
            75% { transform: translateY(2px) rotate(2deg); }
        }
        
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.001ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.001ms !important;
                scroll-behavior: auto !important;
            }
        }
        
        /* Tabs moved to sub-nav, keeping class for backwards compat */
        .tabs { display: none; }
        
        /* ═══════════════════════════════════════════════════════════════════════════════
           SEARCH — Premium search experience
           ═══════════════════════════════════════════════════════════════════════════════ */
        .search {
            flex: 1;
            max-width: 520px;
            position: relative;
        }
        
        .search input {
            width: 100%;
            height: 44px;
            padding: 0 52px 0 48px;
            background: linear-gradient(135deg, var(--void-600) 0%, var(--void-700) 100%);
            border: 1px solid var(--border-2);
            border-radius: 14px;
            color: var(--text-100);
            font-size: 14px;
            font-weight: 450;
            letter-spacing: 0.01em;
            outline: none;
            transition: all 0.25s var(--ease-out), box-shadow 0.4s var(--ease-spring);
        }
        
        .search input:hover:not(:focus) {
            border-color: var(--border-3);
            background: linear-gradient(135deg, var(--void-500) 0%, var(--void-600) 100%);
        }
        
        .search input:focus {
            border-color: var(--gold-500);
            box-shadow: 
                0 0 0 4px rgba(240, 200, 96, 0.15), 
                0 12px 32px rgba(0,0,0,0.4),
                inset 0 1px 0 rgba(255,255,255,0.03);
            background: var(--void-700);
        }
        
        .search input::placeholder { 
            color: var(--text-500);
            font-weight: 400;
            transition: all 0.2s ease;
        }
        
        .search input:focus::placeholder {
            color: var(--text-600);
            transform: translateX(4px);
        }
        
        .search-icon {
            position: absolute;
            left: 16px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 15px;
            color: var(--text-500);
            pointer-events: none;
            transition: all 0.25s var(--ease-spring);
        }
        
        .search input:focus ~ .search-icon {
            color: var(--gold-500);
            transform: translateY(-50%) scale(1.1);
        }
        
        .search-kbd {
            position: absolute;
            right: 14px;
            top: 50%;
            transform: translateY(-50%);
            padding: 4px 8px;
            background: linear-gradient(135deg, var(--void-400) 0%, var(--void-500) 100%);
            border: 1px solid var(--border-3);
            border-radius: 6px;
            font-family: var(--font-mono);
            font-size: 11px;
            font-weight: 600;
            color: var(--text-400);
            pointer-events: none;
            opacity: 0.85;
            transition: all 0.25s var(--ease-spring);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2), inset 0 1px 0 rgba(255,255,255,0.04);
        }
        
        .search input:focus ~ .search-kbd {
            opacity: 0;
            transform: translateY(-50%) scale(0.9);
        }
        
        /* Voice Search Button */
        .voice-btn {
            position: absolute;
            right: 48px;
            top: 50%;
            transform: translateY(-50%);
            width: 28px;
            height: 28px;
            padding: 0;
            background: transparent;
            border: none;
            border-radius: 6px;
            color: var(--text-500);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s var(--ease-out);
            z-index: 2;
        }
        
        .voice-btn svg {
            width: 16px;
            height: 16px;
        }
        
        .voice-btn:hover {
            color: var(--text-200);
            background: var(--void-500);
        }
        
        .voice-btn.listening {
            color: var(--gold-400);
            animation: voice-pulse 1.5s ease-in-out infinite;
        }
        
        .voice-btn.listening svg {
            filter: drop-shadow(0 0 4px var(--gold-500));
        }
        
        @keyframes voice-pulse {
            0%, 100% { transform: translateY(-50%) scale(1); }
            50% { transform: translateY(-50%) scale(1.1); }
        }
        
        .voice-btn.unsupported {
            display: none;
        }
        
        .search input:focus ~ .voice-btn {
            right: 14px;
        }
        
        /* Search Results Dropdown — Clean, minimal typeahead */
        .search-results {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            margin-top: 8px;
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            background: var(--void-800);
            border: 1px solid var(--border-3);
            border-radius: 12px;
            box-shadow: 0 16px 48px rgba(0, 0, 0, 0.5);
            z-index: 200;
            opacity: 0;
            transform: translateY(-8px);
            transition: all 0.2s var(--ease-out);
        }
        
        .search-results.active { 
            display: block;
            opacity: 1;
            transform: translateY(0);
        }
        
        .search-results::-webkit-scrollbar { width: 6px; }
        .search-results::-webkit-scrollbar-track { background: transparent; }
        .search-results::-webkit-scrollbar-thumb {
            background: var(--void-400);
            border-radius: 3px;
        }
        
        /* Search result rows — clean list style */
        .search-result {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 16px;
            cursor: pointer;
            transition: background 0.15s ease;
            border-bottom: 1px solid var(--border-1);
        }
        
        .search-result:last-child {
            border-bottom: none;
        }
        
        .search-result:hover { 
            background: var(--void-600);
        }
        
        .search-result.selected { 
            background: var(--void-500);
        }
        
        .search-result-icon {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            display: grid;
            place-items: center;
            font-size: 14px;
            flex-shrink: 0;
        }
        
        .search-result-content {
            flex: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .search-result-name {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-100);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .search-result-path {
            font: 11px var(--font-mono);
            color: var(--text-500);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        /* Hide verbose meta on results — keep it minimal */
        .search-result-summary,
        .search-result-meta {
            display: none;
        }
        
        .search-result-score {
            font: 600 11px var(--font-mono);
            color: var(--text-500);
            flex-shrink: 0;
        }
        
        /* Token Highlighting — clean highlight */
        .token-match {
            color: var(--gold-400);
            background: rgba(240, 200, 96, 0.15);
            padding: 0 2px;
            border-radius: 2px;
            font-weight: 600;
        }
        
        .search-empty {
            padding: 32px 20px;
            text-align: center;
            color: var(--text-500);
            font-size: 13px;
        }
        
        /* Category headers — subtle dividers */
        .search-header {
            padding: 8px 16px 6px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-500);
            background: var(--void-700);
            border-bottom: 1px solid var(--border-1);
            position: sticky;
            top: 0;
            z-index: 1;
        }
        
        .search::before {
            content: '⌘';
            position: absolute;
            left: 17px;
            top: 50%;
            transform: translateY(-50%);
            font: 600 12px var(--font-sans);
            color: var(--text-500);
            pointer-events: none;
            opacity: 0;
        }
        
        .stats {
            display: flex;
            gap: 12px;
            font-size: 13px;
            color: var(--text-400);
            align-items: center;
            flex-wrap: wrap;
        }
        
        .stat-val {
            color: var(--text-100);
            font-weight: 650;
            font-family: var(--font-mono);
            font-size: 13px;
            letter-spacing: -0.02em;
        }
        
        .stat-muted {
            color: var(--text-500);
            margin-left: 4px;
            font-weight: 500;
        }
        
        .stat-pill {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 14px;
            border-radius: 999px;
            background: linear-gradient(165deg, var(--void-600) 0%, var(--void-700) 100%);
            border: 1px solid var(--border-2);
            color: var(--text-200);
            font-size: 12px;
            font-weight: 500;
            letter-spacing: 0.01em;
            box-shadow: 
                inset 0 1px 0 rgba(255,255,255,0.04), 
                0 2px 6px rgba(0,0,0,0.2);
            transition: all 0.25s var(--ease-spring);
            cursor: default;
        }
        
        .stat-pill:hover {
            background: linear-gradient(165deg, var(--void-500) 0%, var(--void-600) 100%);
            border-color: var(--border-3);
            transform: translateY(-2px);
            box-shadow: 
                inset 0 1px 0 rgba(255,255,255,0.06), 
                0 6px 16px rgba(0,0,0,0.3);
        }
        
        .stat-dot {
            width: 7px;
            height: 7px;
            border-radius: 50%;
            background: var(--gold-500);
            box-shadow: 0 0 10px var(--gold-glow);
            animation: stat-pulse 2.5s ease-in-out infinite;
        }
        
        @keyframes stat-pulse {
            0%, 100% { 
                box-shadow: 0 0 10px var(--gold-glow);
                transform: scale(1);
            }
            50% { 
                box-shadow: 0 0 20px var(--gold-glow), 0 0 6px rgba(240, 200, 96, 0.9);
                transform: scale(1.2);
            }
        }
        
        /* ═══════════════════════════════════════════════════════════════════════════════
           MAIN CONTENT
           ═══════════════════════════════════════════════════════════════════════════════ */
        .main {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        .main::before {
            content: '';
            position: absolute;
            inset: 0;
            pointer-events: none;
            background-image:
                linear-gradient(rgba(255, 255, 255, 0.02) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.02) 1px, transparent 1px);
            background-size: 32px 32px;
            opacity: 0.25;
            z-index: 0;
        }
        
        /* .view styles moved to VIEW TRANSITIONS section */
        
        canvas {
            width: 100%;
            height: 100%;
        }
        
        #treemap { cursor: pointer; }
        #semantic { cursor: grab; }
        #semantic:active { cursor: grabbing; }
        
        /* ═══════════════════════════════════════════════════════════════════════════════
           LEGEND — Now hidden, categories integrated into sub-nav
           ═══════════════════════════════════════════════════════════════════════════════ */
        .legend {
            display: none; /* Categories now in sub-nav */
        }
        
        .legend-title,
        .legend-item,
        .legend-dot,
        .legend-name,
        .legend-count,
        .legend-lines {
            display: none;
        }
        
        /* ═══════════════════════════════════════════════════════════════════════════════
           SIDE PANEL
           ═══════════════════════════════════════════════════════════════════════════════ */
        .panel {
            position: absolute;
            top: 0;
            right: 0;
            width: 360px;
            height: 100%;
            background: var(--glass-2);
            backdrop-filter: blur(32px);
            border-left: 1px solid var(--border-2);
            z-index: 60;
            transform: translateX(100%);
            transition: transform 0.4s var(--ease-spring), box-shadow 0.4s ease;
            display: flex;
            flex-direction: column;
            box-shadow: -24px 0 60px rgba(0, 0, 0, 0);
        }
        
        .panel.open { 
            transform: translateX(0);
            box-shadow: -24px 0 60px rgba(0, 0, 0, 0.5), -8px 0 20px rgba(0, 0, 0, 0.3);
        }
        
        .panel.open .panel-header,
        .panel.open .panel-content > * {
            animation: panel-slide-in 0.35s var(--ease-out) backwards;
        }
        
        .panel.open .panel-content > *:nth-child(1) { animation-delay: 0.1s; }
        .panel.open .panel-content > *:nth-child(2) { animation-delay: 0.15s; }
        .panel.open .panel-content > *:nth-child(3) { animation-delay: 0.2s; }
        .panel.open .panel-content > *:nth-child(4) { animation-delay: 0.25s; }
        .panel.open .panel-content > *:nth-child(5) { animation-delay: 0.3s; }
        
        @keyframes panel-slide-in {
            from {
                opacity: 0;
                transform: translateX(20px);
            }
        }
        
        .panel-header {
            padding: 24px;
            border-bottom: 1px solid var(--border-1);
            position: relative;
        }
        
        .panel-close {
            position: absolute;
            top: 16px;
            right: 16px;
            width: 32px;
            height: 32px;
            border-radius: 10px;
            background: var(--void-600);
            color: var(--text-400);
            font-size: 18px;
            display: grid;
            place-items: center;
            transition: all 0.2s var(--ease-spring);
            overflow: hidden;
        }
        
        .panel-close:hover { 
            background: var(--void-500); 
            color: var(--text-100);
            transform: scale(1.1);
        }
        
        .panel-close:active {
            transform: scale(0.95);
            background: var(--void-400);
        }
        
        .panel-label {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-500);
            margin-bottom: 8px;
        }
        
        .panel-title {
            font-size: 18px;
            font-weight: 600;
            word-break: break-word;
            line-height: 1.3;
        }
        
        .panel-path {
            font: 12px var(--font-mono);
            color: var(--text-400);
            word-break: break-all;
            margin-top: 6px;
        }
        
        .panel-summary {
            margin-top: 10px;
            padding: 10px 12px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border-1);
            color: var(--text-200);
            font-size: 13px;
            line-height: 1.5;
        }
        
        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
        }
        
        .panel-content::-webkit-scrollbar { width: 10px; }
        .panel-content::-webkit-scrollbar-track { 
            background: transparent;
            margin: 8px 0;
        }
        .panel-content::-webkit-scrollbar-thumb {
            background: var(--void-400);
            border-radius: 10px;
            border: 3px solid transparent;
            background-clip: content-box;
            transition: background 0.2s ease;
        }
        .panel-content::-webkit-scrollbar-thumb:hover {
            background: var(--void-300);
            background-clip: content-box;
        }
        
        /* Global scrollbar styling */
        ::-webkit-scrollbar { width: 10px; height: 10px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb {
            background: var(--void-400);
            border-radius: 10px;
            border: 3px solid transparent;
            background-clip: content-box;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: var(--void-300);
            background-clip: content-box;
        }
        ::-webkit-scrollbar-corner { background: transparent; }
        
        .info-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 24px;
        }
        
        .info-box {
            padding: 14px 16px;
            background: linear-gradient(135deg, var(--void-600) 0%, var(--void-700) 100%);
            border: 1px solid var(--border-1);
            border-radius: 12px;
            transition: all 0.2s var(--ease-out);
            position: relative;
            overflow: hidden;
        }
        
        .info-box::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.05), transparent);
        }
        
        .info-box:hover {
            background: linear-gradient(135deg, var(--void-500) 0%, var(--void-600) 100%);
            border-color: var(--border-2);
            transform: translateY(-2px);
        }
        
        .info-box-label { 
            font-size: 10px; 
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            color: var(--text-500); 
            margin-bottom: 6px;
        }
        
        .info-box-value { 
            font-size: 17px; 
            font-weight: 600;
            font-feature-settings: "tnum" 1;
        }
        
        .section-title {
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-500);
            margin: 24px 0 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border-1);
            position: relative;
        }
        
        .section-title::after {
            content: '';
            position: absolute;
            left: 0;
            bottom: -1px;
            width: 24px;
            height: 2px;
            background: var(--gold-500);
            border-radius: 1px;
        }
        
        .summary {
            font-size: 14px;
            line-height: 1.7;
            color: var(--text-300);
            font-style: italic;
        }
        
        .similar-item {
            display: flex;
            align-items: center;
            gap: 14px;
            padding: 12px 14px;
            background: var(--void-600);
            border: 1px solid var(--border-1);
            border-radius: 12px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.25s var(--ease-spring);
            position: relative;
            overflow: hidden;
        }
        
        .similar-item::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.03) 50%, transparent 100%);
            transform: translateX(-100%);
            transition: transform 0.4s ease;
        }
        
        .similar-item:hover::before {
            transform: translateX(100%);
        }
        
        .similar-item:hover {
            background: var(--void-500);
            border-color: var(--border-2);
            transform: translateX(8px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        .similar-item:active {
            transform: translateX(4px) scale(0.99);
        }
        
        .similar-score {
            width: 40px;
            height: 40px;
            display: grid;
            place-items: center;
            background: linear-gradient(135deg, var(--gold-400), var(--gold-600));
            border-radius: 10px;
            font: 700 13px var(--font-sans);
            color: var(--void-900);
            flex-shrink: 0;
            box-shadow: 0 2px 8px rgba(240, 200, 96, 0.25);
            transition: all 0.2s var(--ease-spring);
        }
        
        .similar-item:hover .similar-score {
            transform: scale(1.1) rotate(-2deg);
            box-shadow: 0 4px 12px rgba(240, 200, 96, 0.4);
        }
        
        .similar-info { flex: 1; min-width: 0; }
        .similar-name { font-size: 13px; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .similar-cat { font-size: 11px; margin-top: 2px; }
        
        /* Panel enrichments */
        .section-count {
            font-size: 10px;
            font-weight: 500;
            color: var(--text-500);
            margin-left: 6px;
        }
        
        .panel-doc {
            font-size: 13px;
            line-height: 1.6;
            color: var(--text-300);
            padding: 12px;
            background: var(--void-600);
            border-radius: 8px;
            border-left: 3px solid var(--gold-500);
        }
        
        .panel-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }
        
        .panel-code {
            background: linear-gradient(135deg, var(--void-600) 0%, var(--void-700) 100%);
            padding: 4px 10px;
            border-radius: 6px;
            font-family: var(--font-mono);
            font-size: 11px;
            font-weight: 500;
            color: var(--gold-400);
            border: 1px solid var(--border-1);
            transition: all 0.15s var(--ease-out);
            cursor: default;
        }
        
        .panel-code:hover {
            background: linear-gradient(135deg, var(--void-500) 0%, var(--void-600) 100%);
            border-color: rgba(240, 200, 96, 0.3);
            transform: translateY(-1px);
        }
        
        .panel-code.panel-class {
            color: #61dafb;
            border: 1px solid rgba(97, 218, 251, 0.2);
            background: linear-gradient(135deg, rgba(97, 218, 251, 0.08) 0%, rgba(97, 218, 251, 0.04) 100%);
        }
        
        .panel-code.panel-class:hover {
            border-color: rgba(97, 218, 251, 0.4);
            box-shadow: 0 0 8px rgba(97, 218, 251, 0.15);
        }
        
        .panel-more {
            font-size: 11px;
            color: var(--text-500);
            font-style: italic;
            padding: 4px 0;
        }
        
        .panel-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }
        
        .panel-tag {
            background: linear-gradient(135deg, var(--void-500), var(--void-600));
            padding: 5px 12px;
            border-radius: 14px;
            font-size: 11px;
            font-weight: 500;
            color: var(--text-300);
            border: 1px solid var(--border-1);
            transition: all 0.2s var(--ease-out);
            cursor: default;
        }
        
        .panel-tag:hover {
            background: linear-gradient(135deg, var(--void-400), var(--void-500));
            color: var(--text-200);
            transform: translateY(-1px);
        }
        
        .panel-badge {
            padding: 4px 10px;
            border-radius: 999px;
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 0.02em;
            border: 1px solid var(--border-1);
            background: rgba(255, 255, 255, 0.04);
            color: var(--text-200);
            transition: all 0.2s var(--ease-out);
        }
        
        .panel-badge:hover {
            background: rgba(255, 255, 255, 0.08);
            transform: scale(1.05);
        }
        
        .panel-deps {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .panel-dep {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            background: linear-gradient(135deg, var(--void-600) 0%, var(--void-700) 100%);
            border: 1px solid var(--border-1);
            border-radius: 10px;
            font-size: 12px;
            transition: all 0.2s var(--ease-spring);
            position: relative;
            overflow: hidden;
        }
        
        .panel-dep::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 0;
            background: linear-gradient(90deg, var(--gold-500), transparent);
            opacity: 0;
            transition: all 0.2s ease;
        }
        
        .panel-dep.clickable {
            cursor: pointer;
        }
        
        .panel-dep.clickable:hover {
            background: linear-gradient(135deg, var(--void-500) 0%, var(--void-600) 100%);
            border-color: var(--border-2);
            transform: translateX(6px);
        }
        
        .panel-dep.clickable:hover::before {
            width: 3px;
            opacity: 1;
        }
        
        .panel-dep.clickable:active {
            transform: translateX(4px) scale(0.99);
        }
        
        .dep-arrow {
            color: var(--text-500);
            font-size: 10px;
            transition: transform 0.2s ease;
        }
        
        .panel-dep.clickable:hover .dep-arrow {
            transform: translateX(2px);
            color: var(--gold-500);
        }
        
        .dep-name {
            flex: 1;
            color: var(--text-200);
            font-family: var(--font-mono);
            font-size: 11px;
            transition: color 0.15s ease;
        }
        
        .panel-dep.clickable:hover .dep-name {
            color: var(--text-100);
        }
        
        .dep-badge {
            padding: 3px 8px;
            border-radius: 6px;
            font-size: 9px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.04em;
            transition: all 0.15s ease;
        }
        
        .panel-dep:hover .dep-badge {
            transform: scale(1.05);
        }
        
        .panel-actions {
            margin-top: 24px;
            padding-top: 16px;
            border-top: 1px solid var(--border-1);
            display: flex;
            gap: 10px;
        }
        
        .panel-btn {
            flex: 1;
            padding: 12px 20px;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            letter-spacing: 0.01em;
            cursor: pointer;
            transition: all 0.2s var(--ease-spring);
            position: relative;
            overflow: hidden;
        }
        
        .panel-btn::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(180deg, rgba(255,255,255,0.15) 0%, transparent 50%);
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        
        .panel-btn:hover::before { opacity: 1; }
        
        .panel-btn:hover { transform: translateY(-2px); }
        
        .panel-btn:active { 
            transform: translateY(0) scale(0.98);
            transition-duration: 0.05s;
        }
        
        .panel-btn-primary {
            background: linear-gradient(135deg, var(--gold-400) 0%, var(--gold-500) 50%, var(--gold-600) 100%);
            color: var(--void-900);
            box-shadow: 0 2px 8px rgba(240, 200, 96, 0.2), inset 0 1px 0 rgba(255,255,255,0.2);
            text-shadow: 0 1px 0 rgba(255,255,255,0.1);
        }
        
        .panel-btn-primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 24px rgba(240, 200, 96, 0.35), 0 4px 12px rgba(240, 200, 96, 0.2), inset 0 1px 0 rgba(255,255,255,0.3);
        }
        
        .panel-btn-secondary {
            background: linear-gradient(135deg, var(--void-500) 0%, var(--void-600) 100%);
            color: var(--text-200);
            border: 1px solid var(--border-2);
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.03);
        }
        
        .panel-btn-secondary:hover {
            background: linear-gradient(135deg, var(--void-400) 0%, var(--void-500) 100%);
            border-color: var(--border-3);
            color: var(--text-100);
        }
        
        .toast {
            position: absolute;
            top: 16px;
            right: 16px;
            padding: 10px 16px;
            border-radius: 12px;
            background: linear-gradient(135deg, rgba(10, 10, 16, 0.95) 0%, rgba(20, 20, 32, 0.95) 100%);
            backdrop-filter: blur(12px);
            border: 1px solid var(--border-2);
            color: var(--text-200);
            font-size: 12px;
            font-weight: 500;
            letter-spacing: 0.02em;
            display: flex;
            gap: 8px;
            align-items: center;
            opacity: 0;
            transform: translateY(-12px) scale(0.9);
            transition: all 0.3s var(--ease-spring);
            z-index: 80;
            pointer-events: none;
            box-shadow: var(--shadow-2), 0 0 0 1px rgba(255,255,255,0.03) inset;
        }
        
        .toast.show {
            opacity: 1;
            transform: translateY(0) scale(1);
        }
        
        .toast::before {
            content: '';
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #4ade80;
            box-shadow: 0 0 8px rgba(74, 222, 128, 0.6);
            animation: toast-pulse 1s ease-in-out infinite;
        }
        
        @keyframes toast-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* ═══════════════════════════════════════════════════════════════════════════════
           CONTROLS — Premium floating dock
           ═══════════════════════════════════════════════════════════════════════════════ */
        .controls {
            position: absolute;
            bottom: 28px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 6px;
            padding: 8px;
            background: linear-gradient(165deg, rgba(10, 10, 18, 0.97) 0%, rgba(14, 14, 24, 0.97) 100%);
            backdrop-filter: blur(40px) saturate(1.4);
            border: 1px solid var(--border-2);
            border-radius: 24px;
            z-index: 50;
            box-shadow: 
                0 16px 48px rgba(0, 0, 0, 0.5),
                0 6px 20px rgba(0, 0, 0, 0.35),
                inset 0 1px 0 rgba(255,255,255,0.05);
            animation: controls-entrance 0.6s var(--ease-spring) backwards;
        }
        
        @keyframes controls-entrance {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(24px) scale(0.95);
            }
        }
        
        .ctrl-btn {
            position: relative;
            width: 48px;
            height: 48px;
            border-radius: 14px;
            font-size: 20px;
            color: var(--text-400);
            display: grid;
            place-items: center;
            transition: all 0.25s var(--ease-spring);
            overflow: hidden;
            background: transparent;
        }
        
        .ctrl-btn::before {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: inherit;
            background: linear-gradient(135deg, rgba(255,255,255,0.08) 0%, rgba(255,255,255,0.02) 100%);
            opacity: 0;
            transition: all 0.25s var(--ease-spring);
        }
        
        .ctrl-btn:hover { 
            color: var(--text-100);
            transform: scale(1.1) translateY(-2px);
        }
        
        .ctrl-btn:hover::before {
            opacity: 1;
        }
        
        .ctrl-btn:active {
            transform: scale(0.92);
            transition-duration: 0.08s;
        }
        
        .ctrl-btn.active { 
            background: linear-gradient(135deg, var(--gold-400) 0%, var(--gold-600) 100%); 
            color: var(--void-900);
            box-shadow: 
                0 4px 16px rgba(240, 200, 96, 0.4),
                inset 0 1px 0 rgba(255,255,255,0.2);
        }
        
        .ctrl-btn.active:hover {
            transform: scale(1.12) translateY(-3px);
            box-shadow: 
                0 8px 24px rgba(240, 200, 96, 0.5),
                inset 0 1px 0 rgba(255,255,255,0.2);
        }
        
        .ctrl-divider {
            width: 1px;
            margin: 8px 4px;
            background: linear-gradient(180deg, transparent, var(--border-3), transparent);
        }
        
        /* Zoom controls — vertical pill */
        .zoom {
            position: absolute;
            bottom: 28px;
            right: 28px;
            display: flex;
            flex-direction: column;
            gap: 0;
            z-index: 50;
            background: linear-gradient(165deg, rgba(10, 10, 18, 0.97) 0%, rgba(14, 14, 24, 0.97) 100%);
            backdrop-filter: blur(40px) saturate(1.4);
            border: 1px solid var(--border-2);
            border-radius: 16px;
            padding: 6px;
            box-shadow: 
                0 12px 36px rgba(0, 0, 0, 0.45),
                inset 0 1px 0 rgba(255,255,255,0.05);
        }
        
        .zoom-btn {
            width: 38px;
            height: 38px;
            background: transparent;
            border: none;
            border-radius: 10px;
            font-size: 18px;
            font-weight: 600;
            color: var(--text-400);
            display: grid;
            place-items: center;
            transition: all 0.25s var(--ease-spring);
            position: relative;
        }
        
        .zoom-btn:first-child {
            border-bottom: 1px solid var(--border-1);
        }
        
        .zoom-btn:hover { 
            background: rgba(255,255,255,0.06);
            color: var(--text-100);
            transform: scale(1.1);
        }
        
        .zoom-btn:active {
            transform: scale(0.9);
            transition-duration: 0.08s;
            background: rgba(240, 200, 96, 0.15);
        }
        
        /* ═══════════════════════════════════════════════════════════════════════════════
           LAYERS PANEL — Premium glassmorphism panel
           ═══════════════════════════════════════════════════════════════════════════════ */
        .layers-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 230px;
            padding: 0;
            background: linear-gradient(165deg, rgba(8, 8, 14, 0.98) 0%, rgba(14, 14, 24, 0.98) 100%);
            backdrop-filter: blur(40px) saturate(1.4);
            border: 1px solid var(--border-2);
            border-radius: 20px;
            z-index: 50;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: 
                0 24px 64px rgba(0, 0, 0, 0.55),
                0 8px 24px rgba(0, 0, 0, 0.35),
                inset 0 1px 0 rgba(255, 255, 255, 0.06);
            animation: layers-entrance 0.5s var(--ease-spring) backwards;
        }
        
        @keyframes layers-entrance {
            from {
                opacity: 0;
                transform: translateX(24px) scale(0.94);
            }
        }
        
        .layers-title {
            font-size: 10px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.14em;
            color: var(--text-300);
            padding: 16px 18px 12px;
            border-bottom: 1px solid var(--border-1);
            display: flex;
            align-items: center;
            gap: 10px;
            background: linear-gradient(180deg, rgba(255,255,255,0.02) 0%, transparent 100%);
        }
        
        .layers-title::before {
            content: '✦';
            color: var(--gold-500);
            font-size: 11px;
            animation: star-pulse 3s ease-in-out infinite;
        }
        
        @keyframes star-pulse {
            0%, 100% { opacity: 0.8; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.15); }
        }
        
        .layer-toggle {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 14px 18px;
            cursor: pointer;
            transition: all 0.25s var(--ease-spring);
            font-size: 13px;
            color: var(--text-400);
            position: relative;
            background: transparent;
            border-bottom: 1px solid rgba(255,255,255,0.02);
        }
        
        .layer-toggle:last-of-type {
            border-bottom: none;
        }
        
        .layer-toggle:hover {
            background: linear-gradient(90deg, rgba(255,255,255,0.04) 0%, transparent 100%);
            color: var(--text-100);
        }
        
        .layer-toggle input[type="checkbox"] {
            display: none;
        }
        
        /* Premium toggle switch — iOS-inspired */
        .layer-switch {
            position: relative;
            width: 44px;
            height: 26px;
            background: linear-gradient(180deg, var(--void-600) 0%, var(--void-500) 100%);
            border-radius: 13px;
            border: 1px solid var(--border-3);
            transition: all 0.35s var(--ease-spring);
            flex-shrink: 0;
            order: 10;
            margin-left: auto;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .layer-switch::after {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 18px;
            height: 18px;
            background: linear-gradient(180deg, var(--text-200) 0%, var(--text-400) 100%);
            border-radius: 50%;
            transition: all 0.35s var(--ease-spring);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4), 0 1px 2px rgba(0,0,0,0.3);
        }
        
        .layer-toggle input:checked ~ .layer-switch {
            background: linear-gradient(135deg, var(--gold-400) 0%, var(--gold-600) 100%);
            border-color: rgba(240, 200, 96, 0.6);
            box-shadow: 
                inset 0 2px 4px rgba(255,255,255,0.2),
                0 0 16px rgba(240, 200, 96, 0.3);
        }
        
        .layer-toggle input:checked ~ .layer-switch::after {
            transform: translateX(18px);
            background: linear-gradient(180deg, #fff 0%, #f0f0f0 100%);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        
        .layer-toggle input:checked + .layer-icon {
            filter: none;
            opacity: 1;
            transform: scale(1.12);
        }
        
        .layer-toggle input:checked ~ span:not(.layer-switch):not(.layer-icon) {
            color: var(--text-100);
            font-weight: 600;
        }
        
        .layer-icon {
            font-size: 18px;
            filter: grayscale(0.7);
            opacity: 0.6;
            transition: all 0.3s var(--ease-spring);
            flex-shrink: 0;
            width: 24px;
            text-align: center;
        }
        
        .layer-toggle:hover .layer-icon {
            transform: scale(1.18);
            opacity: 0.85;
            filter: grayscale(0.3);
        }
        
        .layer-label {
            flex: 1;
            font-weight: 500;
            letter-spacing: 0.02em;
            font-size: 13px;
        }
        
        /* Layer status indicator */
        .layer-toggle::after {
            content: '';
            position: absolute;
            left: 18px;
            top: 50%;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background: var(--text-600);
            transform: translateY(-50%) scale(0);
            transition: all 0.3s var(--ease-spring);
            opacity: 0;
        }
        
        .layer-toggle input:checked ~ .layer-label::after {
            content: '';
        }
        
        /* Layer descriptions on hover — improved tooltip */
        .layer-toggle[title]:hover::before {
            content: attr(title);
            position: absolute;
            right: 100%;
            top: 50%;
            transform: translateY(-50%);
            margin-left: 12px;
            padding: 6px 10px;
            background: var(--void-800);
            border: 1px solid var(--border-2);
            border-radius: 6px;
            font-size: 11px;
            color: var(--text-300);
            white-space: nowrap;
            z-index: 100;
            pointer-events: none;
            animation: tooltip-fade 0.2s var(--ease-out);
        }
        
        @keyframes tooltip-fade {
            from { opacity: 0; transform: translateY(-50%) translateX(-5px); }
        }
        
        /* ═══════════════════════════════════════════════════════════════════════════════
           VIEW TRANSITIONS — Cinematic morphing
           ═══════════════════════════════════════════════════════════════════════════════ */
        .view {
            display: none;
            width: 100%;
            height: 100%;
            position: absolute;
            inset: 0;
            will-change: transform, opacity;
            z-index: 1;
        }
        
        .view.active {
            display: block;
        }
        
        /* Transition states for smooth view switching */
        .view.transitioning-out {
            animation: view-fade-out 0.5s var(--ease-out) forwards;
        }
        
        .view.transitioning-in {
            animation: view-fade-in 0.5s var(--ease-out) forwards;
        }
        
        @keyframes view-fade-out {
            0% { opacity: 1; transform: scale(1); filter: blur(0); }
            100% { opacity: 0; transform: scale(1.05); filter: blur(8px); }
        }
        
        @keyframes view-fade-in {
            0% { opacity: 0; transform: scale(0.95); filter: blur(8px); }
            100% { opacity: 1; transform: scale(1); filter: blur(0); }
        }
        
        /* ═══════════════════════════════════════════════════════════════════════════════
           ENHANCED FOCUS & SELECTION STATES
           ═══════════════════════════════════════════════════════════════════════════════ */
        
        /* Pulsing selection ring */
        @keyframes selection-pulse {
            0%, 100% {
                box-shadow: 0 0 0 3px rgba(255, 215, 0, 0.4),
                            0 0 20px rgba(255, 215, 0, 0.2);
            }
            50% {
                box-shadow: 0 0 0 5px rgba(255, 215, 0, 0.6),
                            0 0 30px rgba(255, 215, 0, 0.4);
            }
        }
        
        /* Animated focus ring for interactive elements */
        @keyframes focus-glow {
            0%, 100% { 
                box-shadow: 0 0 0 2px var(--void-800), 
                            0 0 0 4px var(--gold-500),
                            0 0 12px var(--gold-glow);
            }
            50% { 
                box-shadow: 0 0 0 2px var(--void-800), 
                            0 0 0 5px var(--gold-400),
                            0 0 20px var(--gold-glow);
            }
        }
        
        /* Scanning line effect for hover states */
        @keyframes scan-line {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        /* Node selection indicator for 3D view */
        .node-selected-indicator {
            position: absolute;
            pointer-events: none;
            border: 2px solid var(--gold-500);
            border-radius: 50%;
            animation: selection-pulse 2s ease-in-out infinite;
        }
        
        /* Hover card enhancement */
        .hover-highlight {
            position: relative;
        }
        
        .hover-highlight::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent 0%, 
                rgba(255, 255, 255, 0.05) 50%, 
                transparent 100%);
            transform: translateX(-100%);
            animation: scan-line 1.5s ease-in-out infinite;
            pointer-events: none;
        }
        
        /* ═══════════════════════════════════════════════════════════════════════════════
           BREADCRUMBS — Old floating version hidden, now in sub-nav
           ═══════════════════════════════════════════════════════════════════════════════ */
        .breadcrumbs {
            display: none; /* Now integrated into sub-nav */
        }
        
        .crumb, .crumb-sep, .crumb-back { display: none; }
        
        /* ═══════════════════════════════════════════════════════════════════════════════
           TOOLTIP — Premium hover cards with spring physics
           ═══════════════════════════════════════════════════════════════════════════════ */
        .tooltip {
            position: fixed;
            max-width: 380px;
            min-width: 280px;
            padding: 0;
            background: linear-gradient(165deg, rgba(8, 8, 16, 0.98) 0%, rgba(14, 14, 26, 0.98) 100%);
            backdrop-filter: blur(40px) saturate(1.4);
            border: 1px solid var(--border-3);
            border-radius: 18px;
            box-shadow: 
                0 32px 80px rgba(0, 0, 0, 0.65),
                0 12px 32px rgba(0, 0, 0, 0.45),
                inset 0 1px 0 rgba(255, 255, 255, 0.07),
                inset 0 0 0 1px rgba(255, 255, 255, 0.04);
            pointer-events: none;
            opacity: 0;
            transform: translateY(14px) scale(0.94);
            transition: all 0.35s var(--ease-spring);
            z-index: 200;
            overflow: hidden;
        }
        
        .tooltip.visible {
            opacity: 1;
            transform: translateY(0) scale(1);
        }
        
        /* Subtle top highlight shimmer */
        .tooltip::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, 
                transparent 0%, 
                rgba(255, 255, 255, 0.12) 25%,
                rgba(255, 255, 255, 0.18) 50%,
                rgba(255, 255, 255, 0.12) 75%,
                transparent 100%);
        }
        
        .tt-header {
            display: flex;
            gap: 14px;
            padding: 16px 18px;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.04) 0%, transparent 100%);
            border-bottom: 1px solid var(--border-1);
        }
        
        .tt-icon {
            width: 40px;
            height: 40px;
            border-radius: 10px;
            display: grid;
            place-items: center;
            font-size: 18px;
            flex-shrink: 0;
        }
        
        .tt-title { flex: 1; min-width: 0; }
        .tt-name { font-size: 14px; font-weight: 600; color: var(--text-100); margin-bottom: 2px; }
        .tt-path { font: 10px var(--font-mono); color: var(--text-500); word-break: break-all; line-height: 1.4; }
        
        .tt-stats {
            display: flex;
            gap: 10px;
            padding: 10px 16px;
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid var(--border-1);
        }
        
        .tt-stat {
            font-size: 11px;
            color: var(--text-400);
        }
        
        .tt-stat strong {
            color: var(--text-100);
            font-weight: 600;
        }
        
        .tt-cat {
            padding: 2px 8px;
            border-radius: 6px;
            font-weight: 500;
        }
        
        .tt-section {
            padding: 8px 16px;
            border-bottom: 1px solid var(--border-1);
        }
        
        .tt-section:last-of-type { border-bottom: none; }
        
        .tt-label {
            display: block;
            font-size: 9px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-500);
            margin-bottom: 6px;
        }
        
        .tt-values {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            font-size: 11px;
        }
        
        .tt-values code {
            background: var(--void-600);
            padding: 2px 6px;
            border-radius: 4px;
            color: var(--gold-400);
            font-family: var(--font-mono);
            font-size: 10px;
        }
        
        .tt-imports span {
            background: var(--void-600);
            padding: 2px 6px;
            border-radius: 4px;
            color: var(--text-300);
            font-size: 10px;
        }
        
        .tt-more {
            color: var(--text-500);
            font-size: 10px;
            font-style: italic;
        }
        
        .tt-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }
        
        .tt-tag {
            background: linear-gradient(135deg, var(--void-500), var(--void-600));
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 10px;
            color: var(--text-300);
            border: 1px solid var(--border-1);
        }
        
        .tt-summary {
            padding: 10px 16px;
            font-size: 12px;
            line-height: 1.5;
            color: var(--text-200);
            background: var(--void-600);
            border-bottom: 1px solid var(--border-1);
        }
        
        .tt-quick-stats {
            display: flex;
            gap: 12px;
            padding: 8px 16px;
            background: var(--void-600);
            border-bottom: 1px solid var(--border-1);
        }
        
        .tt-qs {
            font-size: 10px;
            color: var(--text-400);
        }
        
        .tt-qs strong {
            color: var(--text-200);
            font-weight: 600;
        }
        
        .tt-importance {
            position: relative;
            padding-left: 50px !important;
            min-width: 70px;
        }
        
        .tt-imp-bar {
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            height: 4px;
            border-radius: 2px;
            max-width: 40px;
        }
        
        .tt-class {
            background: var(--void-500) !important;
            font-weight: 500;
        }
        
        .tt-cluster {
            padding: 8px 16px;
            font-size: 10px;
            color: var(--text-500);
            background: var(--void-600);
            border-top: 1px solid var(--border-1);
        }
        
        .tt-hint {
            padding: 8px 16px;
            font-size: 9px;
            color: var(--text-600);
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .tt-doc {
            padding: 10px 16px;
            font-size: 11px;
            font-style: italic;
            color: var(--text-400);
            line-height: 1.5;
            background: rgba(0, 0, 0, 0.15);
            border-top: 1px solid var(--border-1);
        }
        
        /* ═══════════════════════════════════════════════════════════════════════════════
           STATE OVERLAY (Loading, Error, Empty, Offline)
           ═══════════════════════════════════════════════════════════════════════════════ */
        .state-overlay {
            position: fixed;
            inset: 0;
            background: var(--void-800);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 24px;
            z-index: 1000;
            transition: opacity 0.5s var(--ease-out), transform 0.5s var(--ease-out);
        }
        
        .state-overlay::before {
            content: '';
            position: absolute;
            inset: 0;
            background: 
                radial-gradient(circle at 30% 30%, rgba(240, 200, 96, 0.03) 0%, transparent 50%),
                radial-gradient(circle at 70% 70%, rgba(100, 140, 230, 0.03) 0%, transparent 50%);
            animation: ambient-shift 8s ease-in-out infinite;
        }
        
        @keyframes ambient-shift {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }
        
        .state-overlay.hide { 
            opacity: 0; 
            pointer-events: none;
            transform: scale(1.02);
        }
        
        .state-icon {
            font-size: 64px;
            line-height: 1;
            margin-bottom: 8px;
            animation: state-icon-float 3s ease-in-out infinite;
        }
        
        @keyframes state-icon-float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-8px); }
        }
        
        .state-title {
            font-size: 22px;
            font-weight: 600;
            color: var(--text-100);
            letter-spacing: -0.01em;
            animation: state-fade-in 0.5s var(--ease-out) 0.1s backwards;
        }
        
        .state-message {
            font-size: 14px;
            color: var(--text-400);
            text-align: center;
            max-width: 360px;
            line-height: 1.6;
            animation: state-fade-in 0.5s var(--ease-out) 0.2s backwards;
        }
        
        @keyframes state-fade-in {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
        }
        
        .state-actions {
            display: flex;
            gap: 12px;
            margin-top: 8px;
            animation: state-fade-in 0.5s var(--ease-out) 0.3s backwards;
        }
        
        .state-btn {
            position: relative;
            padding: 12px 24px;
            border-radius: 10px;
            font-weight: 600;
            font-size: 14px;
            letter-spacing: 0.01em;
            transition: all 0.2s var(--ease-spring);
            overflow: hidden;
        }
        
        .state-btn::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(180deg, rgba(255,255,255,0.15) 0%, transparent 50%);
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        
        .state-btn:hover::before { opacity: 1; }
        
        .state-btn-primary {
            background: linear-gradient(135deg, var(--gold-400), var(--gold-600));
            color: var(--void-900);
            box-shadow: 0 4px 16px rgba(240, 200, 96, 0.25);
        }
        
        .state-btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(240, 200, 96, 0.35);
        }
        
        .state-btn-primary:active {
            transform: translateY(0) scale(0.98);
        }
        
        .state-btn-secondary {
            background: var(--void-500);
            color: var(--text-200);
            border: 1px solid var(--border-2);
        }
        
        .state-btn-secondary:hover {
            background: var(--void-400);
            border-color: var(--border-3);
            transform: translateY(-1px);
        }
        
        /* Enhanced spinner with multiple rings */
        .spinner {
            position: relative;
            width: 56px;
            height: 56px;
        }
        
        .spinner::before,
        .spinner::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 50%;
            border: 3px solid transparent;
        }
        
        .spinner::before {
            border-top-color: var(--gold-500);
            border-right-color: var(--gold-600);
            animation: spin 0.9s linear infinite;
        }
        
        .spinner::after {
            inset: 6px;
            border-bottom-color: var(--gold-400);
            border-left-color: rgba(240, 200, 96, 0.4);
            animation: spin 1.4s linear infinite reverse;
        }
        
        @keyframes spin { to { transform: rotate(360deg); } }
        
        /* Shimmer text effect for loading */
        .state-overlay .state-title::after {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(90deg, 
                transparent 0%, 
                rgba(240, 200, 96, 0.1) 50%, 
                transparent 100%);
            animation: shimmer 2s ease-in-out infinite;
        }
        
        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        /* Offline banner */
        .offline-banner {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 10px 16px;
            background: linear-gradient(135deg, var(--void-600) 0%, var(--void-500) 100%);
            color: var(--text-300);
            text-align: center;
            font-size: 13px;
            font-weight: 500;
            letter-spacing: 0.02em;
            z-index: 1001;
            display: none;
            animation: slideDown 0.4s var(--ease-spring);
            box-shadow: 0 4px 16px rgba(0,0,0,0.3);
        }
        
        .offline-banner.active {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
        }
        
        .offline-banner .banner-icon { 
            font-size: 16px;
            animation: offline-pulse 2s ease-in-out infinite;
        }
        
        @keyframes offline-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* Update banner */
        .update-banner {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            padding: 14px 28px;
            background: linear-gradient(135deg, var(--gold-400) 0%, var(--gold-500) 50%, var(--gold-600) 100%);
            color: var(--void-900);
            font-weight: 600;
            font-size: 14px;
            letter-spacing: 0.01em;
            border-radius: 28px;
            z-index: 1001;
            display: none;
            box-shadow: 0 8px 32px rgba(240, 200, 96, 0.35), inset 0 1px 0 rgba(255,255,255,0.2);
            animation: slideUp 0.5s var(--ease-spring);
            cursor: pointer;
            transition: all 0.2s var(--ease-spring);
        }
        
        .update-banner.active { display: flex; align-items: center; gap: 10px; }
        
        .update-banner:hover { 
            transform: translateX(-50%) translateY(-3px);
            box-shadow: 0 12px 40px rgba(240, 200, 96, 0.45), inset 0 1px 0 rgba(255,255,255,0.3);
        }
        
        .update-banner:active {
            transform: translateX(-50%) translateY(-1px) scale(0.98);
        }
        
        @keyframes slideDown {
            from { transform: translateY(-100%); }
            to { transform: translateY(0); }
        }
        
        @keyframes slideUp {
            from { transform: translateX(-50%) translateY(100%); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }
        
        /* ═══════════════════════════════════════════════════════════════════════════════
           RESPONSIVE
           ═══════════════════════════════════════════════════════════════════════════════ */
        @media (max-width: 1024px) {
            .header { gap: 16px; padding: 0 16px; }
            .stats { display: none; }
            .panel { width: 320px; }
        }
        
        @media (max-width: 768px) {
            .header { height: 48px; }
            .logo span:not(.logo-icon) { display: none; }
            .tabs { display: none; }
            .panel { width: 100%; }
            .legend { width: 150px; padding: 12px; }
        }
        
        /* ═══════════════════════════════════════════════════════════════════════════════
           ACCESSIBILITY
           ═══════════════════════════════════════════════════════════════════════════════ */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                transition-duration: 0.01ms !important;
            }
        }
        
        :focus-visible {
            outline: none;
            box-shadow: 0 0 0 2px var(--void-800), 0 0 0 4px var(--gold-500);
            border-radius: inherit;
        }
        
        /* Animated focus ring */
        @keyframes focus-ring-pulse {
            0%, 100% { box-shadow: 0 0 0 2px var(--void-800), 0 0 0 4px var(--gold-500); }
            50% { box-shadow: 0 0 0 2px var(--void-800), 0 0 0 5px var(--gold-500), 0 0 12px var(--gold-glow); }
        }
        
        button:focus-visible,
        input:focus-visible,
        .tab:focus-visible,
        .crumb:focus-visible {
            animation: focus-ring-pulse 1.5s ease-in-out infinite;
        }
        
        /* Skip link for keyboard users */
        .skip-link {
            position: absolute;
            top: -100px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            background: var(--gold-500);
            color: var(--void-900);
            font-weight: 600;
            border-radius: 0 0 12px 12px;
            z-index: 10000;
            transition: top 0.2s ease;
        }
        
        .skip-link:focus {
            top: 0;
        }
    </style>
</head>
<body>
    <!-- Skip to main content for accessibility -->
    <a href="#treemap" class="skip-link">Skip to visualization</a>
    
    <!-- State Overlay -->
    <div class="state-overlay" id="state-overlay">
        <div class="spinner"></div>
        <div class="state-title" id="state-title">Loading...</div>
        <div class="state-message" id="state-message"></div>
        <div class="state-actions" id="state-actions"></div>
    </div>
    
    <!-- Offline Banner -->
    <div class="offline-banner" id="offline-banner">
        <span class="banner-icon">⚡</span>
        <span>You're offline — viewing cached data</span>
    </div>
    
    <!-- Update Banner -->
    <div class="update-banner" id="update-banner">
        <span>🔄</span>
        <span>New data available — click to refresh</span>
    </div>
    
    <div id="app">
        <header class="header">
            <div class="logo">
                <span class="logo-icon">◈</span>
                <span>Code Galaxy</span>
            </div>
            
            <div class="tabs" style="display: none;">
                <button class="tab active" data-view="treemap">Treemap</button>
                <button class="tab" data-view="semantic">3D Explorer</button>
            </div>
            
            <div class="search">
                <span class="search-icon">⌘K</span>
                <input type="text" id="search" placeholder="Search files, classes, functions..." autocomplete="off" spellcheck="false">
                <button type="button" class="voice-btn" id="voice-btn" title="Voice search (click to speak)">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/>
                        <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
                        <line x1="12" y1="19" x2="12" y2="23"/>
                        <line x1="8" y1="23" x2="16" y2="23"/>
                    </svg>
                </button>
                <kbd class="search-kbd">/</kbd>
                <div class="search-results" id="search-results"></div>
            </div>
            
            <div class="stats">
                <span class="stat-pill"><span class="stat-dot"></span><span><span class="stat-val" id="file-count">—</span><span class="stat-muted" id="file-total"></span> files</span></span>
                <span class="stat-pill"><span><span class="stat-val" id="line-count">—</span><span class="stat-muted" id="line-total"></span> lines</span></span>
                <span class="stat-pill"><span>Clusters</span><span class="stat-val" id="cluster-count">—</span></span>
                <span class="stat-pill"><span>Updated</span><span class="stat-val" id="generated-at">—</span></span>
            </div>
        </header>
        
        <!-- Sub-navigation: Breadcrumbs + Categories + View Toggle -->
        <nav class="sub-nav" id="sub-nav">
            <div class="nav-breadcrumbs" id="nav-breadcrumbs">
                <button class="nav-back" id="nav-back" title="Go up (Backspace)" style="display: none;">←</button>
                <span class="nav-crumb current" data-idx="0">root</span>
            </div>
            <div class="nav-divider"></div>
            <div class="nav-categories" id="nav-categories">
                <!-- Categories rendered by JS -->
            </div>
            <div class="view-toggle" id="view-toggle">
                <button class="view-btn active" data-view="treemap" title="Treemap View">🗺️ Map</button>
                <button class="view-btn" data-view="semantic" title="3D Explorer">🌐 3D</button>
            </div>
        </nav>
        
        <main class="main">
            <div class="view active" id="treemap-view">
                <canvas id="treemap"></canvas>
                <div class="breadcrumbs" id="breadcrumbs">
                    <span class="crumb current" data-idx="0">root</span>
                </div>
            </div>
            
            <div class="view" id="semantic-view">
                <canvas id="semantic"></canvas>
            </div>
            
            <aside class="legend" id="legend"></aside>
            
            <aside class="panel" id="panel">
                <div class="panel-header">
                    <button class="panel-close" id="panel-close">×</button>
                    <div class="panel-label">File Details</div>
                    <div class="panel-title" id="panel-title">—</div>
                    <div class="panel-path" id="panel-path">—</div>
                </div>
                <div class="panel-content" id="panel-content"></div>
            </aside>
            
            <nav class="controls" id="controls" style="display: none;">
                <button class="ctrl-btn active" data-preset="orbit" title="Orbit">🌐</button>
                <button class="ctrl-btn" data-preset="top" title="Top View">⬇</button>
                <button class="ctrl-btn" data-preset="front" title="Front View">➡</button>
                <div class="ctrl-divider"></div>
                <button class="ctrl-btn" data-action="reset" title="Reset">↺</button>
                <button class="ctrl-btn" data-action="auto" title="Auto Rotate">▶</button>
            </nav>
            
            <!-- Layers Panel for 3D View — Premium toggles -->
            <div class="layers-panel" id="layers-panel" style="display: none;">
                <div class="layers-title">Visualization Layers</div>
                <label class="layer-toggle" title="Show import connections">
                    <input type="checkbox" data-layer="imports" checked>
                    <span class="layer-icon">🔗</span>
                    <span class="layer-label">Imports</span>
                    <span class="layer-switch"></span>
                </label>
                <label class="layer-toggle" title="Show cluster boundaries">
                    <input type="checkbox" data-layer="clusters">
                    <span class="layer-icon">◎</span>
                    <span class="layer-label">Clusters</span>
                    <span class="layer-switch"></span>
                </label>
                <label class="layer-toggle" title="Color by importance">
                    <input type="checkbox" data-layer="heat">
                    <span class="layer-icon">🔥</span>
                    <span class="layer-label">Heat Map</span>
                    <span class="layer-switch"></span>
                </label>
                <label class="layer-toggle" title="Show file labels">
                    <input type="checkbox" data-layer="labels" checked>
                    <span class="layer-icon">🏷️</span>
                    <span class="layer-label">Labels</span>
                    <span class="layer-switch"></span>
                </label>
                <label class="layer-toggle" title="Focus on selected cluster">
                    <input type="checkbox" data-layer="focus">
                    <span class="layer-icon">🎯</span>
                    <span class="layer-label">Focus Mode</span>
                    <span class="layer-switch"></span>
                </label>
            </div>
            
            <div class="zoom" id="zoom" style="display: none;">
                <button class="zoom-btn" data-dir="in">+</button>
                <button class="zoom-btn" data-dir="out">−</button>
            </div>
        </main>
        
        <div class="tooltip" id="tooltip"></div>
        <div class="toast" id="toast">✓ Copied</div>
    </div>
    
    <script>
        // ═══════════════════════════════════════════════════════════════════════════════
        // CONFIGURATION — All tunable values in one place
        // ═══════════════════════════════════════════════════════════════════════════════
        
        const CONFIG = {
            // 3D Rendering
            render: {
                initialRotX: 0.4,
                initialRotY: 0,
                rotationSensitivity: 0.006,
                rotationClamp: Math.PI * 0.48,
                zoomMin: 0.3,
                zoomMax: 4,
                zoomStep: 1.25,
                autoRotateSpeed: 0.003,
                nodeBaseSize: 3,
                nodeSizeScale: 0.15,
                importanceScale: 8,
                depthScaleMin: 0.5,
                depthScaleMax: 0.8,
                hitRadiusMin: 12,
                hitRadiusScale: 1.5,
                fov: 1.2,
                cameraZ: 2.0,
                scaleMultiplier: 0.85,
                dprCap: 1.75,
                maxNodesHigh: 2200,
                maxNodesMed: 1400,
                maxNodesLow: 800,
                maxLabelsHigh: 24,
                maxLabelsMed: 16,
                maxLabelsLow: 10,
                starCount: 220,
                fogStrength: 0.28,
            },
            
            // UI Timing
            ui: {
                maxLegendItems: 12,
                tooltipDelay: 800,
                searchDebounce: 100,
                searchMinLength: 2,
                searchMaxResults: 50,
                maxSimilarFiles: 8,
                panelSimilarFiles: 6,
                durationFast: 150,
                durationNormal: 233,
                durationSlow: 377,
            },
            
            // Treemap
            treemap: {
                padding: 4,
                cellGap: 2,
                minCellSize: 2,
                cornerRadius: 8,
                folderAlphaBase: 0.55,
                folderAlphaEnd: 0.45,
                fileAlphaBase: 0.85,
                fileAlphaEnd: 0.75,
            },
            
            // Similarity scoring
            similarity: {
                distanceScale: 1.2,
                clusterBoost: 0.2,
                categoryBoost: 0.1,
                minScore: 0.15,
            },
            
            // PWA
            pwa: {
                cacheVersion: 'v7.1.0',
                storageKey: 'code-galaxy-state',
            },
        };
        
        // UI State Machine
        const UI_STATE = {
            LOADING: 'loading',
            ERROR: 'error',
            EMPTY: 'empty',
            OFFLINE: 'offline',
            READY: 'ready',
        };
        
        // State configuration
        const STATE_CONFIG = {
            [UI_STATE.LOADING]: {
                icon: '',
                title: 'Loading...',
                message: 'Analyzing codebase structure',
                showSpinner: true,
                actions: [],
            },
            [UI_STATE.ERROR]: {
                icon: '⚠️',
                title: 'Unable to Load',
                message: 'Failed to load codebase data',
                showSpinner: false,
                actions: [
                    { label: 'Try Again', action: 'retry', primary: true },
                    { label: 'Use Cached', action: 'cache', primary: false },
                ],
            },
            [UI_STATE.EMPTY]: {
                icon: '📭',
                title: 'No Data Found',
                message: 'Run the analyzer to generate codebase data',
                showSpinner: false,
                actions: [
                    { label: 'Refresh', action: 'retry', primary: true },
                ],
            },
            [UI_STATE.OFFLINE]: {
                icon: '📡',
                title: 'You\'re Offline',
                message: 'Viewing cached data. Some features may be limited.',
                showSpinner: false,
                actions: [
                    { label: 'Continue Offline', action: 'continue', primary: true },
                ],
            },
            [UI_STATE.READY]: {
                hide: true,
            },
        };
        
        let retryCount = 0;
        const MAX_RETRIES = 3;
        
        function setUIState(newState, context = {}) {
            state.uiState = newState;
            renderUIState(newState, context);
        }
        
        function renderUIState(uiState, context = {}) {
            const overlay = document.getElementById('state-overlay');
            const config = STATE_CONFIG[uiState];
            
            if (!config || config.hide) {
                overlay.classList.add('hide');
                return;
            }
            
            overlay.classList.remove('hide');
            
            // Update content
            const spinner = overlay.querySelector('.spinner');
            const title = document.getElementById('state-title');
            const message = document.getElementById('state-message');
            const actions = document.getElementById('state-actions');
            
            if (spinner) spinner.style.display = config.showSpinner ? 'block' : 'none';
            if (title) title.textContent = context.title || config.title;
            if (message) message.textContent = context.message || config.message;
            
            // Render actions
            if (actions && config.actions) {
                actions.innerHTML = config.actions.map(a => `
                    <button class="state-btn ${a.primary ? 'state-btn-primary' : 'state-btn-secondary'}" 
                            data-action="${a.action}">${a.label}</button>
                `).join('');
                
                actions.querySelectorAll('button').forEach(btn => {
                    btn.addEventListener('click', () => handleStateAction(btn.dataset.action));
                });
            }
        }
        
        function handleStateAction(action) {
            switch (action) {
                case 'retry':
                    retryCount++;
                    if (retryCount <= MAX_RETRIES) {
                        init();
                    } else {
                        setUIState(UI_STATE.ERROR, { 
                            title: 'Multiple Failures',
                            message: 'Please check your connection and try again later.'
                        });
                    }
                    break;
                case 'cache':
                    loadFromCache();
                    break;
                case 'continue':
                    setUIState(UI_STATE.READY);
                    break;
            }
        }
        
        async function loadFromCache() {
            try {
                const cache = await caches.open(CONFIG.pwa.cacheVersion + '-data');
                const cached = await cache.match('./codebase-analysis.json');
                if (cached) {
                    const data = await cached.json();
                    processData(data);
                } else {
                    setUIState(UI_STATE.ERROR, { message: 'No cached data available' });
                }
            } catch (err) {
                setUIState(UI_STATE.ERROR, { message: 'Cache read failed: ' + err.message });
            }
        }
        
        // ═══════════════════════════════════════════════════════════════════════════════
        // CATEGORY COLORS — Professional palette with official language colors & gradients
        // ═══════════════════════════════════════════════════════════════════════════════
        
        const COLORS = {
            // High-contrast palette optimized for dark backgrounds
            // Each color has: base hex, light variant, dark variant, and glow
            Python:     { h: 210, s: 70, l: 55, hex: '#3B82F6', light: '#60A5FA', dark: '#2563EB', glow: 'rgba(59, 130, 246, 0.6)' },
            JavaScript: { h: 48,  s: 96, l: 53, hex: '#FACC15', light: '#FDE047', dark: '#EAB308', glow: 'rgba(250, 204, 21, 0.6)' },
            TypeScript: { h: 217, s: 91, l: 60, hex: '#3B82F6', light: '#60A5FA', dark: '#1D4ED8', glow: 'rgba(59, 130, 246, 0.6)' },
            React:      { h: 192, s: 95, l: 62, hex: '#22D3EE', light: '#67E8F9', dark: '#06B6D4', glow: 'rgba(34, 211, 238, 0.6)' },
            Rust:       { h: 24,  s: 85, l: 58, hex: '#F97316', light: '#FB923C', dark: '#EA580C', glow: 'rgba(249, 115, 22, 0.6)' },
            Swift:      { h: 15,  s: 90, l: 55, hex: '#EF4444', light: '#F87171', dark: '#DC2626', glow: 'rgba(239, 68, 68, 0.6)' },
            Kotlin:     { h: 270, s: 85, l: 62, hex: '#A855F7', light: '#C084FC', dark: '#9333EA', glow: 'rgba(168, 85, 247, 0.6)' },
            Go:         { h: 186, s: 90, l: 50, hex: '#06B6D4', light: '#22D3EE', dark: '#0891B2', glow: 'rgba(6, 182, 212, 0.6)' },
            Java:       { h: 30,  s: 95, l: 55, hex: '#F59E0B', light: '#FBBF24', dark: '#D97706', glow: 'rgba(245, 158, 11, 0.6)' },
            C:          { h: 215, s: 45, l: 55, hex: '#64748B', light: '#94A3B8', dark: '#475569', glow: 'rgba(100, 116, 139, 0.5)' },
            'C++':      { h: 220, s: 55, l: 50, hex: '#6366F1', light: '#818CF8', dark: '#4F46E5', glow: 'rgba(99, 102, 241, 0.6)' },
            Config:     { h: 215, s: 25, l: 50, hex: '#64748B', light: '#94A3B8', dark: '#475569', glow: 'rgba(100, 116, 139, 0.4)' },
            Docs:       { h: 142, s: 72, l: 50, hex: '#22C55E', light: '#4ADE80', dark: '#16A34A', glow: 'rgba(34, 197, 94, 0.6)' },
            Test:       { h: 330, s: 82, l: 62, hex: '#EC4899', light: '#F472B6', dark: '#DB2777', glow: 'rgba(236, 72, 153, 0.6)' },
            API:        { h: 260, s: 80, l: 60, hex: '#8B5CF6', light: '#A78BFA', dark: '#7C3AED', glow: 'rgba(139, 92, 246, 0.6)' },
            Core:       { h: 200, s: 85, l: 55, hex: '#0EA5E9', light: '#38BDF8', dark: '#0284C7', glow: 'rgba(14, 165, 233, 0.6)' },
            Security:   { h: 0,   s: 80, l: 55, hex: '#EF4444', light: '#F87171', dark: '#DC2626', glow: 'rgba(239, 68, 68, 0.6)' },
            Shell:      { h: 150, s: 70, l: 45, hex: '#10B981', light: '#34D399', dark: '#059669', glow: 'rgba(16, 185, 129, 0.6)' },
            Web:        { h: 280, s: 75, l: 58, hex: '#A855F7', light: '#C084FC', dark: '#9333EA', glow: 'rgba(168, 85, 247, 0.6)' },
            Style:      { h: 340, s: 85, l: 55, hex: '#F43F5E', light: '#FB7185', dark: '#E11D48', glow: 'rgba(244, 63, 94, 0.6)' },
            Database:   { h: 40,  s: 92, l: 52, hex: '#F59E0B', light: '#FBBF24', dark: '#D97706', glow: 'rgba(245, 158, 11, 0.6)' },
            Model:      { h: 165, s: 75, l: 45, hex: '#14B8A6', light: '#2DD4BF', dark: '#0D9488', glow: 'rgba(20, 184, 166, 0.6)' },
            Service:    { h: 240, s: 75, l: 60, hex: '#6366F1', light: '#818CF8', dark: '#4F46E5', glow: 'rgba(99, 102, 241, 0.6)' },
            Utility:    { h: 175, s: 80, l: 48, hex: '#14B8A6', light: '#2DD4BF', dark: '#0D9488', glow: 'rgba(20, 184, 166, 0.6)' },
            Vue:        { h: 152, s: 72, l: 50, hex: '#42B883', light: '#5ED49E', dark: '#349268', glow: 'rgba(66, 184, 131, 0.6)' },
            Svelte:     { h: 12,  s: 85, l: 55, hex: '#FF3E00', light: '#FF6B35', dark: '#D63500', glow: 'rgba(255, 62, 0, 0.6)' },
            Ruby:       { h: 0,   s: 70, l: 50, hex: '#CC342D', light: '#E05A4F', dark: '#A32920', glow: 'rgba(204, 52, 45, 0.6)' },
            PHP:        { h: 240, s: 50, l: 55, hex: '#777BB4', light: '#9498CC', dark: '#5A5E96', glow: 'rgba(119, 123, 180, 0.5)' },
            Other:      { h: 220, s: 15, l: 55, hex: '#6B7280', light: '#9CA3AF', dark: '#4B5563', glow: 'rgba(107, 114, 128, 0.4)' },
            Folder:     { h: 35,  s: 50, l: 45, hex: '#B45309', light: '#D97706', dark: '#92400E', glow: 'rgba(180, 83, 9, 0.5)' },
        };
        
        function getColor(cat, alpha = 1) {
            const c = COLORS[cat] || COLORS.Other;
            if (alpha === 1) return c.hex;
            // Extract RGB from hex for alpha support
            const r = parseInt(c.hex.slice(1, 3), 16);
            const g = parseInt(c.hex.slice(3, 5), 16);
            const b = parseInt(c.hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        
        function getHSL(cat) {
            return COLORS[cat] || COLORS.Other;
        }
        
        function getGradient(ctx, cat, x, y, w, h, isFolder = false) {
            const c = COLORS[cat] || COLORS.Other;
            const grad = ctx.createLinearGradient(x, y, x + w * 0.7, y + h);
            if (isFolder) {
                grad.addColorStop(0, c.light + 'CC');
                grad.addColorStop(0.5, c.hex + 'AA');
                grad.addColorStop(1, c.dark + '99');
            } else {
                grad.addColorStop(0, c.light + 'E8');
                grad.addColorStop(0.4, c.hex + 'DD');
                grad.addColorStop(1, c.dark + 'CC');
            }
            return grad;
        }
        
        // ═══════════════════════════════════════════════════════════════════════════════
        // CLUSTER COLORS — Additive blending for directories based on cluster composition
        // ═══════════════════════════════════════════════════════════════════════════════
        
        // Default cluster color palette (can be overridden by data.clusterColors)
        const DEFAULT_CLUSTER_COLORS = [
            { h: 220, s: 75, l: 55 },  // Blue
            { h: 35,  s: 85, l: 55 },  // Orange
            { h: 160, s: 70, l: 45 },  // Teal
            { h: 280, s: 65, l: 55 },  // Purple
            { h: 45,  s: 90, l: 50 },  // Gold
            { h: 0,   s: 75, l: 55 },  // Red
            { h: 190, s: 80, l: 50 },  // Cyan
            { h: 320, s: 70, l: 55 },  // Magenta
            { h: 90,  s: 65, l: 45 },  // Green
            { h: 15,  s: 80, l: 55 },  // Coral
            { h: 250, s: 70, l: 60 },  // Indigo
            { h: 60,  s: 75, l: 45 },  // Lime
            { h: 340, s: 75, l: 55 },  // Pink
            { h: 175, s: 70, l: 45 },  // Aqua
            { h: 30,  s: 80, l: 50 },  // Amber
            { h: 210, s: 70, l: 50 },  // Steel Blue
            { h: 300, s: 60, l: 50 },  // Violet
            { h: 120, s: 60, l: 40 },  // Forest
        ];
        
        function getClusterColors() {
            return state.data?.clusterColors || DEFAULT_CLUSTER_COLORS;
        }
        
        function getClusterColor(clusterId) {
            const colors = getClusterColors();
            const idx = clusterId % colors.length;
            return colors[idx];
        }
        
        // Blend multiple cluster colors additively based on their weights (lines)
        // Returns {h, s, l} with weighted average of hue (circular), and regular avg for s/l
        function blendClusterColors(clusterComposition) {
            if (!clusterComposition || Object.keys(clusterComposition).length === 0) {
                return { h: 35, s: 50, l: 45 }; // Default folder color
            }
            
            const entries = Object.entries(clusterComposition);
            if (entries.length === 1) {
                return getClusterColor(parseInt(entries[0][0]));
            }
            
            const totalLines = entries.reduce((sum, [_, lines]) => sum + lines, 0);
            if (totalLines === 0) {
                return { h: 35, s: 50, l: 45 };
            }
            
            // Weighted circular average for hue (using sine/cosine to handle wrap-around)
            let sinSum = 0, cosSum = 0, sSum = 0, lSum = 0;
            
            for (const [clusterIdStr, lines] of entries) {
                const clusterId = parseInt(clusterIdStr);
                const color = getClusterColor(clusterId);
                const weight = lines / totalLines;
                
                // Convert hue to radians for circular average
                const hueRad = (color.h * Math.PI) / 180;
                sinSum += Math.sin(hueRad) * weight;
                cosSum += Math.cos(hueRad) * weight;
                
                // Weighted average for saturation and lightness
                sSum += color.s * weight;
                lSum += color.l * weight;
            }
            
            // Convert back from sin/cos to hue
            let avgHue = (Math.atan2(sinSum, cosSum) * 180) / Math.PI;
            if (avgHue < 0) avgHue += 360;
            
            // Boost saturation slightly for more vibrant colors
            const avgSat = Math.min(90, sSum * 1.1);
            const avgLight = Math.max(40, Math.min(60, lSum));
            
            return { h: avgHue, s: avgSat, l: avgLight };
        }
        
        // Create a gradient using blended cluster colors
        function getClusterGradient(ctx, clusterComposition, x, y, w, h) {
            const blended = blendClusterColors(clusterComposition);
            const grad = ctx.createLinearGradient(x, y, x + w * 0.7, y + h);
            
            // Create light, mid, and dark variants with proper hsla() format
            const light = `hsla(${blended.h}, ${blended.s}%, ${Math.min(75, blended.l + 15)}%, 0.8)`;
            const mid = `hsla(${blended.h}, ${blended.s}%, ${blended.l}%, 0.67)`;
            const dark = `hsla(${blended.h}, ${Math.max(30, blended.s - 15)}%, ${Math.max(25, blended.l - 15)}%, 0.6)`;
            
            grad.addColorStop(0, light);
            grad.addColorStop(0.5, mid);
            grad.addColorStop(1, dark);
            
            return { grad, blended };
        }
        
        // ═══════════════════════════════════════════════════════════════════════════════
        // STATE
        // ═══════════════════════════════════════════════════════════════════════════════
        
        const state = {
            uiState: UI_STATE.LOADING,
            view: 'treemap',
            data: null,
            files: [],
            tree: null,
            isOnline: navigator.onLine,
            
            treemap: {
                path: [],
                hovered: null,
                selected: null,
                cells: [],
            },
            
            semantic: {
                rotX: CONFIG.render.initialRotX,
                rotY: CONFIG.render.initialRotY,
                targetRotX: CONFIG.render.initialRotX,
                targetRotY: CONFIG.render.initialRotY,
                zoom: 1.0,
                dragging: false,
                lastX: 0,
                lastY: 0,
                hovered: null,
                selected: null,
                autoRotate: false,
                related: [],
                projected: [],
                quality: 'high',
                frameMsAvg: 0,
                focusClusterId: null,
                layers: {
                    imports: true,
                    clusters: false,
                    heat: false,
                    labels: true,
                    focus: false,
                },
            },
            
            filter: null,
            query: '',
            tooltipTimer: null,
            
            // View transition state
            transition: {
                active: false,
                progress: 0,
                fromView: null,
                toView: null,
                targetFile: null,
                startTime: 0,
                duration: 600,
            },
            
            // Import graph (built from data)
            importGraph: {
                imports: {},      // path -> [imported paths]
                importedBy: {},   // path -> [files that import this]
            },
            
            // Derived stats (live-updating)
            stats: {
                totalFiles: 0,
                visibleFiles: 0,
                totalLines: 0,
                visibleLines: 0,
                categories: {},
            },
        };
        
        // Global debug access
        window.DEBUG_STATE = state;
        
        let treemapCanvas, treemapCtx;
        let semanticCanvas, semanticCtx;
        let dpr = 1;
        let rafId = null;
        
        // ═══════════════════════════════════════════════════════════════════════════════
        // LOCAL STORAGE PERSISTENCE
        // ═══════════════════════════════════════════════════════════════════════════════
        
        const saveStateDebounced = debounce(saveState, 500);
        
        function saveState() {
            try {
                const persist = {
                    version: 1,
                    savedAt: Date.now(),
                    repoId: state.data?.meta?.name || state.data?.meta?.root || 'unknown',
                    view: state.view,
                    filter: state.filter,
                    treemapPath: state.treemap.path,
                    semantic: {
                        rotX: state.semantic.rotX,
                        rotY: state.semantic.rotY,
                        zoom: state.semantic.zoom,
                        autoRotate: state.semantic.autoRotate,
                    },
                };
                localStorage.setItem(CONFIG.pwa.storageKey, JSON.stringify(persist));
            } catch (err) {
                console.warn('Failed to save state:', err);
            }
        }
        
        function loadState() {
            try {
                const saved = localStorage.getItem(CONFIG.pwa.storageKey);
                if (!saved) return false;
                
                const persist = JSON.parse(saved);
                
                // Check if same repo
                const currentRepoId = state.data?.meta?.name || state.data?.meta?.root || 'unknown';
                if (persist.repoId !== currentRepoId) {
                    console.log('Different repo, skipping state restore');
                    return false;
                }
                
                // Restore state
                if (persist.view) state.view = persist.view;
                if (persist.filter !== undefined) state.filter = persist.filter;
                if (Array.isArray(persist.treemapPath)) state.treemap.path = persist.treemapPath;
                if (persist.semantic) {
                    if (typeof persist.semantic.rotX === 'number') state.semantic.rotX = persist.semantic.rotX;
                    if (typeof persist.semantic.rotY === 'number') state.semantic.rotY = persist.semantic.rotY;
                    if (typeof persist.semantic.zoom === 'number') state.semantic.zoom = persist.semantic.zoom;
                    if (typeof persist.semantic.autoRotate === 'boolean') state.semantic.autoRotate = persist.semantic.autoRotate;
                }
                
                return true;
            } catch (err) {
                console.warn('Failed to load state:', err);
                return false;
            }
        }
        
        function clearSavedState() {
            localStorage.removeItem(CONFIG.pwa.storageKey);
        }
        
        // ═══════════════════════════════════════════════════════════════════════════════
        // INITIALIZATION
        // ═══════════════════════════════════════════════════════════════════════════════
        
        async function init() {
            setUIState(UI_STATE.LOADING);
            
            try {
                // Check online status first
                if (!navigator.onLine) {
                    state.isOnline = false;
                    document.getElementById('offline-banner').classList.add('active');
                    // Try to load from cache
                    await loadFromCache();
                    return;
                }
                
                const res = await fetch('codebase-analysis.json?v=' + Date.now());
                if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                
                const data = await res.json();
                processData(data);
                
            } catch (err) {
                console.error('Init error:', err);
                setUIState(UI_STATE.ERROR, { 
                    title: 'Failed to Load',
                    message: err.message || 'Network error. Check your connection.'
                });
            }
        }
        
        function processData(data) {
            if (!data || !data.files || data.files.length === 0) {
                setUIState(UI_STATE.EMPTY, {
                    message: 'No files found. Run the analyzer to generate data.'
                });
                return;
            }
            
            state.data = data;
            state.files = data.files || [];
            
            // Build import graph (imports -> importedBy reverse index)
            buildImportGraph();
            
            // Use pre-built tree if available, otherwise build it
            if (data.tree) {
                state.tree = data.tree;
            } else {
                buildTree();
            }
            
            // Restore saved state (after data is set so repoId comparison works)
            const restored = loadState();
            
            // Update page metadata from data
            updateMetadata();
            
            // Initialize canvas elements
            treemapCanvas = document.getElementById('treemap');
            semanticCanvas = document.getElementById('semantic');
            treemapCtx = treemapCanvas.getContext('2d');
            semanticCtx = semanticCanvas.getContext('2d');
            
            resize();
            setupEvents();
            updateStats();
            buildLegend();
            
            // Apply restored state to UI
            if (restored) {
                const is3D = state.view === 'semantic';
                
                // Update view tabs (old hidden tabs)
                document.querySelectorAll('.tab').forEach(t => {
                    t.classList.toggle('active', t.dataset.view === state.view);
                });
                
                // Update view toggle buttons (new sub-nav)
                document.querySelectorAll('.view-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.view === state.view);
                });
                
                // Show/hide correct view
                document.getElementById('treemap-view').classList.toggle('active', state.view === 'treemap');
                document.getElementById('semantic-view').classList.toggle('active', state.view === 'semantic');
                document.getElementById('controls').style.display = is3D ? 'flex' : 'none';
                document.getElementById('zoom').style.display = is3D ? 'flex' : 'none';
                document.getElementById('breadcrumbs').style.display = is3D ? 'none' : 'flex';
                
                // Update layers panel visibility
                const layersPanel = document.getElementById('layers-panel');
                if (layersPanel) layersPanel.style.display = is3D ? 'flex' : 'none';
                
                // Update nav-breadcrumbs styling
                const navBreadcrumbs = document.getElementById('nav-breadcrumbs');
                if (navBreadcrumbs) {
                    navBreadcrumbs.style.opacity = is3D ? '0.5' : '1';
                    navBreadcrumbs.style.pointerEvents = is3D ? 'none' : 'auto';
                }
                
                // Update breadcrumbs
                updateBreadcrumbs();
            }
            setupOnlineListeners();
            
            // Success!
            setUIState(UI_STATE.READY);
            retryCount = 0;
            render();
        }
        
        function updateMetadata() {
            const meta = state.data?.meta || {};
            const title = meta.title || meta.name || 'Code Galaxy';
            
            document.title = title;
            const logoText = document.querySelector('.logo span:last-child');
            if (logoText) logoText.textContent = title;
            
            // Update theme color if specified
            const themeColor = document.querySelector('meta[name="theme-color"]');
            if (themeColor && meta.themeColor) {
                themeColor.setAttribute('content', meta.themeColor);
            }
            
            const generatedAt = document.getElementById('generated-at');
            if (generatedAt && meta.generated) {
                generatedAt.textContent = formatRelativeTime(meta.generated);
            }
        }
        
        function setupOnlineListeners() {
            window.addEventListener('online', () => {
                state.isOnline = true;
                document.getElementById('offline-banner').classList.remove('active');
                // Optionally refresh data
            });
            
            window.addEventListener('offline', () => {
                state.isOnline = false;
                document.getElementById('offline-banner').classList.add('active');
            });
            
            // Listen for SW updates
            if (navigator.serviceWorker) {
                navigator.serviceWorker.addEventListener('message', e => {
                    if (e.data?.type === 'DATA_UPDATED') {
                        document.getElementById('update-banner').classList.add('active');
                    }
                });
                
                document.getElementById('update-banner').addEventListener('click', () => {
                    location.reload();
                });
            }
        }
        
        function buildImportGraph() {
            // Build forward and reverse import relationships
            state.importGraph = { imports: {}, importedBy: {} };
            
            // Create a lookup for resolving imports
            const filesByName = new Map();
            const filesByPath = new Map();
            
            for (const f of state.files) {
                if (f.path) filesByPath.set(f.path, f);
                if (f.name) {
                    const name = f.name.replace(/\.(py|js|ts|tsx|jsx|rs|swift|kt)$/, '');
                    if (!filesByName.has(name)) filesByName.set(name, []);
                    filesByName.get(name).push(f);
                }
            }
            
            // Build import graph
            for (const f of state.files) {
                const imports = f.imports || [];
                state.importGraph.imports[f.path] = imports;
                
                for (const imp of imports) {
                    // Try to resolve the import to an actual file
                    let targetPath = null;
                    
                    // Direct path match
                    if (filesByPath.has(imp)) {
                        targetPath = imp;
                    } else {
                        // Try by module name
                        const moduleName = imp.split('/').pop().replace(/\.(py|js|ts|tsx|jsx|rs|swift|kt)$/, '');
                        const candidates = filesByName.get(moduleName) || [];
                        
                        // Find best match (same directory or closest ancestor)
                        if (candidates.length === 1) {
                            targetPath = candidates[0].path;
                        } else if (candidates.length > 1) {
                            // Prefer files in same directory tree
                            const fDir = f.path.split('/').slice(0, -1).join('/');
                            const match = candidates.find(c => c.path.startsWith(fDir + '/')) || candidates[0];
                            targetPath = match.path;
                        }
                    }
                    
                    if (targetPath) {
                        if (!state.importGraph.importedBy[targetPath]) {
                            state.importGraph.importedBy[targetPath] = [];
                        }
                        if (!state.importGraph.importedBy[targetPath].includes(f.path)) {
                            state.importGraph.importedBy[targetPath].push(f.path);
                        }
                    }
                }
            }
        }
        
        function buildTree() {
            const root = { name: 'root', path: '', lines: 0, isFile: false, children: {} };
            
            for (const f of state.files) {
                if (!f.path) continue;
                const parts = f.path.split('/');
                let node = root;
                
                for (let i = 0; i < parts.length - 1; i++) {
                    const part = parts[i];
                    if (!node.children[part]) {
                        node.children[part] = { 
                            name: part, 
                            path: parts.slice(0, i + 1).join('/'),
                            lines: 0, 
                            isFile: false, 
                            children: {} 
                        };
                    }
                    node = node.children[part];
                }
                
                const fileName = parts[parts.length - 1];
                node.children[fileName] = {
                    name: f.name || fileName,
                    path: f.path,
                    lines: f.lines || 0,
                    isFile: true,
                    file: f,
                    category: f.category || 'Other',
                };
            }
            
            // Calculate folder sizes
            function sumLines(n) {
                if (n.isFile) return n.lines;
                let sum = 0;
                for (const c of Object.values(n.children || {})) {
                    sum += sumLines(c);
                }
                n.lines = sum;
                return sum;
            }
            
            sumLines(root);
            state.tree = root;
        }
        
        function resize() {
            dpr = Math.min(window.devicePixelRatio || 1, CONFIG.render.dprCap);
            
            [treemapCanvas, semanticCanvas].forEach(c => {
                if (!c) return;
                const rect = c.parentElement.getBoundingClientRect();
                c.width = rect.width * dpr;
                c.height = rect.height * dpr;
                c.style.width = rect.width + 'px';
                c.style.height = rect.height + 'px';
                c.getContext('2d').setTransform(dpr, 0, 0, dpr, 0, 0);
            });
        }
        
        // ═══════════════════════════════════════════════════════════════════════════════
        // RENDER LOOP
        // ═══════════════════════════════════════════════════════════════════════════════
        
        function render() {
            if (state.view === 'treemap') {
                renderTreemap();
            } else {
                renderSemantic();
            }
            rafId = requestAnimationFrame(render);
        }
        
        // ═══════════════════════════════════════════════════════════════════════════════
        // TREEMAP — Proper Squarify Algorithm
        // ═══════════════════════════════════════════════════════════════════════════════
        
        function renderTreemap() {
            if (!treemapCtx || !state.tree) return;
            
            const w = treemapCanvas.width / dpr;
            const h = treemapCanvas.height / dpr;
            const ctx = treemapCtx;
            
            // Background
            ctx.fillStyle = '#04040a';
            ctx.fillRect(0, 0, w, h);
            
            // Navigate to current path
            let node = state.tree;
            for (const seg of state.treemap.path) {
                if (node.children && node.children[seg]) {
                    node = node.children[seg];
                } else {
                    // Invalid path, reset
                    state.treemap.path = [];
                    node = state.tree;
                    break;
                }
            }
            
            // Get children as array
            const children = Object.values(node.children || {}).filter(c => c.lines > 0);
            if (!children.length) return;
            
            // Fill entire screen - legend floats on top
            const pad = 4;
            state.treemap.cells = squarify(children, pad, pad, w - pad * 2, h - pad * 2);
            
            // Draw cells
            for (const cell of state.treemap.cells) {
                drawTreemapCell(ctx, cell);
            }
        }
        
        // ═══════════════════════════════════════════════════════════════════════════════
        // PROPER SQUARIFY ALGORITHM — Optimal aspect ratios
        // Based on Bruls, Huizing, van Wijk 2000
        // ═══════════════════════════════════════════════════════════════════════════════
        
        function squarify(items, x, y, w, h) {
            if (!items.length || w < 4 || h < 4) return [];
            
            // Sort by value descending for best squarification
            const sorted = [...items].sort((a, b) => b.lines - a.lines);
            const total = sorted.reduce((s, c) => s + c.lines, 0);
            if (total === 0) return [];
            
            // Normalize values to fit area
            const area = w * h;
            const normalizedItems = sorted.map(item => ({
                node: item,
                value: (item.lines / total) * area
            }));
            
            const cells = [];
            squarifyRecursive(normalizedItems, x, y, w, h, cells);
            return cells;
        }
        
        function squarifyRecursive(items, x, y, w, h, cells) {
            if (!items.length) return;
            if (w < 2 || h < 2) return;
            
            const gap = 2; // Gap between cells
            
            // Single item - fill the space
            if (items.length === 1) {
                const item = items[0];
                if (w - gap > 2 && h - gap > 2) {
                    cells.push({ 
                        node: item.node, 
                        x: x, 
                        y: y, 
                        w: Math.max(2, w - gap), 
                        h: Math.max(2, h - gap)
                    });
                }
                return;
            }
            
            // Determine orientation - lay out along shorter edge
            const vertical = h < w;
            const side = vertical ? h : w;
            
            // Find row that gives best aspect ratio
            const row = [];
            let rowArea = 0;
            let remaining = [...items];
            
            while (remaining.length > 0) {
                const item = remaining[0];
                const testRow = [...row, item];
                const testArea = rowArea + item.value;
                
                const currentWorst = row.length > 0 ? worstRatio(row, rowArea, side) : Infinity;
                const testWorst = worstRatio(testRow, testArea, side);
                
                if (testWorst <= currentWorst || row.length === 0) {
                    // Adding this item improves or maintains ratio
                    row.push(item);
                    rowArea = testArea;
                    remaining = remaining.slice(1);
                } else {
                    // Adding would make it worse, layout current row
                    break;
                }
            }
            
            // Layout the row
            layoutRow(row, rowArea, x, y, w, h, vertical, gap, cells);
            
            // Calculate remaining space
            const rowSize = rowArea / side;
            if (vertical) {
                squarifyRecursive(remaining, x + rowSize, y, w - rowSize, h, cells);
            } else {
                squarifyRecursive(remaining, x, y + rowSize, w, h - rowSize, cells);
            }
        }
        
        function worstRatio(row, area, side) {
            if (row.length === 0 || area === 0) return Infinity;
            
            const rowWidth = area / side;
            let worst = 0;
            
            for (const item of row) {
                const itemHeight = item.value / rowWidth;
                const ratio = Math.max(rowWidth / itemHeight, itemHeight / rowWidth);
                worst = Math.max(worst, ratio);
            }
            
            return worst;
        }
        
        function layoutRow(row, area, x, y, w, h, vertical, gap, cells) {
            if (row.length === 0 || area === 0) return;
            
            const side = vertical ? h : w;
            const rowSize = area / side;
            let offset = 0;
            
            for (const item of row) {
                const itemSize = item.value / rowSize;
                
                let cellX, cellY, cellW, cellH;
                if (vertical) {
                    cellX = x;
                    cellY = y + offset;
                    cellW = rowSize - gap;
                    cellH = itemSize - gap;
                } else {
                    cellX = x + offset;
                    cellY = y;
                    cellW = itemSize - gap;
                    cellH = rowSize - gap;
                }
                
                // Only add valid cells
                if (cellW > 2 && cellH > 2 && isFinite(cellW) && isFinite(cellH)) {
                    cells.push({
                        node: item.node,
                        x: cellX,
                        y: cellY,
                        w: Math.max(2, cellW),
                        h: Math.max(2, cellH)
                    });
                }
                
                offset += itemSize;
            }
        }
        
        function drawTreemapCell(ctx, { node, x, y, w, h }) {
            if (w < 2 || h < 2 || !isFinite(w) || !isFinite(h) || !isFinite(x) || !isFinite(y)) return;
            
            const hov = state.treemap.hovered === node;
            const sel = state.treemap.selected === node;
            const isFolder = !node.isFile;
            
            // ═══════════════════════════════════════════════════════════════════════════
            // COLOR SELECTION — Cluster-based for folders, category for files
            // ═══════════════════════════════════════════════════════════════════════════
            
            // Always define cat for use in labels/icons
            const cat = node.category || node.file?.category || (isFolder ? 'Folder' : 'Other');
            let c, fillGradient, blendedColor = null;
            
            if (isFolder && node.clusterComposition && Object.keys(node.clusterComposition).length > 0) {
                // Use additive cluster color blending for folders
                const result = getClusterGradient(ctx, node.clusterComposition, x, y, w, h);
                fillGradient = result.grad;
                blendedColor = result.blended;
                
                // Create a pseudo-color object for glow etc
                c = {
                    h: blendedColor.h,
                    s: blendedColor.s,
                    l: blendedColor.l,
                    hex: `hsl(${blendedColor.h}, ${blendedColor.s}%, ${blendedColor.l}%)`,
                    light: `hsl(${blendedColor.h}, ${blendedColor.s}%, ${Math.min(75, blendedColor.l + 15)}%)`,
                    dark: `hsl(${blendedColor.h}, ${Math.max(30, blendedColor.s - 15)}%, ${Math.max(25, blendedColor.l - 15)}%)`,
                    glow: `hsla(${blendedColor.h}, ${blendedColor.s}%, ${blendedColor.l}%, 0.5)`,
                };
            } else {
                // Use category color for files or folders without cluster data
                c = COLORS[cat] || COLORS.Other;
                fillGradient = getGradient(ctx, cat, x, y, w, h, isFolder);
            }
            
            // Calculate corner radius - larger for bigger cells
            const r = Math.max(4, Math.min(16, Math.min(w, h) / 6));
            
            // ═══════════════════════════════════════════════════════════════════════════
            // GLASSMORPHISM BASE
            // ═══════════════════════════════════════════════════════════════════════════
            
            // Outer glow for depth (subtle)
            if (w > 40 && h > 40) {
                ctx.shadowColor = c.glow;
                ctx.shadowBlur = hov ? 20 : sel ? 28 : 8;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 4;
            }
            
            // Main fill with beautiful gradient
            ctx.beginPath();
            ctx.roundRect(x, y, w, h, r);
            ctx.fillStyle = fillGradient;
            ctx.fill();
            
            // Reset shadow
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;
            
            // Inner highlight (top edge glow for glass effect)
            if (w > 30 && h > 30) {
                const highlightGrad = ctx.createLinearGradient(x, y, x, y + h * 0.3);
                highlightGrad.addColorStop(0, 'rgba(255, 255, 255, 0.25)');
                highlightGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = highlightGrad;
                ctx.beginPath();
                ctx.roundRect(x + 1, y + 1, w - 2, h * 0.4, [r - 1, r - 1, 0, 0]);
                ctx.fill();
            }
            
            // Border with gradient (handle both HSL and hex color formats)
            const borderGrad = ctx.createLinearGradient(x, y, x + w, y + h);
            if (blendedColor) {
                // HSL color from cluster blending
                borderGrad.addColorStop(0, `hsla(${blendedColor.h}, ${blendedColor.s}%, ${Math.min(80, blendedColor.l + 20)}%, 0.4)`);
                borderGrad.addColorStop(0.5, `hsla(${blendedColor.h}, ${blendedColor.s}%, ${blendedColor.l}%, 0.25)`);
                borderGrad.addColorStop(1, `hsla(${blendedColor.h}, ${Math.max(30, blendedColor.s - 15)}%, ${Math.max(30, blendedColor.l - 10)}%, 0.2)`);
            } else {
                // Hex color from category
                borderGrad.addColorStop(0, c.light + '60');
                borderGrad.addColorStop(0.5, c.hex + '40');
                borderGrad.addColorStop(1, c.dark + '30');
            }
            ctx.strokeStyle = borderGrad;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.roundRect(x, y, w, h, r);
            ctx.stroke();
            
            // ═══════════════════════════════════════════════════════════════════════════
            // ENHANCED HOVER / SELECTION EFFECTS — Multi-layer feedback
            // ═══════════════════════════════════════════════════════════════════════════
            
            if (hov || sel) {
                // Animated pulse effect for selection
                const time = performance.now() * 0.003;
                const pulse = sel ? 1 + 0.1 * Math.sin(time * 2) : 1;
                
                // Outer glow ring
                if (sel) {
                    // Double animated border
                    ctx.shadowColor = '#FFD700';
                    ctx.shadowBlur = 20 + 8 * Math.sin(time);
                    ctx.strokeStyle = `rgba(255, 215, 0, ${0.8 + 0.2 * Math.sin(time)})`;
                    ctx.lineWidth = 3;
                    ctx.stroke();
                    
                    // Inner white highlight
                    ctx.shadowBlur = 0;
                    ctx.strokeStyle = `rgba(255, 255, 255, ${0.5 + 0.2 * Math.sin(time + 1)})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.roundRect(x + 2, y + 2, w - 4, h - 4, Math.max(2, r - 2));
                    ctx.stroke();
                    
                } else {
                    // Hover: bright animated border
                    ctx.shadowColor = c.glow;
                    ctx.shadowBlur = 12;
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
                
                // Scanning highlight effect for hover
                if (hov && !sel && w > 60) {
                    const scanPos = ((time * 50) % (w + 60)) - 30;
                    const scanGrad = ctx.createLinearGradient(x + scanPos - 30, y, x + scanPos + 30, y);
                    scanGrad.addColorStop(0, 'transparent');
                    scanGrad.addColorStop(0.5, 'rgba(255, 255, 255, 0.15)');
                    scanGrad.addColorStop(1, 'transparent');
                    ctx.fillStyle = scanGrad;
                    ctx.beginPath();
                    ctx.roundRect(x, y, w, h, r);
                    ctx.fill();
                }
                
                // General hover brightening overlay (stronger for better touch feedback)
                if (hov && !sel) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.12)';
                    ctx.fill();
                    
                    // Add a subtle inner glow for file cells
                    if (!isFolder && w > 30 && h > 30) {
                        const innerGlow = ctx.createRadialGradient(x + w/2, y + h/2, 0, x + w/2, y + h/2, Math.max(w, h) * 0.7);
                        innerGlow.addColorStop(0, 'rgba(255, 255, 255, 0.08)');
                        innerGlow.addColorStop(1, 'transparent');
                        ctx.fillStyle = innerGlow;
                        ctx.fill();
                    }
                }
            }
            
            // ═══════════════════════════════════════════════════════════════════════════
            // TYPOGRAPHY - Better hierarchy
            // ═══════════════════════════════════════════════════════════════════════════
            
            if (w > 60 && h > 28) {
                const isLarge = w > 200 && h > 150;
                const isMedium = w > 120 && h > 80;
                const fontSize = isLarge ? 18 : isMedium ? 14 : 12;
                const fontWeight = isFolder ? 700 : 600;
                
                ctx.font = `${fontWeight} ${fontSize}px "IBM Plex Sans", sans-serif`;
                
                const maxChars = Math.floor((w - 20) / (fontSize * 0.55));
                const icon = isFolder ? '📁 ' : getCategoryIcon(cat) + ' ';
                let label = icon + node.name;
                if (label.length > maxChars) {
                    label = label.slice(0, maxChars - 1) + '…';
                }
                
                const textY = y + (isLarge ? 28 : isMedium ? 22 : 18);
                
                // Text shadow for readability
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillText(label, x + 11, textY + 1);
                
                // Main text
                ctx.fillStyle = '#FFFFFF';
                ctx.fillText(label, x + 10, textY);
                
                // Metadata line (lines count + category badge)
                if (h > 50 && w > 80) {
                    const metaY = textY + (isLarge ? 24 : 18);
                    ctx.font = `500 ${isLarge ? 13 : 11}px "IBM Plex Mono", monospace`;
                    
                    const meta = formatNum(node.lines) + ' lines';
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.fillText(meta, x + 11, metaY + 1);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.75)';
                    ctx.fillText(meta, x + 10, metaY);
                    
                    // Category badge for files
                    if (!isFolder && w > 120 && h > 70) {
                        const badgeText = cat;
                        const badgeX = x + 10;
                        const badgeY = metaY + (isLarge ? 20 : 16);
                        ctx.font = `600 ${isLarge ? 11 : 9}px "IBM Plex Sans", sans-serif`;
                        const badgeW = ctx.measureText(badgeText).width + 10;
                        
                        // Badge background
                        ctx.fillStyle = c.dark + '80';
                        ctx.beginPath();
                        ctx.roundRect(badgeX, badgeY - 10, badgeW, 14, 4);
                        ctx.fill();
                        
                        // Badge text
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillText(badgeText, badgeX + 5, badgeY);
                    }
                }
            } else if (w > 35 && h > 20) {
                // Compact label
                ctx.font = '600 10px "IBM Plex Sans", sans-serif';
                const maxChars = Math.floor((w - 8) / 6);
                let short = node.name.slice(0, maxChars);
                if (node.name.length > maxChars) short += '…';
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.fillText(short, x + 5, y + 14);
                ctx.fillStyle = '#FFFFFF';
                ctx.fillText(short, x + 4, y + 13);
            }
        }
        
        // ═══════════════════════════════════════════════════════════════════════════════
        // 3D SEMANTIC EXPLORER — Immersive Perspective
        // ═══════════════════════════════════════════════════════════════════════════════
        
        function renderSemantic() {
            if (!semanticCtx || !state.files.length) return;
            
            // Auto-resize if canvas has no dimensions
            if (semanticCanvas.width === 0 || semanticCanvas.height === 0) {
                resize();
                if (semanticCanvas.width === 0) return;
            }
            const t0 = performance.now();
            const w = semanticCanvas.width / dpr;
            const h = semanticCanvas.height / dpr;
            const ctx = semanticCtx;
            const cx = w / 2;
            const cy = h / 2;
            const layers = state.semantic.layers;
            const quality = state.semantic.quality;
            const focusCluster = layers.focus && state.semantic.focusClusterId !== null;
            
            if (state.semantic.dragging) {
                state.semantic.rotX = state.semantic.targetRotX;
                state.semantic.rotY = state.semantic.targetRotY;
            } else {
                const smooth = quality === 'low' ? 0.25 : 0.14;
                state.semantic.rotX += (state.semantic.targetRotX - state.semantic.rotX) * smooth;
                state.semantic.rotY += (state.semantic.targetRotY - state.semantic.rotY) * smooth;
            }
            
            // ═══════════════════════════════════════════════════════════════════════════
            // BACKGROUND — Deep space with nebula effect
            // ═══════════════════════════════════════════════════════════════════════════
            const bgGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, Math.hypot(w, h) * 0.7);
            bgGrad.addColorStop(0, '#0c0c1a');
            bgGrad.addColorStop(0.2, '#080814');
            bgGrad.addColorStop(0.5, '#050510');
            bgGrad.addColorStop(1, '#020206');
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, w, h);
            
            // Rich nebula glow with multiple layers
            const nebulaGrad = ctx.createRadialGradient(cx * 0.7, cy * 0.6, 0, cx * 0.7, cy * 0.6, Math.min(w, h) * 0.6);
            nebulaGrad.addColorStop(0, 'rgba(120, 60, 200, 0.05)');
            nebulaGrad.addColorStop(0.4, 'rgba(80, 100, 200, 0.03)');
            nebulaGrad.addColorStop(0.7, 'rgba(60, 140, 180, 0.02)');
            nebulaGrad.addColorStop(1, 'transparent');
            ctx.fillStyle = nebulaGrad;
            ctx.fillRect(0, 0, w, h);
            
            // Secondary nebula for depth
            const nebula2 = ctx.createRadialGradient(cx * 1.3, cy * 1.2, 0, cx * 1.3, cy * 1.2, Math.min(w, h) * 0.4);
            nebula2.addColorStop(0, 'rgba(200, 100, 80, 0.03)');
            nebula2.addColorStop(0.5, 'rgba(150, 60, 100, 0.02)');
            nebula2.addColorStop(1, 'transparent');
            ctx.fillStyle = nebula2;
            ctx.fillRect(0, 0, w, h);
            
            // Star field
            ctx.fillStyle = 'rgba(255,255,255,0.06)';
            for (let i = 0; i < CONFIG.render.starCount; i++) {
                const sx = seededRandom(i * 7) * w;
                const sy = seededRandom(i * 13 + 1000) * h;
                const size = 0.2 + seededRandom(i * 17 + 2000) * 0.6;
                ctx.beginPath();
                ctx.arc(sx, sy, size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // ═══════════════════════════════════════════════════════════════════════════
            // FILTER & PROJECT FILES — Keep all, fade non-matching during search
            // ═══════════════════════════════════════════════════════════════════════════
            let files = state.files.filter(f => 
                f.x !== undefined && f.y !== undefined && f.z !== undefined &&
                isFinite(f.x) && isFinite(f.y) && isFinite(f.z)
            );
            
            // Category filter still removes non-matching completely
            if (state.filter) {
                files = files.filter(f => f.category === state.filter);
            }
            
            // Search: Build set of matching files (for fade logic), but keep all visible
            const searchQuery = state.query?.toLowerCase() || '';
            const hasSearch = searchQuery.length >= CONFIG.ui.searchMinLength;
            const matchingPaths = new Set();
            
            if (hasSearch) {
                for (const f of files) {
                    const matches = 
                        (f.path && f.path.toLowerCase().includes(searchQuery)) || 
                        (f.name && f.name.toLowerCase().includes(searchQuery)) ||
                        (f.keywords && f.keywords.some(k => k.toLowerCase().includes(searchQuery))) ||
                        (f.summary && f.summary.toLowerCase().includes(searchQuery));
                    if (matches) {
                        matchingPaths.add(f.path);
                    }
                }
            }
            
            const fov = CONFIG.render.fov;
            const cameraZ = CONFIG.render.cameraZ;
            const scale = Math.min(w, h) * CONFIG.render.scaleMultiplier * state.semantic.zoom;
            const cosY = Math.cos(state.semantic.rotY);
            const sinY = Math.sin(state.semantic.rotY);
            const cosX = Math.cos(state.semantic.rotX);
            const sinX = Math.sin(state.semantic.rotX);
            
            // Project all files to 2D
            let projected = [];
            
            for (const f of files) {
                let px = (f.x - 0.5) * 2;
                let py = (f.y - 0.5) * 2;
                let pz = (f.z - 0.5) * 2;
                
                const x1 = px * cosY - pz * sinY;
                const z1 = px * sinY + pz * cosY;
                const y1 = py * cosX - z1 * sinX;
                const z2 = py * sinX + z1 * cosX;
                
                const depth = fov / (fov + z2 + cameraZ);
                if (depth <= 0 || !isFinite(depth)) continue;
                
                projected.push({
                    file: f,
                    sx: cx + x1 * scale * depth,
                    sy: cy + y1 * scale * depth,
                    sz: z2,
                    depth: depth,
                    matchesSearch: !hasSearch || matchingPaths.has(f.path),
                });
            }
            
            // LOD: keep most important nodes for performance
            const maxNodes = quality === 'high' ? CONFIG.render.maxNodesHigh :
                quality === 'med' ? CONFIG.render.maxNodesMed : CONFIG.render.maxNodesLow;
            if (projected.length > maxNodes) {
                projected.sort((a, b) => (b.file.importance || 0) - (a.file.importance || 0));
                projected = projected.slice(0, maxNodes);
            }
            
            projected.sort((a, b) => a.sz - b.sz);
            state.semantic.projected = projected;
            
            // Build projection lookup
            const projByPath = new Map();
            projected.forEach(p => projByPath.set(p.file.path, p));
            const projByName = new Map();
            projected.forEach(p => {
                if (!p.file.name) return;
                const name = p.file.name.replace(/\.(py|js|ts|tsx|jsx|rs|swift|kt)$/, '');
                if (!projByName.has(name)) projByName.set(name, []);
                projByName.get(name).push(p);
            });
            
            // ═══════════════════════════════════════════════════════════════════════════
            // LAYER: CLUSTERS — Translucent boundary hulls
            // ═══════════════════════════════════════════════════════════════════════════
            if (layers.clusters && quality === 'high') {
                const clusterGroups = new Map();
                projected.forEach(p => {
                    const cluster = p.file.cluster ?? -1;
                    if (cluster >= 0) {
                        if (!clusterGroups.has(cluster)) clusterGroups.set(cluster, []);
                        clusterGroups.get(cluster).push(p);
                    }
                });
                
                clusterGroups.forEach((points, clusterId) => {
                    if (points.length < 3) return;
                    
                    // Simple convex hull approximation (bounding circle)
                    const avgX = points.reduce((s, p) => s + p.sx, 0) / points.length;
                    const avgY = points.reduce((s, p) => s + p.sy, 0) / points.length;
                    const maxR = Math.max(...points.map(p => Math.hypot(p.sx - avgX, p.sy - avgY))) + 30;
                    
                    // Use actual cluster color from palette
                    const clusterColor = getClusterColor(clusterId);
                    const { h, s, l } = clusterColor;
                    
                    // Outer glow for cluster
                    const outerGlow = ctx.createRadialGradient(avgX, avgY, maxR * 0.3, avgX, avgY, maxR * 1.2);
                    outerGlow.addColorStop(0, `hsla(${h}, ${s}%, ${l}%, 0.08)`);
                    outerGlow.addColorStop(0.7, `hsla(${h}, ${s}%, ${l}%, 0.03)`);
                    outerGlow.addColorStop(1, 'transparent');
                    ctx.fillStyle = outerGlow;
                    ctx.fillRect(avgX - maxR * 1.5, avgY - maxR * 1.5, maxR * 3, maxR * 3);
                    
                    // Inner fill
                    ctx.beginPath();
                    ctx.arc(avgX, avgY, maxR, 0, Math.PI * 2);
                    ctx.fillStyle = `hsla(${h}, ${s}%, ${l}%, 0.06)`;
                    ctx.fill();
                    
                    // Dashed border
                    ctx.strokeStyle = `hsla(${h}, ${Math.min(90, s + 15)}%, ${Math.min(75, l + 15)}%, 0.25)`;
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([6, 4]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Cluster label with improved styling
                    const label = getClusterLabel(clusterId);
                    if (label) {
                        ctx.font = '600 11px "IBM Plex Sans", sans-serif';
                        ctx.textAlign = 'center';
                        
                        // Label background pill
                        const textWidth = ctx.measureText(label).width;
                        const pillX = avgX - textWidth / 2 - 8;
                        const pillY = avgY - maxR - 18;
                        const pillW = textWidth + 16;
                        const pillH = 20;
                        
                        ctx.fillStyle = `hsla(${h}, ${s}%, ${Math.max(15, l - 30)}%, 0.9)`;
                        ctx.beginPath();
                        ctx.roundRect(pillX, pillY, pillW, pillH, 6);
                        ctx.fill();
                        
                        // Pill border
                        ctx.strokeStyle = `hsla(${h}, ${s}%, ${l}%, 0.5)`;
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        
                        // Label text
                        ctx.fillStyle = `hsla(${h}, ${Math.min(85, s + 10)}%, ${Math.min(85, l + 25)}%, 1)`;
                        ctx.fillText(label, avgX, pillY + 14);
                        ctx.textAlign = 'left';
                    }
                });
            }
            
            // ═══════════════════════════════════════════════════════════════════════════
            // LAYER: IMPORTS — Connection lines
            // ═══════════════════════════════════════════════════════════════════════════
            if (layers.imports && quality !== 'low') {
                ctx.globalAlpha = 0.4;
                
                // Draw all import connections (subtle)
                for (const p of projected) {
                    const imports = p.file.imports || [];
                    for (const imp of imports) {
                        // Try to find the imported file
                        let targetP = projByPath.get(imp);
                        if (!targetP) {
                            const moduleName = imp.split('/').pop().replace(/\.(py|js|ts|tsx|jsx|rs|swift|kt)$/, '');
                            const candidates = projByName.get(moduleName) || [];
                            targetP = candidates[0];
                        }
                        
                        if (targetP && targetP !== p) {
                            const cat = p.file.category || 'Other';
                            const c = COLORS[cat] || COLORS.Other;
                            
                            ctx.beginPath();
                            ctx.moveTo(p.sx, p.sy);
                            ctx.lineTo(targetP.sx, targetP.sy);
                            ctx.strokeStyle = c.hex + '30';
                            ctx.lineWidth = 0.5;
                            ctx.stroke();
                        }
                    }
                }
                
                ctx.globalAlpha = 1;
            }
            
            // ═══════════════════════════════════════════════════════════════════════════
            // SELECTED FILE CONNECTIONS (bright, on top of faint import lines)
            // ═══════════════════════════════════════════════════════════════════════════
            if (state.semantic.selected && state.semantic.related.length) {
                const selP = projByPath.get(state.semantic.selected.path);
                if (selP) {
                    for (const relFile of state.semantic.related) {
                        const relP = projByPath.get(relFile.path);
                        if (relP) {
                            // Gradient line with glow
                            ctx.shadowColor = 'rgba(255, 215, 0, 0.5)';
                            ctx.shadowBlur = 8;
                            
                            const grad = ctx.createLinearGradient(selP.sx, selP.sy, relP.sx, relP.sy);
                            grad.addColorStop(0, 'rgba(255, 215, 0, 0.9)');
                            grad.addColorStop(0.3, 'rgba(255, 180, 0, 0.6)');
                            grad.addColorStop(0.7, 'rgba(255, 140, 0, 0.4)');
                            grad.addColorStop(1, 'rgba(255, 100, 0, 0.2)');
                            
                            ctx.beginPath();
                            ctx.moveTo(selP.sx, selP.sy);
                            ctx.lineTo(relP.sx, relP.sy);
                            ctx.strokeStyle = grad;
                            ctx.lineWidth = 2;
                            ctx.stroke();
                            
                            ctx.shadowBlur = 0;
                        }
                    }
                }
            }
            
            // ═══════════════════════════════════════════════════════════════════════════
            // DRAW NODES
            // ═══════════════════════════════════════════════════════════════════════════
            for (const p of projected) {
                drawNode(ctx, p, layers);
            }
            
            // ═══════════════════════════════════════════════════════════════════════════
            // LAYER: LABELS — Floating labels for important nodes and search matches
            // ═══════════════════════════════════════════════════════════════════════════
            if (layers.labels) {
                ctx.textAlign = 'center';
                
                // Prioritize: 1) search matches, 2) important files, 3) large files
                let labelCandidates;
                
                if (hasSearch && matchingPaths.size > 0) {
                    // During search, show labels for all matching files
                    labelCandidates = projected
                        .filter(p => p.matchesSearch)
                        .sort((a, b) => (b.file.importance || 0) - (a.file.importance || 0))
                        .slice(0, quality === 'high' ? 50 : quality === 'med' ? 30 : 15);
                } else {
                    // Normal mode: label important files
                    labelCandidates = projected
                        .filter(p => (p.file.importance || 0) > 0.3 || (p.file.lines || 0) > 500)
                        .sort((a, b) => b.depth - a.depth)
                        .slice(0, quality === 'high' ? CONFIG.render.maxLabelsHigh :
                            quality === 'med' ? CONFIG.render.maxLabelsMed : CONFIG.render.maxLabelsLow);
                }
                
                for (const p of labelCandidates) {
                    const hov = state.semantic.hovered === p.file;
                    const sel = state.semantic.selected === p.file;
                    if (hov || sel) continue; // These already have labels from drawNode
                    
                    const label = p.file.name || p.file.path.split('/').pop();
                    let alpha = Math.min(1, p.depth * 0.8);
                    
                    // Search match labels are more prominent
                    const isSearchMatch = hasSearch && p.matchesSearch;
                    if (isSearchMatch) {
                        alpha = Math.max(0.85, alpha);
                    }
                    
                    const baseSize = CONFIG.render.nodeBaseSize + Math.sqrt(p.file.lines || 1) * CONFIG.render.nodeSizeScale;
                    const size = baseSize * (CONFIG.render.depthScaleMin + p.depth * CONFIG.render.depthScaleMax);
                    
                    // Enhanced label styling for search matches
                    if (isSearchMatch) {
                        const cat = p.file.category || 'Other';
                        const c = COLORS[cat] || COLORS.Other;
                        
                        ctx.font = '600 11px "IBM Plex Sans", sans-serif';
                        
                        // Background pill for search matches
                        const textWidth = ctx.measureText(label).width;
                        const pillX = p.sx - textWidth / 2 - 6;
                        const pillY = p.sy - size - 20;
                        const pillW = textWidth + 12;
                        const pillH = 18;
                        
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
                        ctx.beginPath();
                        ctx.roundRect(pillX, pillY, pillW, pillH, 5);
                        ctx.fill();
                        
                        ctx.strokeStyle = c.hex + 'AA';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        
                        ctx.fillStyle = c.light;
                        ctx.fillText(label, p.sx, pillY + 13);
                    } else {
                        ctx.font = '500 10px "IBM Plex Sans", sans-serif';
                        ctx.fillStyle = `rgba(200, 200, 200, ${alpha * 0.7})`;
                        ctx.fillText(label, p.sx, p.sy - size - 8);
                    }
                }
                
                ctx.textAlign = 'left';
            }
            
            // Auto rotate
            if (state.semantic.autoRotate && !state.semantic.dragging) {
                state.semantic.targetRotY += CONFIG.render.autoRotateSpeed;
            }
            
            // Fog overlay for depth cohesion
            const fog = ctx.createRadialGradient(cx, cy, Math.min(w, h) * 0.2, cx, cy, Math.max(w, h) * 0.75);
            fog.addColorStop(0, `rgba(6, 6, 10, ${CONFIG.render.fogStrength * 0.15})`);
            fog.addColorStop(1, `rgba(6, 6, 10, ${CONFIG.render.fogStrength})`);
            ctx.fillStyle = fog;
            ctx.fillRect(0, 0, w, h);
            
            updateQuality(performance.now() - t0);
        }
        
        function drawNode(ctx, { file, sx, sy, sz, depth, matchesSearch = true }, layers = {}) {
            const hov = state.semantic.hovered === file;
            const sel = state.semantic.selected === file;
            const rel = state.semantic.related.includes(file);
            const quality = state.semantic.quality;
            const focusOn = state.semantic.layers.focus && state.semantic.focusClusterId !== null;
            const isFocused = focusOn && file.cluster === state.semantic.focusClusterId;
            
            // Size based on importance and depth
            const baseSize = CONFIG.render.nodeBaseSize + Math.sqrt(file.lines || 1) * CONFIG.render.nodeSizeScale + (file.importance || 0) * CONFIG.render.importanceScale;
            const depthScale = CONFIG.render.depthScaleMin + depth * CONFIG.render.depthScaleMax;
            let size = baseSize * depthScale;
            
            // Interactive states
            if (hov) size *= 1.4;
            if (sel) size *= 1.6;
            if (rel) size *= 1.2;
            
            // Search match highlighting: boost matching, fade non-matching
            if (!matchesSearch && !sel && !hov) {
                size *= 0.6;
            } else if (matchesSearch && state.query?.length >= CONFIG.ui.searchMinLength) {
                size *= 1.25; // Boost search matches
            }
            
            // Alpha based on depth
            let alpha = Math.max(0.3, Math.min(1, 0.35 + depth * 0.75));
            
            // Fade non-matching nodes during search
            if (!matchesSearch && !sel && !hov) {
                alpha *= 0.12; // Heavy fade for non-matching
            }
            
            if (focusOn && !isFocused) {
                alpha *= 0.15;
                size *= 0.8;
            }
            
            const cat = file.category || 'Other';
            const c = COLORS[cat] || COLORS.Other;
            
            // ═══════════════════════════════════════════════════════════════════════════
            // HEAT LAYER — Color intensity by importance
            // ═══════════════════════════════════════════════════════════════════════════
            let heatColor = c.hex;
            if (layers.heat) {
                const importance = file.importance || 0;
                const lines = Math.log10(Math.max(1, file.lines || 1)) / 5;
                const heat = Math.min(1, importance + lines * 0.3);
                
                // Interpolate from cool (blue) to hot (red/yellow)
                const hue = 240 - heat * 240; // Blue → Red
                const sat = 70 + heat * 30;
                const light = 40 + heat * 20;
                heatColor = `hsl(${hue}, ${sat}%, ${light}%)`;
                alpha = Math.max(0.5, alpha);
            }
            
            // ═══════════════════════════════════════════════════════════════════════════
            // ENHANCED GLOW FOR INTERACTIVE STATES — Multi-layer glow system
            // ═══════════════════════════════════════════════════════════════════════════
            if (sel || hov || (rel && quality !== 'low')) {
                // Animated pulse for selection (use time for animation)
                const time = performance.now() * 0.002;
                const pulse = sel ? 0.15 * Math.sin(time) + 1 : 1;
                const glowSize = size * (sel ? 6 * pulse : hov ? 4.5 : 3.5);
                
                // Outer atmospheric glow
                const outerGlow = ctx.createRadialGradient(sx, sy, 0, sx, sy, glowSize * 1.5);
                if (sel) {
                    outerGlow.addColorStop(0, 'rgba(255, 215, 0, 0.3)');
                    outerGlow.addColorStop(0.5, 'rgba(255, 180, 0, 0.1)');
                    outerGlow.addColorStop(1, 'transparent');
                    ctx.fillStyle = outerGlow;
                    ctx.beginPath();
                    ctx.arc(sx, sy, glowSize * 1.5, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Main glow
                const glow = ctx.createRadialGradient(sx, sy, 0, sx, sy, glowSize);
                
                if (sel) {
                    // Golden selection glow with animation
                    glow.addColorStop(0, `rgba(255, 220, 50, ${0.8 * pulse})`);
                    glow.addColorStop(0.25, `rgba(255, 200, 0, ${0.5 * pulse})`);
                    glow.addColorStop(0.5, `rgba(255, 160, 0, ${0.25 * pulse})`);
                    glow.addColorStop(0.75, `rgba(255, 120, 0, ${0.1 * pulse})`);
                    glow.addColorStop(1, 'transparent');
                } else if (hov) {
                    // Bright hover glow using category color (enhanced for touch)
                    const glowOpacity = 0.85;
                    glow.addColorStop(0, c.light + alphaHex(glowOpacity));
                    glow.addColorStop(0.25, c.hex + alphaHex(glowOpacity * 0.6));
                    glow.addColorStop(0.5, c.dark + alphaHex(glowOpacity * 0.3));
                    glow.addColorStop(0.75, c.dark + alphaHex(glowOpacity * 0.1));
                    glow.addColorStop(1, 'transparent');
                } else {
                    // Related file glow
                    glow.addColorStop(0, 'rgba(255, 200, 100, 0.5)');
                    glow.addColorStop(0.4, 'rgba(255, 180, 80, 0.2)');
                    glow.addColorStop(0.7, 'rgba(255, 160, 60, 0.08)');
                    glow.addColorStop(1, 'transparent');
                }
                
                ctx.fillStyle = glow;
                ctx.beginPath();
                ctx.arc(sx, sy, glowSize, 0, Math.PI * 2);
                ctx.fill();
                
                // Selection ring animation
                if (sel) {
                    const ringSize = size * (2.2 + 0.3 * Math.sin(time * 2));
                    ctx.strokeStyle = `rgba(255, 215, 0, ${0.6 + 0.3 * Math.sin(time)})`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(sx, sy, ringSize, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Second animated ring
                    const ring2Size = size * (3 + 0.4 * Math.sin(time * 1.5 + 1));
                    ctx.strokeStyle = `rgba(255, 215, 0, ${0.3 + 0.2 * Math.sin(time + 0.5)})`;
                    ctx.lineWidth = 1;
                    ctx.setLineDash([4, 4]);
                    ctx.beginPath();
                    ctx.arc(sx, sy, ring2Size, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
            
            // ═══════════════════════════════════════════════════════════════════════════
            // MAIN NODE WITH GRADIENT
            // ═══════════════════════════════════════════════════════════════════════════
            if (!layers.heat && !sel && !hov && !rel && quality !== 'low') {
                const sprite = getNodeSprite(cat, size);
                ctx.globalAlpha = alpha;
                ctx.drawImage(sprite, sx - sprite.width / 2, sy - sprite.height / 2);
                ctx.globalAlpha = 1;
            } else {
                const nodeGrad = ctx.createRadialGradient(sx - size * 0.3, sy - size * 0.3, 0, sx, sy, size);
                if (layers.heat) {
                    nodeGrad.addColorStop(0, heatColor);
                    nodeGrad.addColorStop(1, heatColor.replace('hsl', 'hsla').replace(')', ', 0.7)'));
                } else {
                    nodeGrad.addColorStop(0, c.light + alphaHex(alpha));
                    nodeGrad.addColorStop(0.5, c.hex + alphaHex(alpha * 0.9));
                    nodeGrad.addColorStop(1, c.dark + alphaHex(alpha * 0.8));
                }
                
                ctx.beginPath();
                ctx.arc(sx, sy, size, 0, Math.PI * 2);
                ctx.fillStyle = nodeGrad;
                ctx.fill();
            }
            
            // Outer ring for definition
            ctx.strokeStyle = (sel ? '#FFD700' : c.light) + alphaHex(alpha * 0.5);
            ctx.lineWidth = sel ? 2 : 1;
            if (quality !== 'low') ctx.stroke();
            
            if (isFocused && quality === 'high') {
                ctx.strokeStyle = c.light + '66';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(sx, sy, size * 1.8, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Bright core highlight
            if (size > 3 && quality !== 'low') {
                const coreSize = size * 0.3;
                const coreGrad = ctx.createRadialGradient(sx - size * 0.15, sy - size * 0.15, 0, sx, sy, coreSize);
                coreGrad.addColorStop(0, `rgba(255, 255, 255, ${alpha * 0.9})`);
                coreGrad.addColorStop(0.5, `rgba(255, 255, 255, ${alpha * 0.4})`);
                coreGrad.addColorStop(1, 'transparent');
                
                ctx.beginPath();
                ctx.arc(sx - size * 0.15, sy - size * 0.15, coreSize, 0, Math.PI * 2);
                ctx.fillStyle = coreGrad;
                ctx.fill();
            }
            
            // ═══════════════════════════════════════════════════════════════════════════
            // LABEL FOR SELECTED/HOVERED
            // ═══════════════════════════════════════════════════════════════════════════
            if ((sel || hov) && size > 3) {
                const label = file.name || file.path.split('/').pop();
                ctx.font = `${sel ? 700 : 600} ${sel ? 14 : 12}px "IBM Plex Sans", sans-serif`;
                ctx.textAlign = 'center';
                
                // Background pill
                const textWidth = ctx.measureText(label).width;
                const pillX = sx - textWidth / 2 - 8;
                const pillY = sy - size - 24;
                const pillW = textWidth + 16;
                const pillH = 20;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
                ctx.beginPath();
                ctx.roundRect(pillX, pillY, pillW, pillH, 6);
                ctx.fill();
                
                // Border
                ctx.strokeStyle = sel ? '#FFD700' : c.hex;
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Text
                ctx.fillStyle = sel ? '#FFD700' : '#FFFFFF';
                ctx.fillText(label, sx, pillY + 14);
                ctx.textAlign = 'left';
            }
        }
        
        // Helper: convert alpha (0-1) to hex (00-FF)
        function alphaHex(alpha) {
            return Math.round(Math.max(0, Math.min(1, alpha)) * 255).toString(16).padStart(2, '0');
        }
        
        const spriteCache = new Map();
        
        function getNodeSprite(cat, size) {
            const c = COLORS[cat] || COLORS.Other;
            const bucket = Math.max(6, Math.min(40, Math.round(size * 1.4)));
            const key = `${cat}-${bucket}`;
            if (spriteCache.has(key)) return spriteCache.get(key);
            
            const canvas = document.createElement('canvas');
            const s = bucket * 2.4;
            canvas.width = s;
            canvas.height = s;
            const ctx = canvas.getContext('2d');
            const cx = s / 2;
            const cy = s / 2;
            
            const grad = ctx.createRadialGradient(cx - bucket * 0.35, cy - bucket * 0.35, 0, cx, cy, bucket);
            grad.addColorStop(0, c.light + 'FF');
            grad.addColorStop(0.5, c.hex + 'E6');
            grad.addColorStop(1, c.dark + 'CC');
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(cx, cy, bucket, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = c.light + '88';
            ctx.lineWidth = 1;
            ctx.stroke();
            
            spriteCache.set(key, canvas);
            return canvas;
        }
        
        // Seeded random for consistent star field
        function seededRandom(seed) {
            const x = Math.sin(seed) * 10000;
            return x - Math.floor(x);
        }
        
        // ═══════════════════════════════════════════════════════════════════════════════
        // EVENT HANDLERS
        // ═══════════════════════════════════════════════════════════════════════════════
        
        function setupEvents() {
            window.addEventListener('resize', debounce(resize, 100));
            
            // View tabs (old, hidden)
            document.querySelectorAll('.tab').forEach(t => {
                t.addEventListener('click', () => switchView(t.dataset.view));
            });
            
            // View toggle in sub-nav (new)
            document.querySelectorAll('.view-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    if (btn.classList.contains('active')) return;
                    switchView(btn.dataset.view);
                });
            });
            
            // Treemap events
            treemapCanvas.addEventListener('mousemove', onTreemapMove);
            treemapCanvas.addEventListener('click', onTreemapClick);
            treemapCanvas.addEventListener('mouseleave', () => {
                state.treemap.hovered = null;
                hideTooltip();
            });
            
            // Touch support for treemap (fixes tap-to-select on mobile/tablet)
            let treemapTouchStart = null;
            treemapCanvas.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    const touch = e.touches[0];
                    treemapTouchStart = { x: touch.clientX, y: touch.clientY, time: Date.now() };
                    // Update hovered cell on touch start
                    const rect = treemapCanvas.getBoundingClientRect();
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    state.treemap.hovered = null;
                    for (let i = state.treemap.cells.length - 1; i >= 0; i--) {
                        const cell = state.treemap.cells[i];
                        if (x >= cell.x && x <= cell.x + cell.w && y >= cell.y && y <= cell.y + cell.h) {
                            state.treemap.hovered = cell.node;
                            break;
                        }
                    }
                }
            }, { passive: true });
            
            treemapCanvas.addEventListener('touchend', (e) => {
                if (treemapTouchStart && e.changedTouches.length === 1) {
                    const touch = e.changedTouches[0];
                    const dx = Math.abs(touch.clientX - treemapTouchStart.x);
                    const dy = Math.abs(touch.clientY - treemapTouchStart.y);
                    const dt = Date.now() - treemapTouchStart.time;
                    
                    // Treat as tap if small movement and quick touch
                    if (dx < 15 && dy < 15 && dt < 400) {
                        // Re-check hovered cell at touch end position
                        const rect = treemapCanvas.getBoundingClientRect();
                        const x = touch.clientX - rect.left;
                        const y = touch.clientY - rect.top;
                        for (let i = state.treemap.cells.length - 1; i >= 0; i--) {
                            const cell = state.treemap.cells[i];
                            if (x >= cell.x && x <= cell.x + cell.w && y >= cell.y && y <= cell.y + cell.h) {
                                state.treemap.hovered = cell.node;
                                break;
                            }
                        }
                        if (state.treemap.hovered) {
                            onTreemapClick();
                        }
                    }
                }
                treemapTouchStart = null;
                hideTooltip();
            }, { passive: true });
            
            treemapCanvas.addEventListener('touchmove', (e) => {
                // Update hover during touch for visual feedback
                if (e.touches.length === 1) {
                    const touch = e.touches[0];
                    const rect = treemapCanvas.getBoundingClientRect();
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    state.treemap.hovered = null;
                    for (let i = state.treemap.cells.length - 1; i >= 0; i--) {
                        const cell = state.treemap.cells[i];
                        if (x >= cell.x && x <= cell.x + cell.w && y >= cell.y && y <= cell.y + cell.h) {
                            state.treemap.hovered = cell.node;
                            break;
                        }
                    }
                    if (state.treemap.hovered) {
                        showTooltip(state.treemap.hovered, touch.clientX, touch.clientY);
                    } else {
                        hideTooltip();
                    }
                }
            }, { passive: true });
            
            // Semantic 3D events
            semanticCanvas.addEventListener('mousedown', onSemanticDown);
            semanticCanvas.addEventListener('mousemove', onSemanticMove);
            semanticCanvas.addEventListener('mouseup', () => {
                if (state.semantic.dragging) {
                    state.semantic.dragging = false;
                    semanticCanvas.style.cursor = 'grab';
                    saveStateDebounced(); // Save camera state after drag
                }
            });
            semanticCanvas.addEventListener('mouseleave', () => {
                if (state.semantic.dragging) {
                    state.semantic.dragging = false;
                    saveStateDebounced();
                }
                state.semantic.hovered = null;
                hideTooltip();
            });
            semanticCanvas.addEventListener('wheel', e => {
                onSemanticWheel(e);
                saveStateDebounced(); // Save zoom after wheel
            }, { passive: false });
            semanticCanvas.addEventListener('click', onSemanticClick);
            
            // Touch support for semantic 3D view
            let semanticTouchState = { type: null, startX: 0, startY: 0, startDist: 0, time: 0 };
            
            semanticCanvas.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    const touch = e.touches[0];
                    semanticTouchState = {
                        type: 'single',
                        startX: touch.clientX,
                        startY: touch.clientY,
                        lastX: touch.clientX,
                        lastY: touch.clientY,
                        time: Date.now(),
                        moved: false
                    };
                    state.semantic.dragging = false;
                    
                    // Find hovered node for potential tap selection
                    const rect = semanticCanvas.getBoundingClientRect();
                    state.semantic.hovered = findNodeAt(touch.clientX - rect.left, touch.clientY - rect.top);
                } else if (e.touches.length === 2) {
                    // Pinch-to-zoom
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    semanticTouchState = {
                        type: 'pinch',
                        startDist: Math.sqrt(dx * dx + dy * dy),
                        startZoom: state.semantic.zoom
                    };
                }
            }, { passive: true });
            
            semanticCanvas.addEventListener('touchmove', (e) => {
                if (semanticTouchState.type === 'single' && e.touches.length === 1) {
                    const touch = e.touches[0];
                    const dx = touch.clientX - semanticTouchState.lastX;
                    const dy = touch.clientY - semanticTouchState.lastY;
                    
                    // Mark as moved if significant movement
                    const totalDx = Math.abs(touch.clientX - semanticTouchState.startX);
                    const totalDy = Math.abs(touch.clientY - semanticTouchState.startY);
                    if (totalDx > 10 || totalDy > 10) {
                        semanticTouchState.moved = true;
                        state.semantic.dragging = true;
                    }
                    
                    if (state.semantic.dragging) {
                        state.semantic.targetRotY += dx * CONFIG.render.rotationSensitivity;
                        state.semantic.targetRotX += dy * CONFIG.render.rotationSensitivity;
                        state.semantic.targetRotX = Math.max(-CONFIG.render.rotationClamp, Math.min(CONFIG.render.rotationClamp, state.semantic.targetRotX));
                    }
                    
                    semanticTouchState.lastX = touch.clientX;
                    semanticTouchState.lastY = touch.clientY;
                } else if (semanticTouchState.type === 'pinch' && e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const scale = dist / semanticTouchState.startDist;
                    state.semantic.zoom = Math.max(CONFIG.render.zoomMin, Math.min(CONFIG.render.zoomMax, semanticTouchState.startZoom * scale));
                }
                e.preventDefault();
            }, { passive: false });
            
            semanticCanvas.addEventListener('touchend', (e) => {
                if (semanticTouchState.type === 'single' && e.changedTouches.length === 1) {
                    const touch = e.changedTouches[0];
                    const dt = Date.now() - semanticTouchState.time;
                    
                    // Treat as tap if no significant movement and quick touch
                    if (!semanticTouchState.moved && dt < 400) {
                        const rect = semanticCanvas.getBoundingClientRect();
                        const hovered = findNodeAt(touch.clientX - rect.left, touch.clientY - rect.top);
                        if (hovered) {
                            selectFile(hovered);
                        } else {
                            closePanel();
                        }
                    }
                }
                
                if (state.semantic.dragging) {
                    saveStateDebounced();
                }
                state.semantic.dragging = false;
                semanticTouchState = { type: null };
                hideTooltip();
            }, { passive: true });
            
            // Controls
            document.querySelectorAll('.ctrl-btn').forEach(b => {
                b.addEventListener('click', () => onControl(b));
            });
            
            document.querySelectorAll('.zoom-btn').forEach(b => {
                b.addEventListener('click', () => {
                    const delta = b.dataset.dir === 'in' ? CONFIG.render.zoomStep : 1 / CONFIG.render.zoomStep;
                    state.semantic.zoom = Math.max(CONFIG.render.zoomMin, Math.min(CONFIG.render.zoomMax, state.semantic.zoom * delta));
                });
            });
            
            // Layer toggles
            document.querySelectorAll('.layer-toggle input').forEach(input => {
                input.addEventListener('change', () => {
                    const layer = input.dataset.layer;
                    state.semantic.layers[layer] = input.checked;
                    if (layer === 'focus' && input.checked && !state.semantic.selected) {
                        showToast('Select a file to focus its cluster');
                    }
                    saveStateDebounced();
                });
            });
            
            // Deep Semantic Search
            const searchInput = document.getElementById('search');
            const searchResults = document.getElementById('search-results');
            let searchSelectedIdx = -1;
            
            // Voice Search Setup
            const voiceBtn = document.getElementById('voice-btn');
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            
            if (SpeechRecognition) {
                const recognition = new SpeechRecognition();
                recognition.continuous = false;
                recognition.interimResults = true;
                recognition.lang = 'en-US';
                
                let isListening = false;
                
                voiceBtn.addEventListener('click', () => {
                    if (isListening) {
                        recognition.stop();
                    } else {
                        recognition.start();
                        searchInput.focus();
                    }
                });
                
                recognition.onstart = () => {
                    isListening = true;
                    voiceBtn.classList.add('listening');
                    searchInput.placeholder = 'Listening...';
                };
                
                recognition.onend = () => {
                    isListening = false;
                    voiceBtn.classList.remove('listening');
                    searchInput.placeholder = 'Search files, classes, functions...';
                };
                
                recognition.onresult = (event) => {
                    const transcript = Array.from(event.results)
                        .map(result => result[0].transcript)
                        .join('');
                    
                    searchInput.value = transcript;
                    state.query = transcript.trim();
                    performSearch(transcript.trim());
                };
                
                recognition.onerror = (event) => {
                    console.warn('Voice recognition error:', event.error);
                    isListening = false;
                    voiceBtn.classList.remove('listening');
                    searchInput.placeholder = 'Search files, classes, functions...';
                    
                    if (event.error === 'not-allowed') {
                        showToast('Microphone access denied');
                    }
                };
            } else {
                // Hide voice button if not supported
                voiceBtn.classList.add('unsupported');
            }
            
            searchInput.addEventListener('input', debounce(e => {
                const query = e.target.value.trim();
                state.query = query;
                performSearch(query);
            }, CONFIG.ui.searchDebounce));
            
            searchInput.addEventListener('focus', () => {
                if (searchInput.value.trim()) performSearch(searchInput.value.trim());
            });
            
            searchInput.addEventListener('blur', () => {
                setTimeout(() => searchResults.classList.remove('active'), 200);
            });
            
            searchInput.addEventListener('keydown', e => {
                const results = searchResults.querySelectorAll('.search-result');
                if (!results.length) return;
                
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    searchSelectedIdx = Math.min(searchSelectedIdx + 1, results.length - 1);
                    updateSearchSelection(results);
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    searchSelectedIdx = Math.max(searchSelectedIdx - 1, 0);
                    updateSearchSelection(results);
                } else if (e.key === 'Enter' && searchSelectedIdx >= 0) {
                    e.preventDefault();
                    results[searchSelectedIdx].click();
                }
            });
            
            function updateSearchSelection(results) {
                results.forEach((r, i) => r.classList.toggle('selected', i === searchSelectedIdx));
                if (searchSelectedIdx >= 0) results[searchSelectedIdx].scrollIntoView({ block: 'nearest' });
            }
            
            function performSearch(query) {
                if (!query || query.length < CONFIG.ui.searchMinLength) {
                    searchResults.classList.remove('active');
                    return;
                }
                
                const tokens = tokenize(query);
                const scored = state.files.map(f => ({
                    file: f,
                    score: scoreFile(f, tokens),
                    matches: findMatches(f, tokens)
                })).filter(r => r.score > 0)
                  .sort((a, b) => b.score - a.score)
                  .slice(0, CONFIG.ui.searchMaxResults);
                
                if (!scored.length) {
                    searchResults.innerHTML = '<div class="search-empty">No results for "' + escapeHtml(query) + '"</div>';
                } else {
                    const grouped = groupResults(scored);
                    searchResults.innerHTML = renderSearchResults(grouped, tokens);
                    
                    // Build a path-to-file lookup for click handling
                    const fileByPath = new Map(scored.map(r => [r.file.path, r.file]));
                    
                    searchResults.querySelectorAll('.search-result').forEach(el => {
                        el.addEventListener('click', () => {
                            const path = el.dataset.path;
                            const file = fileByPath.get(path);
                            if (file) {
                                selectFile(file);
                                searchResults.classList.remove('active');
                                searchInput.blur();
                            }
                        });
                    });
                }
                
                searchSelectedIdx = -1;
                searchResults.classList.add('active');
            }
            
            function tokenize(query) {
                return query.toLowerCase()
                    .split(/[\s\-_./\\]+/)
                    .filter(t => t.length >= 2)
                    .map(t => ({ text: t, regex: new RegExp('(' + escapeRegex(t) + ')', 'gi') }));
            }
            
            function scoreFile(file, tokens) {
                let score = 0;
                const name = (file.name || '').toLowerCase();
                const path = (file.path || '').toLowerCase();
                const funcs = (file.functions || []).join(' ').toLowerCase();
                const classes = (file.classes || []).join(' ').toLowerCase();
                const keywords = (file.keywords || []).join(' ').toLowerCase();
                const summary = (file.summary || '').toLowerCase();
                const concepts = (file.concepts || []).join(' ').toLowerCase();
                const exportsList = (file.exports || []).join(' ').toLowerCase();
                
                for (const { text } of tokens) {
                    // Exact name match (highest)
                    if (name === text) score += 100;
                    // Name starts with token
                    else if (name.startsWith(text)) score += 50;
                    // Name contains token
                    else if (name.includes(text)) score += 30;
                    
                    // Path match
                    if (path.includes(text)) score += 15;
                    
                    // Function/class/keyword matches (semantic)
                    if (funcs.includes(text)) score += 25;
                    if (classes.includes(text)) score += 25;
                    if (keywords.includes(text)) score += 20;
                    if (summary.includes(text)) score += 10;
                    if (concepts.includes(text)) score += 12;
                    if (exportsList.includes(text)) score += 10;
                    
                    // Category match
                    if ((file.category || '').toLowerCase().includes(text)) score += 15;
                }
                
                // Boost important files
                score *= (1 + (file.importance || 0) * 0.5);
                
                // Boost by line count (more code = more relevant)
                score *= (1 + Math.log10(Math.max(1, file.lines || 1)) * 0.1);
                
                return score;
            }
            
            function findMatches(file, tokens) {
                const matches = { name: [], path: [], funcs: [], classes: [], keywords: [], concepts: [], exports: [] };
                
                for (const { text } of tokens) {
                    if ((file.name || '').toLowerCase().includes(text)) matches.name.push(text);
                    if ((file.path || '').toLowerCase().includes(text)) matches.path.push(text);
                    
                    (file.functions || []).forEach(f => {
                        if (f.toLowerCase().includes(text)) matches.funcs.push(f);
                    });
                    (file.classes || []).forEach(c => {
                        if (c.toLowerCase().includes(text)) matches.classes.push(c);
                    });
                    (file.keywords || []).forEach(k => {
                        if (k.toLowerCase().includes(text)) matches.keywords.push(k);
                    });
                    (file.concepts || []).forEach(c => {
                        if (c.toLowerCase().includes(text)) matches.concepts.push(c);
                    });
                    (file.exports || []).forEach(e => {
                        if (String(e).toLowerCase().includes(text)) matches.exports.push(e);
                    });
                }
                
                return matches;
            }
            
            function groupResults(scored) {
                // Group by category for better UX
                const groups = {};
                for (const r of scored) {
                    const cat = r.file.category || 'Other';
                    if (!groups[cat]) groups[cat] = [];
                    groups[cat].push(r);
                }
                return groups;
            }
            
            function renderSearchResults(groups, tokens) {
                let html = '';
                
                for (const [cat, results] of Object.entries(groups)) {
                    if (!results.length) continue;
                    
                    html += '<div class="search-header">' + escapeHtml(cat) + '</div>';
                    
                    for (const { file, score } of results.slice(0, 8)) {
                        const color = getHSL(cat);
                        const icon = getCategoryIcon(cat);
                        const highlighted = highlightTokens(file.name || '', tokens);
                        
                        // Shorter path display with highlighting
                        const pathParts = (file.path || '').split('/');
                        const shortPath = pathParts.length > 3 
                            ? '…/' + pathParts.slice(-3).join('/') 
                            : file.path;
                        const pathHighlighted = highlightTokens(shortPath, tokens);
                        
                        html += '<div class="search-result" data-path="' + escapeHtml(file.path) + '">';
                        html += '<div class="search-result-icon" style="background: hsla(' + color.h + ', ' + color.s + '%, ' + color.l + '%, 0.12); color: hsl(' + color.h + ', ' + color.s + '%, ' + color.l + '%)">' + icon + '</div>';
                        html += '<div class="search-result-content">';
                        html += '<div class="search-result-name">' + highlighted + '</div>';
                        html += '<div class="search-result-path">' + pathHighlighted + '</div>';
                        html += '</div>';
                        html += '<span class="search-result-score">' + Math.round(score) + '</span>';
                        html += '</div>';
                    }
                }
                
                return html;
            }
            
            function highlightTokens(text, tokens) {
                let result = escapeHtml(text);
                for (const { regex } of tokens) {
                    result = result.replace(regex, '<span class="token-match">$1</span>');
                }
                return result;
            }
            
            // Panel close
            document.getElementById('panel-close').addEventListener('click', closePanel);
            
            // Keyboard
            document.addEventListener('keydown', e => {
                if (e.key === 'Escape') closePanel();
                if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
                    e.preventDefault();
                    searchInput.focus();
                }
                // "/" to focus search (vim-style)
                if (e.key === '/' && !e.metaKey && !e.ctrlKey && !e.altKey) {
                    const active = document.activeElement;
                    if (active?.tagName !== 'INPUT' && active?.tagName !== 'TEXTAREA') {
                        e.preventDefault();
                        searchInput.focus();
                    }
                }
                if (e.key === 'Backspace' && state.view === 'treemap' && state.treemap.path.length && document.activeElement !== searchInput) {
                    e.preventDefault();
                    state.treemap.path.pop();
                    updateBreadcrumbs();
                }
            });
        }
        
        // ═══════════════════════════════════════════════════════════════════════════════
        // VIEW TRANSITIONS — Street View-style smooth morphing
        // ═══════════════════════════════════════════════════════════════════════════════
        
        function switchView(view, targetFile = null) {
            if (state.transition.active) return;
            if (state.view === view && !targetFile) return;
            
            const fromView = state.view;
            const toView = view;
            
            // Start transition
            state.transition = {
                active: true,
                progress: 0,
                fromView,
                toView,
                targetFile,
                startTime: performance.now(),
                duration: 700,
            };
            
            // Update UI immediately
            document.querySelectorAll('.tab').forEach(t => t.classList.toggle('active', t.dataset.view === view));
            document.querySelectorAll('.view-btn').forEach(btn => btn.classList.toggle('active', btn.dataset.view === view));
            
            // Show both views during transition
            const treemapView = document.getElementById('treemap-view');
            const semanticView = document.getElementById('semantic-view');
            
            // Street View style: Cinematic zoom with blur
            const transitionStyle = `
                opacity 0.6s cubic-bezier(0.4, 0, 0.2, 1), 
                transform 0.7s cubic-bezier(0.4, 0, 0.2, 1),
                filter 0.5s ease-out
            `;
            treemapView.style.transition = transitionStyle;
            semanticView.style.transition = transitionStyle;
            
            if (toView === 'semantic') {
                // Treemap → 3D: Immersive zoom-in like entering a 3D space
                treemapView.style.opacity = '1';
                treemapView.style.transform = 'scale(1) perspective(1000px) rotateX(0deg)';
                treemapView.style.filter = 'blur(0)';
                semanticView.classList.add('active');
                semanticView.style.opacity = '0';
                semanticView.style.transform = 'scale(0.85) perspective(1000px) rotateX(-5deg)';
                semanticView.style.filter = 'blur(8px)';
                
                // If we have a target file, center the 3D view on it
                if (targetFile && targetFile.x !== undefined) {
                    const px = (targetFile.x - 0.5) * 2;
                    const pz = (targetFile.z - 0.5) * 2;
                    state.semantic.targetRotY = Math.atan2(px, pz);
                    state.semantic.rotY = state.semantic.targetRotY;
                }
                
                requestAnimationFrame(() => {
                    resize();
                    // Outgoing view zooms forward and blurs
                    treemapView.style.opacity = '0';
                    treemapView.style.transform = 'scale(1.3) perspective(1000px) rotateX(10deg)';
                    treemapView.style.filter = 'blur(12px)';
                    // Incoming view scales up and sharpens
                    semanticView.style.opacity = '1';
                    semanticView.style.transform = 'scale(1) perspective(1000px) rotateX(0deg)';
                    semanticView.style.filter = 'blur(0)';
                });
                
                setTimeout(() => {
                    treemapView.classList.remove('active');
                    treemapView.style.cssText = '';
                    semanticView.style.cssText = '';
                    completeTransition(toView);
                }, 650);
                
            } else {
                // 3D → Treemap: Pull back like exiting immersive mode
                semanticView.style.opacity = '1';
                semanticView.style.transform = 'scale(1) perspective(1000px) rotateX(0deg)';
                semanticView.style.filter = 'blur(0)';
                treemapView.classList.add('active');
                treemapView.style.opacity = '0';
                treemapView.style.transform = 'scale(1.3) perspective(1000px) rotateX(10deg)';
                treemapView.style.filter = 'blur(12px)';
                
                requestAnimationFrame(() => {
                    resize();
                    // Outgoing view shrinks back and blurs
                    semanticView.style.opacity = '0';
                    semanticView.style.transform = 'scale(0.85) perspective(1000px) rotateX(-5deg)';
                    semanticView.style.filter = 'blur(8px)';
                    // Incoming view scales to normal
                    treemapView.style.opacity = '1';
                    treemapView.style.transform = 'scale(1) perspective(1000px) rotateX(0deg)';
                    treemapView.style.filter = 'blur(0)';
                });
                
                setTimeout(() => {
                    semanticView.classList.remove('active');
                    semanticView.style.cssText = '';
                    treemapView.style.cssText = '';
                    completeTransition(toView);
                }, 650);
            }
        }
        
        function completeTransition(view) {
            state.view = view;
            state.transition.active = false;
            
            const is3D = view === 'semantic';
            
            // Update UI visibility
            const controls = document.getElementById('controls');
            const zoom = document.getElementById('zoom');
            const layersPanel = document.getElementById('layers-panel');
            const navBreadcrumbs = document.getElementById('nav-breadcrumbs');
            
            if (controls) controls.style.display = is3D ? 'flex' : 'none';
            if (zoom) zoom.style.display = is3D ? 'flex' : 'none';
            if (layersPanel) layersPanel.style.display = is3D ? 'flex' : 'none';
            
            // Show/hide breadcrumbs in sub-nav based on view
            if (navBreadcrumbs) {
                navBreadcrumbs.style.opacity = is3D ? '0.5' : '1';
                navBreadcrumbs.style.pointerEvents = is3D ? 'none' : 'auto';
            }
            
            // Update view toggle buttons
            document.querySelectorAll('.view-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.view === view);
            });
            
            // Update old tabs too for compatibility
            document.querySelectorAll('.tab').forEach(t => {
                t.classList.toggle('active', t.dataset.view === view);
            });
            
            // Make sure the correct view is active
            const treemapView = document.getElementById('treemap-view');
            const semanticView = document.getElementById('semantic-view');
            
            if (is3D) {
                treemapView?.classList.remove('active');
                semanticView?.classList.add('active');
            } else {
                semanticView?.classList.remove('active');
                treemapView?.classList.add('active');
                // Update breadcrumbs when returning to treemap
                updateBreadcrumbs();
            }
            
            // Force resize to ensure canvas dimensions are correct
            resize();
            
            // Persist state
            saveState();
        }
        
        function transitionToFile(file) {
            // Navigate to file's location in treemap, then transition to 3D centered on it
            if (file) {
                state.semantic.selected = file;
                state.semantic.related = findRelatedByImports(file);
                switchView('semantic', file);
            }
        }
        
        function onTreemapMove(e) {
            const rect = treemapCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            state.treemap.hovered = null;
            
            // Find hovered cell (reverse order for front-to-back)
            for (let i = state.treemap.cells.length - 1; i >= 0; i--) {
                const cell = state.treemap.cells[i];
                if (x >= cell.x && x <= cell.x + cell.w && y >= cell.y && y <= cell.y + cell.h) {
                    state.treemap.hovered = cell.node;
                    break;
                }
            }
            
            if (state.treemap.hovered) {
                showTooltip(state.treemap.hovered, e.clientX, e.clientY);
                treemapCanvas.style.cursor = 'pointer';
            } else {
                hideTooltip();
                treemapCanvas.style.cursor = 'default';
            }
        }
        
        function onTreemapClick() {
            const node = state.treemap.hovered;
            if (!node) return;
            
            if (node.isFile && node.file) {
                selectFile(node.file);
            } else if (!node.isFile && node.children) {
                state.treemap.path.push(node.name);
                updateBreadcrumbs();
                saveState();
            }
        }
        
        function onSemanticDown(e) {
            state.semantic.dragging = true;
            state.semantic.lastX = e.clientX;
            state.semantic.lastY = e.clientY;
            semanticCanvas.style.cursor = 'grabbing';
        }
        
        function onSemanticMove(e) {
            if (state.semantic.dragging) {
                const dx = e.clientX - state.semantic.lastX;
                const dy = e.clientY - state.semantic.lastY;
                state.semantic.targetRotY += dx * CONFIG.render.rotationSensitivity;
                state.semantic.targetRotX += dy * CONFIG.render.rotationSensitivity;
                state.semantic.targetRotX = Math.max(-CONFIG.render.rotationClamp, Math.min(CONFIG.render.rotationClamp, state.semantic.targetRotX));
                state.semantic.lastX = e.clientX;
                state.semantic.lastY = e.clientY;
            } else {
                const rect = semanticCanvas.getBoundingClientRect();
                const mx = e.clientX - rect.left;
                const my = e.clientY - rect.top;
                
                state.semantic.hovered = findNodeAt(mx, my);
                
                if (state.semantic.hovered) {
                    showTooltip(state.semantic.hovered, e.clientX, e.clientY);
                    semanticCanvas.style.cursor = 'pointer';
                } else {
                    hideTooltip();
                    semanticCanvas.style.cursor = 'grab';
                }
            }
        }
        
        function onSemanticWheel(e) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 1 / CONFIG.render.zoomStep : CONFIG.render.zoomStep;
            state.semantic.zoom = Math.max(CONFIG.render.zoomMin, Math.min(CONFIG.render.zoomMax, state.semantic.zoom * delta));
        }
        
        function onSemanticClick(e) {
            if (state.semantic.dragging) return;
            
            if (state.semantic.hovered) {
                selectFile(state.semantic.hovered);
            } else {
                // Click on empty space - deselect
                closePanel();
            }
        }
        
        function onControl(btn) {
            const preset = btn.dataset.preset;
            const action = btn.dataset.action;
            
            if (preset) {
                document.querySelectorAll('.ctrl-btn[data-preset]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                if (preset === 'orbit') { state.semantic.targetRotX = CONFIG.render.initialRotX; state.semantic.targetRotY = CONFIG.render.initialRotY; }
                else if (preset === 'top') { state.semantic.targetRotX = Math.PI / 2 - 0.1; state.semantic.targetRotY = CONFIG.render.initialRotY; }
                else if (preset === 'front') { state.semantic.targetRotX = 0; state.semantic.targetRotY = CONFIG.render.initialRotY; }
                
                saveState();
            }
            
            if (action === 'reset') {
                state.semantic.targetRotX = CONFIG.render.initialRotX;
                state.semantic.targetRotY = CONFIG.render.initialRotY;
                state.semantic.zoom = 1.0;
                saveState();
            }
            
            if (action === 'auto') {
                state.semantic.autoRotate = !state.semantic.autoRotate;
                btn.classList.toggle('active', state.semantic.autoRotate);
                saveState();
            }
            
            if (action === 'back') {
                // Smooth transition back to treemap
                switchView('treemap');
            }
        }
        
        // Find related files by actual import relationships
        function findRelatedByImports(file) {
            if (!file || !file.path) return [];
            
            const related = new Set();
            const imports = file.imports || [];
            const importedBy = state.importGraph.importedBy[file.path] || [];
            
            // Files this file imports
            for (const imp of imports) {
                const target = state.files.find(f => 
                    f.path === imp || 
                    f.path.endsWith('/' + imp) ||
                    f.name === imp ||
                    f.path.includes(imp.replace(/\./g, '/'))
                );
                if (target) related.add(target);
            }
            
            // Files that import this file
            for (const imp of importedBy) {
                const source = state.files.find(f => f.path === imp);
                if (source) related.add(source);
            }
            
            // Also add proximity-based similarity as fallback
            const proximityRelated = findSimilar(file, 5);
            proximityRelated.forEach(f => related.add(f));
            
            return Array.from(related).slice(0, CONFIG.ui.maxSimilarFiles);
        }
        
        function findNodeAt(mx, my) {
            // Search from front to back (reverse of draw order)
            const projected = state.semantic.projected;
            for (let i = projected.length - 1; i >= 0; i--) {
                const p = projected[i];
                const baseSize = CONFIG.render.nodeBaseSize + Math.sqrt(p.file.lines || 1) * CONFIG.render.nodeSizeScale + (p.file.importance || 0) * CONFIG.render.importanceScale;
                const depthScale = CONFIG.render.depthScaleMin + p.depth * CONFIG.render.depthScaleMax;
                const size = baseSize * depthScale;
                const hitRadius = Math.max(CONFIG.render.hitRadiusMin, size * CONFIG.render.hitRadiusScale);
                
                const dist = Math.hypot(p.sx - mx, p.sy - my);
                if (dist < hitRadius) {
                    return p.file;
                }
            }
            return null;
        }
        
        // ═══════════════════════════════════════════════════════════════════════════════
        // UI HELPERS
        // ═══════════════════════════════════════════════════════════════════════════════
        
        function getVisibleFiles() {
            let files = state.files;
            
            // Apply filter
            if (state.filter) {
                files = files.filter(f => f.category === state.filter);
            }
            
            // Apply search query
            if (state.query && state.query.length >= CONFIG.ui.searchMinLength) {
                const q = state.query.toLowerCase();
                files = files.filter(f => 
                    (f.path && f.path.toLowerCase().includes(q)) ||
                    (f.name && f.name.toLowerCase().includes(q)) ||
                    (f.functions && f.functions.some(fn => fn.toLowerCase().includes(q))) ||
                    (f.classes && f.classes.some(c => c.toLowerCase().includes(q)))
                );
            }
            
            return files;
        }
        
        function updateStats() {
            const visibleFiles = getVisibleFiles();
            const totalFiles = state.files.length;
            const visibleLines = visibleFiles.reduce((s, f) => s + (f.lines || 0), 0);
            const totalLines = state.files.reduce((s, f) => s + (f.lines || 0), 0);
            const totalClusters = state.data?.stats?.clusters || 0;
            
            // Update state for derived stats
            state.stats.totalFiles = totalFiles;
            state.stats.visibleFiles = visibleFiles.length;
            state.stats.totalLines = totalLines;
            state.stats.visibleLines = visibleLines;
            
            const fileCountEl = document.getElementById('file-count');
            const lineCountEl = document.getElementById('line-count');
            const clusterCountEl = document.getElementById('cluster-count');
            const fileTotalEl = document.getElementById('file-total');
            const lineTotalEl = document.getElementById('line-total');
            
            // Show filtered count if different from total
            const isFiltered = state.filter || (state.query && state.query.length >= CONFIG.ui.searchMinLength);
            
            if (isFiltered) {
                animateNumber(fileCountEl, visibleFiles.length);
                animateNumber(lineCountEl, visibleLines);
                if (fileTotalEl) fileTotalEl.textContent = `/${formatNum(totalFiles)}`;
                if (lineTotalEl) lineTotalEl.textContent = `/${formatNum(totalLines)}`;
            } else {
                animateNumber(fileCountEl, totalFiles);
                animateNumber(lineCountEl, totalLines);
                if (fileTotalEl) fileTotalEl.textContent = '';
                if (lineTotalEl) lineTotalEl.textContent = '';
            }
            
            if (clusterCountEl) clusterCountEl.textContent = formatNum(totalClusters);
        }
        
        function animateNumber(el, targetValue) {
            if (!el) return;
            
            const currentText = el.textContent.replace(/,/g, '');
            const currentValue = parseInt(currentText) || 0;
            
            if (currentValue === targetValue) return;
            
            // Quick animation
            const duration = CONFIG.ui.durationNormal;
            const steps = 12;
            const stepTime = duration / steps;
            const diff = targetValue - currentValue;
            let step = 0;
            
            const animate = () => {
                step++;
                const progress = step / steps;
                const eased = 1 - Math.pow(1 - progress, 3); // Ease out cubic
                const value = Math.round(currentValue + diff * eased);
                el.textContent = formatNum(value);
                
                if (step < steps) {
                    setTimeout(animate, stepTime);
                }
            };
            
            animate();
        }
        
        function buildLegend() {
            // Build categories in sub-nav instead of floating legend
            buildNavCategories();
        }
        
        function buildNavCategories() {
            const counts = {};
            const lines = {};
            for (const f of state.files) {
                const cat = f.category || 'Other';
                counts[cat] = (counts[cat] || 0) + 1;
                lines[cat] = (lines[cat] || 0) + (f.lines || 0);
            }
            
            const sorted = Object.entries(counts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 15); // Show more categories in horizontal nav
            
            const container = document.getElementById('nav-categories');
            if (!container) return;
            
            // Add "All" pill first
            const allActive = !state.filter;
            let html = `
                <button class="cat-pill ${allActive ? 'active' : ''}" data-cat="">
                    <span class="cat-dot" style="background: var(--gold-500)"></span>
                    <span>All</span>
                    <span class="cat-count">${state.files.length}</span>
                </button>
            `;
            
            html += sorted.map(([name, count]) => {
                const c = COLORS[name] || COLORS.Other;
                const isActive = state.filter === name;
                return `
                    <button class="cat-pill ${isActive ? 'active' : ''}" 
                            data-cat="${name}"
                            style="--cat-color: ${c.hex}; --cat-color-dark: ${c.dark}; --cat-glow: ${c.glow}">
                        <span class="cat-dot" style="background: ${c.hex}"></span>
                        <span>${name}</span>
                        <span class="cat-count">${count}</span>
                    </button>
                `;
            }).join('');
            
            container.innerHTML = html;
            
            container.querySelectorAll('.cat-pill').forEach(el => {
                el.addEventListener('click', () => {
                    const cat = el.dataset.cat;
                    state.filter = cat || null;
                    buildNavCategories();
                    updateStats();
                    saveState();
                });
            });
        }
        
        function updateBreadcrumbs() {
            // Update breadcrumbs in sub-nav
            const parts = ['root', ...state.treemap.path];
            const container = document.getElementById('nav-breadcrumbs');
            const backBtn = document.getElementById('nav-back');
            
            if (!container) return;
            
            // Show/hide back button
            if (backBtn) {
                backBtn.style.display = state.treemap.path.length > 0 ? 'grid' : 'none';
            }
            
            // Build crumbs
            let html = '';
            parts.forEach((p, i) => {
                const isLast = i === parts.length - 1;
                html += `<span class="nav-crumb ${isLast ? 'current' : ''}" data-idx="${i}">${p}</span>`;
                if (!isLast) html += '<span class="nav-sep">/</span>';
            });
            
            // Keep back button, replace rest
            container.innerHTML = `
                <button class="nav-back" id="nav-back" title="Go up (Backspace)" style="display: ${state.treemap.path.length > 0 ? 'grid' : 'none'}">←</button>
                ${html}
            `;
            
            // Re-attach back button handler
            const newBackBtn = document.getElementById('nav-back');
            if (newBackBtn) {
                newBackBtn.addEventListener('click', () => {
                    if (state.treemap.path.length > 0) {
                        state.treemap.path.pop();
                        updateBreadcrumbs();
                        saveState();
                    }
                });
            }
            
            // Crumb click handlers
            container.querySelectorAll('.nav-crumb').forEach(el => {
                el.addEventListener('click', () => {
                    if (el.classList.contains('current')) return;
                    const idx = parseInt(el.dataset.idx);
                    state.treemap.path = state.treemap.path.slice(0, idx);
                    updateBreadcrumbs();
                    saveState();
                });
            });
        }
        
        function updateViewToggle() {
            document.querySelectorAll('.view-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.view === state.view);
            });
        }
        
        function showTooltip(item, x, y) {
            clearTimeout(state.tooltipTimer);
            
            const t = document.getElementById('tooltip');
            const file = item.file || item;
            const cat = file.category || item.category || 'Other';
            const c = COLORS[cat] || COLORS.Other;
            const clusterLabel = getClusterLabel(file.cluster);
            const importance = file.importance !== undefined ? Math.round(file.importance * 100) : null;
            
            // Build rich tooltip content with improved layout
            let html = `
                <div class="tt-header">
                    <span class="tt-icon" style="background: ${c.hex}25; color: ${c.hex}; border: 1px solid ${c.hex}40">${getCategoryIcon(cat)}</span>
                    <div class="tt-title">
                        <div class="tt-name">${escapeHtml(file.name || item.name)}</div>
                        <div class="tt-path">${escapeHtml(file.path || item.path)}</div>
                    </div>
                </div>
                <div class="tt-stats">
                    <span class="tt-stat"><strong>${formatNum(file.lines || item.lines)}</strong> lines</span>
                    <span class="tt-stat tt-cat" style="background: ${c.hex}25; color: ${c.hex}; border: 1px solid ${c.hex}40">${cat}</span>
                    ${importance !== null ? `<span class="tt-stat tt-importance"><span class="tt-imp-bar" style="width: ${importance}%; background: ${c.hex}"></span>${importance}%</span>` : ''}
                </div>
            `;
            
            // Summary first (most important)
            if (file.summary) {
                html += `<div class="tt-summary">${escapeHtml(file.summary)}</div>`;
            }
            
            // Quick stats row (compact)
            const funcs = file.functions || [];
            const classes = file.classes || [];
            const imports = file.imports || [];
            
            if (funcs.length || classes.length || imports.length) {
                html += `<div class="tt-quick-stats">`;
                if (classes.length) html += `<span class="tt-qs"><strong>${classes.length}</strong> class${classes.length > 1 ? 'es' : ''}</span>`;
                if (funcs.length) html += `<span class="tt-qs"><strong>${funcs.length}</strong> func${funcs.length > 1 ? 's' : ''}</span>`;
                if (imports.length) html += `<span class="tt-qs"><strong>${imports.length}</strong> import${imports.length > 1 ? 's' : ''}</span>`;
                html += `</div>`;
            }
            
            // Classes (prioritize over functions)
            if (classes.length > 0) {
                const display = classes.slice(0, 4);
                const more = classes.length > 4 ? ` <span class="tt-more">+${classes.length - 4}</span>` : '';
                html += `
                    <div class="tt-section">
                        <span class="tt-label">Classes</span>
                        <span class="tt-values">${display.map(c => `<code class="tt-class">${escapeHtml(c)}</code>`).join('')}${more}</span>
                    </div>
                `;
            }
            
            // Functions (show key ones)
            if (funcs.length > 0) {
                const display = funcs.filter(f => !f.startsWith('_')).slice(0, 4);
                if (display.length > 0) {
                    const more = funcs.length > 4 ? ` <span class="tt-more">+${funcs.length - display.length}</span>` : '';
                    html += `
                        <div class="tt-section">
                            <span class="tt-label">Functions</span>
                            <span class="tt-values">${display.map(f => `<code>${escapeHtml(f)}</code>`).join('')}${more}</span>
                        </div>
                    `;
                }
            }
            
            // Concepts/Keywords combined (semantic tags)
            const concepts = file.concepts || [];
            const keywords = file.keywords || [];
            const tags = [...new Set([...concepts, ...keywords])].slice(0, 6);
            if (tags.length > 0) {
                html += `
                    <div class="tt-section">
                        <span class="tt-label">Topics</span>
                        <span class="tt-tags">${tags.map(k => `<span class="tt-tag" style="background: ${c.hex}15; border: 1px solid ${c.hex}30; color: ${c.light}">${escapeHtml(k)}</span>`).join('')}</span>
                    </div>
                `;
            }
            
            // Cluster info
            if (file.cluster !== undefined && clusterLabel) {
                html += `<div class="tt-cluster">Cluster ${file.cluster}: ${escapeHtml(clusterLabel)}</div>`;
            }
            
            // Click hint
            html += `<div class="tt-hint">Click for details</div>`;
            
            t.innerHTML = html;
            
            // Position with smart edge detection
            const pad = 16;
            const maxWidth = 340;
            const rect = t.getBoundingClientRect();
            const estimatedHeight = 280;
            
            let left = x + pad;
            let top = y + pad;
            
            if (left + maxWidth > window.innerWidth - 20) {
                left = x - maxWidth - pad;
            }
            if (top + estimatedHeight > window.innerHeight - 20) {
                top = Math.max(20, window.innerHeight - estimatedHeight - 20);
            }
            
            t.style.left = left + 'px';
            t.style.top = top + 'px';
            t.classList.add('visible');
        }
        
        function hideTooltip() {
            clearTimeout(state.tooltipTimer);
            document.getElementById('tooltip').classList.remove('visible');
        }
        
        function selectFile(file) {
            if (!file || typeof file !== 'object') return;
            if (!file.path) return;
            
            state.treemap.selected = file;
            state.semantic.selected = file;
            state.semantic.related = findSimilar(file, CONFIG.ui.maxSimilarFiles);
            if (state.semantic.layers.focus) {
                state.semantic.focusClusterId = file.cluster ?? null;
            }
            
            showPanel(file);
        }
        
        function findSimilar(file, limit = 5) {
            if (!file || file.x === undefined || file.y === undefined || file.z === undefined) return [];
            
            const results = [];
            
            for (const f of state.files) {
                if (f === file) continue;
                if (f.x === undefined || f.y === undefined || f.z === undefined) continue;
                
                const dist = Math.sqrt(
                    (f.x - file.x) ** 2 +
                    (f.y - file.y) ** 2 +
                    (f.z - file.z) ** 2
                );
                
                let score = Math.max(0, 1 - dist * CONFIG.similarity.distanceScale);
                
                // Boost for same cluster
                if (f.cluster !== undefined && f.cluster === file.cluster) {
                    score += CONFIG.similarity.clusterBoost;
                }
                
                // Boost for same category
                if (f.category === file.category) {
                    score += CONFIG.similarity.categoryBoost;
                }
                
                if (score > CONFIG.similarity.minScore) {
                    results.push({ file: f, score, dist });
                }
            }
            
            return results
                .sort((a, b) => b.score - a.score)
                .slice(0, limit)
                .map(r => r.file);
        }
        
        function showPanel(file) {
            const cat = file.category || 'Other';
            const c = COLORS[cat] || COLORS.Other;
            const clusterLabel = getClusterLabel(file.cluster);
            
            document.getElementById('panel-title').textContent = file.name || file.path.split('/').pop();
            document.getElementById('panel-path').textContent = file.path;
            
            // Get related files by imports
            const importRelated = findRelatedByImports(file);
            const similar = findSimilar(file, CONFIG.ui.panelSimilarFiles);
            
            // Build imports/importedBy lists
            const imports = file.imports || [];
            const importedBy = state.importGraph.importedBy[file.path] || [];
            const funcs = file.functions || [];
            const classes = file.classes || [];
            const keywords = file.keywords || [];
            
            let html = `
                <!-- Stats Grid -->
                <div class="info-grid">
                    <div class="info-box">
                        <div class="info-box-label">Lines</div>
                        <div class="info-box-value">${formatNum(file.lines || 0)}</div>
                    </div>
                    <div class="info-box">
                        <div class="info-box-label">Category</div>
                        <div class="info-box-value" style="color:${c.hex}">${cat}</div>
                    </div>
                    <div class="info-box">
                        <div class="info-box-label">Cluster</div>
                        <div class="info-box-value">#${file.cluster ?? '—'}</div>
                    </div>
                    <div class="info-box">
                        <div class="info-box-label">Importance</div>
                        <div class="info-box-value">${file.importance ? (file.importance * 100).toFixed(0) + '%' : '—'}</div>
                    </div>
                    <div class="info-box">
                        <div class="info-box-label">Cluster Label</div>
                        <div class="info-box-value">${clusterLabel || '—'}</div>
                    </div>
                </div>
            `;
            
            const clusterMeta = state.data?.clusterMeta?.[String(file.cluster ?? '')];
            if (clusterMeta) {
                const clusterCats = (clusterMeta.topCategories || []).slice(0, 4);
                const clusterKeywords = (clusterMeta.topKeywords || []).slice(0, 10);
                // Colony info (catastrophe theory)
                const colonyName = clusterMeta.colony || '';
                const colonySymbol = clusterMeta.symbol || '';
                const catastrophe = clusterMeta.catastrophe || '';
                const role = clusterMeta.role || '';
                
                html += `
                    <div class="section-title">${colonySymbol ? colonySymbol + ' ' : ''}Colony${colonyName ? ': ' + escapeHtml(colonyName) : ''}</div>
                    ${catastrophe || role ? `
                        <div class="panel-colony-info" style="font-size: 11px; color: var(--text-dim); margin-bottom: 8px;">
                            ${role ? `<span style="color: var(--accent-primary)">${escapeHtml(role)}</span>` : ''}
                            ${role && catastrophe ? ' · ' : ''}
                            ${catastrophe ? `<span>${escapeHtml(catastrophe)}</span>` : ''}
                        </div>
                    ` : ''}
                    ${clusterCats.length ? `
                        <div class="panel-tags">
                            ${clusterCats.map(([catName]) => `<span class="panel-badge" style="border-color:${getColor(catName)}55;color:${getColor(catName)}">${escapeHtml(catName)}</span>`).join('')}
                        </div>
                    ` : ''}
                    ${clusterKeywords.length ? `
                        <div class="panel-tags" style="margin-top: 8px;">
                            ${clusterKeywords.map(k => `<span class="panel-tag">${escapeHtml(k)}</span>`).join('')}
                        </div>
                    ` : ''}
                `;
            }
            
            if (file.summary) {
                html += `
                    <div class="section-title">Summary</div>
                    <div class="panel-summary">${escapeHtml(file.summary)}</div>
                `;
            }
            
            // Docstring
            if (file.docstring) {
                html += `
                    <div class="section-title">Documentation</div>
                    <div class="panel-doc">${escapeHtml(file.docstring)}</div>
                `;
            }
            
            // Functions
            if (funcs.length > 0) {
                html += `
                    <div class="section-title">Functions <span class="section-count">${funcs.length}</span></div>
                    <div class="panel-list">
                        ${funcs.slice(0, 15).map(f => `<code class="panel-code">${escapeHtml(f)}()</code>`).join('')}
                        ${funcs.length > 15 ? `<span class="panel-more">+${funcs.length - 15} more</span>` : ''}
                    </div>
                `;
            }
            
            // Classes
            if (classes.length > 0) {
                html += `
                    <div class="section-title">Classes <span class="section-count">${classes.length}</span></div>
                    <div class="panel-list">
                        ${classes.map(c => `<code class="panel-code panel-class">${escapeHtml(c)}</code>`).join('')}
                    </div>
                `;
            }
            
            // Keywords
            if (keywords.length > 0) {
                html += `
                    <div class="section-title">Keywords</div>
                    <div class="panel-tags">
                        ${keywords.slice(0, 12).map(k => `<span class="panel-tag">${escapeHtml(k)}</span>`).join('')}
                    </div>
                `;
            }
            
            const concepts = file.concepts || [];
            if (concepts.length > 0) {
                html += `
                    <div class="section-title">Concepts</div>
                    <div class="panel-tags">
                        ${concepts.slice(0, 10).map(k => `<span class="panel-tag">${escapeHtml(k)}</span>`).join('')}
                    </div>
                `;
            }
            
            const exportsList = file.exports || [];
            if (exportsList.length > 0) {
                html += `
                    <div class="section-title">Exports <span class="section-count">${exportsList.length}</span></div>
                    <div class="panel-list">
                        ${exportsList.slice(0, 12).map(e => `<code class="panel-code">${escapeHtml(e)}</code>`).join('')}
                        ${exportsList.length > 12 ? `<span class="panel-more">+${exportsList.length - 12} more</span>` : ''}
                    </div>
                `;
            }
            
            // Imports (Dependency Graph)
            if (imports.length > 0) {
                html += `
                    <div class="section-title">Imports <span class="section-count">${imports.length}</span></div>
                    <div class="panel-deps">
                        ${imports.slice(0, 10).map(imp => {
                            const short = imp.split('/').pop();
                            const targetFile = state.files.find(f => 
                                f.path === imp || 
                                f.path.endsWith('/' + imp) ||
                                f.name === short
                            );
                            const exists = !!targetFile;
                            return `
                                <div class="panel-dep ${exists ? 'clickable' : ''}" ${exists ? `data-path="${targetFile.path}"` : ''}>
                                    <span class="dep-arrow">→</span>
                                    <span class="dep-name">${escapeHtml(short)}</span>
                                    ${exists ? `<span class="dep-badge" style="background:${getColor(targetFile.category)}40;color:${getColor(targetFile.category)}">${targetFile.category}</span>` : ''}
                                </div>
                            `;
                        }).join('')}
                        ${imports.length > 10 ? `<div class="panel-more">+${imports.length - 10} more imports</div>` : ''}
                    </div>
                `;
            }
            
            // Imported By (Reverse Dependencies)
            if (importedBy.length > 0) {
                html += `
                    <div class="section-title">Imported By <span class="section-count">${importedBy.length}</span></div>
                    <div class="panel-deps">
                        ${importedBy.slice(0, 8).map(imp => {
                            const sourceFile = state.files.find(f => f.path === imp);
                            const short = imp.split('/').pop();
                            return sourceFile ? `
                                <div class="panel-dep clickable" data-path="${sourceFile.path}">
                                    <span class="dep-arrow">←</span>
                                    <span class="dep-name">${escapeHtml(short)}</span>
                                    <span class="dep-badge" style="background:${getColor(sourceFile.category)}40;color:${getColor(sourceFile.category)}">${sourceFile.category}</span>
                                </div>
                            ` : '';
                        }).join('')}
                        ${importedBy.length > 8 ? `<div class="panel-more">+${importedBy.length - 8} more dependents</div>` : ''}
                    </div>
                `;
            }
            
            // Similar Files (by semantic proximity)
            if (similar.length > 0) {
                html += `
                    <div class="section-title">Semantically Similar</div>
                    ${similar.map(s => {
                        const dist = Math.sqrt(
                            (s.x - file.x) ** 2 + (s.y - file.y) ** 2 + (s.z - file.z) ** 2
                        );
                        const score = Math.max(0, Math.round((1 - dist) * 100));
                        const sc = COLORS[s.category] || COLORS.Other;
                        return `
                            <div class="similar-item" data-path="${s.path}">
                                <div class="similar-score">${score}</div>
                                <div class="similar-info">
                                    <div class="similar-name">${escapeHtml(s.name || s.path.split('/').pop())}</div>
                                    <div class="similar-cat" style="color:${sc.hex}">${s.category || 'Other'}</div>
                                </div>
                            </div>
                        `;
                    }).join('')}
                `;
            }
            
            // Action buttons
            html += `
                <div class="panel-actions">
                    <button class="panel-btn panel-btn-secondary" data-action="copy">
                        Copy Path
                    </button>
                    <button class="panel-btn panel-btn-primary" data-action="explore">
                        🚀 Explore in 3D
                    </button>
                </div>
            `;
            
            document.getElementById('panel-content').innerHTML = html;
            
            // Event listeners for clickable elements
            document.querySelectorAll('.similar-item, .panel-dep.clickable').forEach(el => {
                el.addEventListener('click', () => {
                    const f = state.files.find(f => f.path === el.dataset.path);
                    if (f) selectFile(f);
                });
            });
            
            // Explore in 3D button
            document.querySelector('.panel-btn[data-action="explore"]')?.addEventListener('click', () => {
                transitionToFile(file);
            });
            
            document.querySelector('.panel-btn[data-action="copy"]')?.addEventListener('click', () => {
                copyToClipboard(file.path || '');
            });
            
            document.getElementById('panel').classList.add('open');
        }
        
        function closePanel() {
            document.getElementById('panel').classList.remove('open');
            state.treemap.selected = null;
            state.semantic.selected = null;
            state.semantic.related = [];
        }
        
        // ═══════════════════════════════════════════════════════════════════════════════
        // UTILITIES
        // ═══════════════════════════════════════════════════════════════════════════════
        
        function formatNum(n) {
            if (n >= 1000000) return (n / 1000000).toFixed(1) + 'M';
            if (n >= 1000) return (n / 1000).toFixed(1) + 'K';
            return new Intl.NumberFormat().format(n);
        }
        
        function formatRelativeTime(iso) {
            const t = new Date(iso);
            if (Number.isNaN(t.getTime())) return '—';
            const diff = Date.now() - t.getTime();
            const mins = Math.floor(diff / 60000);
            if (mins < 1) return 'just now';
            if (mins < 60) return `${mins}m ago`;
            const hours = Math.floor(mins / 60);
            if (hours < 24) return `${hours}h ago`;
            const days = Math.floor(hours / 24);
            return `${days}d ago`;
        }
        
        function truncate(text, maxLen) {
            if (!text) return '';
            const clean = String(text).trim();
            return clean.length > maxLen ? clean.slice(0, maxLen).trim() + '…' : clean;
        }
        
        function showToast(message) {
            const toast = document.getElementById('toast');
            if (!toast) return;
            toast.textContent = message;
            toast.classList.add('show');
            clearTimeout(showToast._t);
            showToast._t = setTimeout(() => toast.classList.remove('show'), 1400);
        }
        
        async function copyToClipboard(text) {
            if (!text) return;
            try {
                if (navigator.clipboard?.writeText) {
                    await navigator.clipboard.writeText(text);
                } else {
                    const input = document.createElement('textarea');
                    input.value = text;
                    input.style.position = 'fixed';
                    input.style.left = '-9999px';
                    document.body.appendChild(input);
                    input.select();
                    document.execCommand('copy');
                    document.body.removeChild(input);
                }
                showToast('✓ Path copied');
            } catch (err) {
                showToast('Copy failed');
            }
        }
        
        function updateQuality(frameMs) {
            const prev = state.semantic.frameMsAvg || frameMs;
            const avg = prev * 0.85 + frameMs * 0.15;
            state.semantic.frameMsAvg = avg;
            
            if (avg > 28) state.semantic.quality = 'low';
            else if (avg > 18) state.semantic.quality = 'med';
            else state.semantic.quality = 'high';
        }
        
        function debounce(fn, ms) {
            let t;
            return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); };
        }
        
        function escapeHtml(str) {
            return String(str).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
        }
        
        function escapeRegex(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }
        
        function getCategoryIcon(cat) {
            const icons = {
                Python: '🐍', JavaScript: '📜', TypeScript: '💠', Rust: '🦀',
                Swift: '🍎', Kotlin: '🎯', React: '⚛️', Web: '🌐', Go: '🔷',
                Test: '🧪', Config: '⚙️', Docs: '📚', Service: '🔧', Java: '☕',
                API: '🔌', Model: '📊', Utility: '🛠️', Style: '🎨', C: '⚡',
                Shell: '💻', Security: '🔐', Database: '🗃️', Core: '💎',
                Folder: '📁', Other: '📄'
            };
            return icons[cat] || '📄';
        }
        
        function getClusterLabel(clusterId) {
            if (clusterId === undefined || clusterId === null) return '';
            const meta = state.data?.clusterMeta?.[String(clusterId)];
            if (!meta) return '';
            // Use colony name/symbol if available (new format)
            if (meta.colony && meta.symbol) {
                return `${meta.symbol} ${meta.colony}`;
            }
            // Fallback to keywords (old format)
            if (meta.topKeywords) {
                return meta.topKeywords.slice(0, 2).join(' · ');
            }
            return '';
        }
        
        // Service worker registration for PWA
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js').catch(() => {});
        }
        
        // Start
        init();
    </script>
</body>
</html>
