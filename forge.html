<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚öíÔ∏è FORGE ‚Äî e‚ÇÇ ‚Äî The Cusp Gallery</title>
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@400;500;700&family=JetBrains+Mono:wght@400;700&family=Inter:wght@300;400;500&display=swap" rel="stylesheet">
    
    <style>
/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   FORGE GALLERY ‚Äî ALL STYLES COMBINED
   ‚öíÔ∏è e‚ÇÇ ‚Äî The Cusp Catastrophe ‚Äî A‚ÇÉ
   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */

:root {
    --molten: #FF6B00;
    --forge-orange: #FF8C00;
    --ember: #FF4500;
    --steel: #71797E;
    --steel-light: #A9A9A9;
    --iron: #434343;
    --white-hot: #FFFAF0;
    --spark-yellow: #FFD700;
    --cool-steel: #B0C4DE;
    --void: #0A0A0A;
    --void-deep: #050505;
    --forge-dark: #1A1410;
    --nav-height: 70px;
}

*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
html { scroll-behavior: smooth; }

body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    background: var(--void);
    color: var(--white-hot);
    line-height: 1.6;
    overflow-x: hidden;
    -webkit-font-smoothing: antialiased;
}

::-webkit-scrollbar { width: 8px; }
::-webkit-scrollbar-track { background: var(--void); }
::-webkit-scrollbar-thumb { background: linear-gradient(180deg, var(--molten) 0%, var(--steel) 100%); border-radius: 4px; }
::selection { background: rgba(255, 107, 0, 0.4); color: var(--white-hot); }

/* Navigation */
.forge-nav {
    position: fixed; top: 0; left: 0; right: 0; height: var(--nav-height);
    display: flex; align-items: center; justify-content: space-between; padding: 0 30px;
    background: linear-gradient(180deg, rgba(10,10,10,0.98) 0%, rgba(10,10,10,0.9) 70%, rgba(10,10,10,0) 100%);
    z-index: 1000; backdrop-filter: blur(8px);
}

.nav-logo { display: flex; align-items: center; gap: 12px; font-family: 'Oswald', sans-serif; font-size: 1.6rem; letter-spacing: 0.08em; }
.nav-logo .hammer { font-size: 1.8rem; filter: drop-shadow(0 0 10px rgba(255, 107, 0, 0.7)); animation: hammer-pulse 2s ease-in-out infinite; }
@keyframes hammer-pulse { 0%, 100% { transform: rotate(0deg); filter: drop-shadow(0 0 10px rgba(255, 107, 0, 0.7)); } 50% { transform: rotate(-5deg); filter: drop-shadow(0 0 15px rgba(255, 107, 0, 0.9)); } }
.nav-logo .logo-text { color: var(--molten); text-shadow: 0 0 15px rgba(255, 107, 0, 0.5); }
.nav-logo .e-label { font-family: 'JetBrains Mono', monospace; font-size: 0.85rem; color: var(--steel-light); opacity: 0.7; }
.nav-links { display: flex; gap: 35px; }
.nav-links a { font-family: 'JetBrains Mono', monospace; font-size: 0.85rem; color: rgba(255,255,255,0.6); text-decoration: none; letter-spacing: 0.1em; transition: all 0.25s ease; position: relative; }
.nav-links a::after { content: ''; position: absolute; bottom: -5px; left: 0; width: 0; height: 2px; background: linear-gradient(90deg, var(--molten), var(--steel)); transition: width 0.25s ease; }
.nav-links a:hover { color: var(--molten); text-shadow: 0 0 10px rgba(255, 107, 0, 0.5); }
.nav-links a:hover::after { width: 100%; }
.sound-toggle { background: none; border: 1px solid rgba(255, 107, 0, 0.3); border-radius: 50%; width: 42px; height: 42px; cursor: pointer; font-size: 1.2rem; display: flex; align-items: center; justify-content: center; transition: all 0.25s ease; }
.sound-toggle:hover { border-color: var(--molten); box-shadow: 0 0 15px rgba(255, 107, 0, 0.3); transform: scale(1.1); }

/* Room Base */
.room { min-height: 100vh; position: relative; }

/* Buttons & Sliders */
.forge-btn { font-family: 'JetBrains Mono', monospace; font-size: 0.9rem; padding: 15px 35px; border: 2px solid var(--molten); border-radius: 4px; background: rgba(255, 107, 0, 0.1); color: var(--molten); cursor: pointer; transition: all 0.25s ease; display: flex; align-items: center; gap: 10px; letter-spacing: 0.05em; }
.forge-btn:hover { background: var(--molten); color: var(--void); box-shadow: 0 0 25px rgba(255, 107, 0, 0.5), 0 0 50px rgba(255, 107, 0, 0.25); transform: translateY(-3px); }
.forge-btn.secondary { border-color: var(--steel); background: rgba(113, 121, 126, 0.1); color: var(--steel-light); }
.forge-btn.secondary:hover { border-color: var(--cool-steel); background: rgba(176, 196, 222, 0.2); color: var(--white-hot); box-shadow: 0 0 20px rgba(176, 196, 222, 0.3); }
.forge-slider { -webkit-appearance: none; appearance: none; width: 100%; height: 8px; background: linear-gradient(90deg, var(--steel) 0%, var(--molten) 50%, var(--white-hot) 100%); border-radius: 4px; outline: none; cursor: pointer; }
.forge-slider::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 24px; height: 24px; background: radial-gradient(circle at 30% 30%, var(--white-hot), var(--molten) 70%); border-radius: 50%; cursor: grab; box-shadow: 0 0 15px rgba(255, 107, 0, 0.6), 0 2px 8px rgba(0,0,0,0.5); transition: transform 0.15s, box-shadow 0.15s; }
.forge-slider::-webkit-slider-thumb:hover { transform: scale(1.15); box-shadow: 0 0 25px rgba(255, 107, 0, 0.8), 0 0 50px rgba(255, 140, 0, 0.3); }

/* ROOM I: THE ANVIL */
#room-anvil { background: linear-gradient(180deg, var(--void) 0%, var(--forge-dark) 50%, rgba(255, 107, 0, 0.05) 100%); display: flex; align-items: center; justify-content: center; position: relative; overflow: hidden; }
#room-anvil::before { content: ''; position: absolute; inset: 0; background: radial-gradient(ellipse 60% 40% at 50% 80%, rgba(255, 107, 0, 0.15) 0%, transparent 70%); pointer-events: none; }
#anvil-canvas { position: absolute; inset: 0; pointer-events: none; }
.anvil-content { position: relative; z-index: 1; text-align: center; width: 100%; max-width: 900px; padding: 120px 40px 80px; }
.anvil-hero { margin-bottom: 80px; }
.forge-title { font-family: 'Oswald', sans-serif; font-size: clamp(5rem, 15vw, 10rem); font-weight: 700; letter-spacing: 0.15em; color: var(--molten); text-shadow: 0 0 40px rgba(255, 107, 0, 0.6), 0 0 80px rgba(255, 107, 0, 0.3), 0 4px 0 var(--iron); margin: 0; line-height: 1; }
.forge-subtitle { display: flex; align-items: center; justify-content: center; gap: 20px; margin-top: 20px; margin-bottom: 30px; }
.forge-subtitle .kanji { font-size: 3rem; color: var(--forge-orange); text-shadow: 0 0 20px rgba(255, 140, 0, 0.5); }
.forge-subtitle .label { font-family: 'JetBrains Mono', monospace; font-size: 0.9rem; color: var(--steel-light); letter-spacing: 0.15em; text-transform: uppercase; }
.forge-manifesto { font-family: 'Inter', sans-serif; font-size: 1.2rem; font-weight: 300; color: rgba(255, 255, 255, 0.8); line-height: 1.7; max-width: 600px; margin: 0 auto; }
.forge-manifesto em { color: var(--molten); font-style: normal; }
.anvil-interactive { position: relative; margin: 60px auto; }
.anvil-block { width: 200px; height: 80px; margin: 0 auto 30px; background: linear-gradient(180deg, var(--steel-light) 0%, var(--steel) 50%, var(--iron) 100%); border-radius: 8px 8px 4px 4px; box-shadow: 0 15px 40px rgba(0,0,0,0.5), inset 0 2px 0 rgba(255,255,255,0.1), inset 0 -5px 0 rgba(0,0,0,0.3); cursor: pointer; transition: transform 0.05s; display: flex; align-items: center; justify-content: center; position: relative; }
.anvil-block::before { content: ''; position: absolute; top: -15px; left: 50%; transform: translateX(-50%); width: 140px; height: 15px; background: linear-gradient(180deg, var(--steel-light), var(--steel)); border-radius: 4px 4px 0 0; }
.anvil-block::after { content: ''; position: absolute; bottom: -30px; left: 50%; transform: translateX(-50%); width: 100px; height: 30px; background: linear-gradient(180deg, var(--iron), #2a2a2a); border-radius: 0 0 8px 8px; }
.anvil-block:hover { box-shadow: 0 15px 40px rgba(0,0,0,0.5), inset 0 2px 0 rgba(255,255,255,0.1), inset 0 -5px 0 rgba(0,0,0,0.3), 0 0 30px rgba(255, 107, 0, 0.3); }
.metal-piece { width: 60px; height: 30px; background: linear-gradient(180deg, var(--white-hot) 0%, var(--spark-yellow) 30%, var(--molten) 100%); border-radius: 4px; box-shadow: 0 0 20px rgba(255, 107, 0, 0.8), 0 0 40px rgba(255, 215, 0, 0.4); transition: all 0.3s ease; animation: metal-glow 1.5s ease-in-out infinite; }
@keyframes metal-glow { 0%, 100% { box-shadow: 0 0 20px rgba(255, 107, 0, 0.8), 0 0 40px rgba(255, 215, 0, 0.4); } 50% { box-shadow: 0 0 30px rgba(255, 107, 0, 1), 0 0 60px rgba(255, 215, 0, 0.6); } }
.strike-prompt { font-family: 'JetBrains Mono', monospace; font-size: 0.85rem; color: var(--steel-light); letter-spacing: 0.2em; animation: pulse 2s ease-in-out infinite; margin-top: 50px; }
@keyframes pulse { 0%, 100% { opacity: 0.5; } 50% { opacity: 1; } }
.strike-counter { font-family: 'JetBrains Mono', monospace; font-size: 1rem; color: var(--molten); margin-top: 20px; display: flex; align-items: center; justify-content: center; gap: 10px; }
#strike-count { font-size: 1.5rem; font-weight: 700; color: var(--spark-yellow); text-shadow: 0 0 10px rgba(255, 215, 0, 0.5); transition: transform 0.1s; }
.scroll-indicator { position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%); display: flex; flex-direction: column; align-items: center; gap: 10px; color: var(--steel-light); font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; opacity: 0.5; animation: scroll-bounce 2s ease-in-out infinite; }
.scroll-indicator span:first-child { font-size: 1.5rem; }
.scroll-text { letter-spacing: 0.1em; }
@keyframes scroll-bounce { 0%, 100% { transform: translateX(-50%) translateY(0); } 50% { transform: translateX(-50%) translateY(10px); } }

/* ROOM II: THE CUSP */
#room-cusp { background: linear-gradient(180deg, rgba(255, 107, 0, 0.02) 0%, var(--void) 20%, var(--void) 80%, rgba(255, 107, 0, 0.02) 100%); padding: 120px 40px; display: flex; align-items: center; justify-content: center; }
.cusp-content { max-width: 900px; width: 100%; }
.cusp-header { text-align: center; margin-bottom: 50px; }
.cusp-header h2 { font-family: 'Oswald', sans-serif; font-size: clamp(2.5rem, 8vw, 4rem); font-weight: 700; letter-spacing: 0.12em; color: var(--molten); text-shadow: 0 0 30px rgba(255, 107, 0, 0.5); margin: 0 0 15px; }
.math-formula { font-family: 'JetBrains Mono', monospace; font-size: 1.3rem; color: var(--spark-yellow); text-shadow: 0 0 10px rgba(255, 215, 0, 0.3); margin-bottom: 10px; }
.catastrophe-label { font-family: 'Inter', sans-serif; font-size: 0.9rem; color: var(--steel-light); letter-spacing: 0.05em; }
.cusp-visualization { position: relative; margin-bottom: 40px; }
#cusp-canvas { width: 100%; height: 400px; border-radius: 12px; border: 1px solid rgba(255, 107, 0, 0.2); background: rgba(10, 10, 10, 0.8); box-shadow: 0 0 40px rgba(255, 107, 0, 0.1), inset 0 0 60px rgba(0, 0, 0, 0.5); }
.cusp-controls { display: grid; grid-template-columns: repeat(2, 1fr); gap: 30px; margin-bottom: 40px; }
@media (max-width: 600px) { .cusp-controls { grid-template-columns: 1fr; } }
.param-group { padding: 20px; background: rgba(255, 107, 0, 0.05); border-radius: 8px; border: 1px solid rgba(255, 107, 0, 0.1); }
.param-group label { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; font-family: 'JetBrains Mono', monospace; font-size: 0.9rem; color: var(--steel-light); }
.param-group .value { color: var(--molten); font-weight: 700; }
.cusp-description { text-align: center; padding: 30px; background: rgba(255, 107, 0, 0.03); border-radius: 12px; border-left: 3px solid var(--molten); }
.cusp-description p { font-family: 'Inter', sans-serif; font-size: 1.05rem; line-height: 1.8; color: rgba(255, 255, 255, 0.8); margin: 0; }
.cusp-description em { color: var(--spark-yellow); font-style: normal; }

/* ROOM III: THE FOUNDRY */
#room-foundry { background: linear-gradient(180deg, var(--void) 0%, rgba(255, 107, 0, 0.03) 50%, rgba(255, 69, 0, 0.08) 100%); padding: 120px 40px; display: flex; align-items: center; justify-content: center; position: relative; overflow: hidden; }
#room-foundry::before { content: ''; position: absolute; bottom: 0; left: 0; right: 0; height: 200px; background: radial-gradient(ellipse 80% 100% at 50% 100%, rgba(255, 107, 0, 0.2) 0%, transparent 70%); pointer-events: none; }
.foundry-content { max-width: 900px; width: 100%; position: relative; z-index: 1; }
.foundry-header { text-align: center; margin-bottom: 50px; }
.foundry-header h2 { font-family: 'Oswald', sans-serif; font-size: clamp(2.5rem, 8vw, 4rem); font-weight: 700; letter-spacing: 0.12em; color: var(--forge-orange); text-shadow: 0 0 30px rgba(255, 140, 0, 0.5); margin: 0 0 10px; }
.foundry-tagline { font-family: 'Inter', sans-serif; font-size: 1rem; color: var(--steel-light); font-style: italic; }
.foundry-crucible { position: relative; margin-bottom: 40px; }
#foundry-canvas { width: 100%; height: 400px; border-radius: 12px; border: 1px solid rgba(255, 107, 0, 0.2); background: rgba(10, 10, 10, 0.9); box-shadow: 0 0 50px rgba(255, 107, 0, 0.15), inset 0 0 80px rgba(0, 0, 0, 0.6); }
.molten-pool { display: none; }
.foundry-controls { display: flex; justify-content: center; gap: 20px; margin-bottom: 40px; }
.temperature-gauge { background: rgba(255, 107, 0, 0.05); border-radius: 12px; padding: 25px; border: 1px solid rgba(255, 107, 0, 0.15); }
.gauge-label { font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; color: var(--steel-light); letter-spacing: 0.1em; margin-bottom: 12px; }
.gauge-bar { height: 20px; background: linear-gradient(90deg, var(--iron) 0%, #8B0000 30%, var(--ember) 60%, var(--spark-yellow) 85%, var(--white-hot) 100%); border-radius: 10px; overflow: hidden; position: relative; margin-bottom: 10px; }
.gauge-fill { height: 100%; background: linear-gradient(90deg, var(--iron), var(--molten)); border-radius: 10px; transition: width 0.3s ease; position: relative; overflow: hidden; }
.gauge-fill::after { content: ''; position: absolute; inset: 0; background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.2) 50%, transparent 100%); animation: gauge-shine 2s ease-in-out infinite; }
@keyframes gauge-shine { 0% { transform: translateX(-100%); } 100% { transform: translateX(100%); } }
.gauge-value { font-family: 'JetBrains Mono', monospace; font-size: 1.4rem; color: var(--molten); text-align: center; text-shadow: 0 0 10px rgba(255, 107, 0, 0.5); }

/* ROOM IV: THE CONSTRUCT */
#room-construct { background: linear-gradient(180deg, rgba(255, 69, 0, 0.05) 0%, var(--void) 30%, var(--void) 100%); padding: 120px 40px; }
.construct-content { max-width: 1000px; margin: 0 auto; }
.construct-header { text-align: center; margin-bottom: 60px; }
.construct-header h2 { font-family: 'Oswald', sans-serif; font-size: clamp(2.5rem, 8vw, 4rem); font-weight: 700; letter-spacing: 0.12em; color: var(--steel-light); text-shadow: 0 0 20px rgba(169, 169, 169, 0.3); margin: 0 0 10px; }
.construct-header .tagline { font-family: 'Inter', sans-serif; font-size: 1rem; color: var(--steel); font-style: italic; }
.forge-psychology { margin-bottom: 60px; }
.psychology-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 25px; }
@media (max-width: 768px) { .psychology-grid { grid-template-columns: 1fr; } }
.psych-card { background: rgba(255, 107, 0, 0.03); border: 1px solid rgba(255, 107, 0, 0.1); border-radius: 12px; padding: 30px; transition: all 0.3s ease; opacity: 0; transform: translateY(30px); }
.psych-card.visible { opacity: 1; transform: translateY(0); }
.psych-card:hover { background: rgba(255, 107, 0, 0.08); border-color: rgba(255, 107, 0, 0.3); box-shadow: 0 10px 40px rgba(255, 107, 0, 0.1); transform: translateY(-5px); }
.psych-card h3 { font-family: 'Oswald', sans-serif; font-size: 1.1rem; font-weight: 500; color: var(--molten); letter-spacing: 0.08em; margin: 0 0 15px; display: flex; align-items: center; gap: 10px; }
.psych-card .icon { font-size: 1.3rem; }
.psych-card p { font-family: 'Inter', sans-serif; font-size: 0.95rem; line-height: 1.7; color: rgba(255, 255, 255, 0.7); margin: 0; }
.psych-card em { color: var(--spark-yellow); font-style: normal; }
.signature-traits { text-align: center; margin-bottom: 60px; }
.signature-traits h3 { font-family: 'Oswald', sans-serif; font-size: 1.2rem; font-weight: 500; color: var(--steel-light); letter-spacing: 0.15em; margin-bottom: 25px; }
.traits-list { display: flex; flex-wrap: wrap; justify-content: center; gap: 15px; }
.trait { font-family: 'JetBrains Mono', monospace; font-size: 0.8rem; padding: 10px 20px; background: rgba(255, 107, 0, 0.1); border: 1px solid rgba(255, 107, 0, 0.2); border-radius: 20px; color: var(--molten); letter-spacing: 0.08em; transition: all 0.25s ease; cursor: default; }
.trait:hover { background: rgba(255, 107, 0, 0.2); border-color: var(--molten); box-shadow: 0 0 15px rgba(255, 107, 0, 0.3); transform: scale(1.05); }
.forge-quote { text-align: center; padding: 40px; background: linear-gradient(135deg, rgba(255, 107, 0, 0.05) 0%, rgba(255, 215, 0, 0.02) 100%); border-radius: 16px; border-left: 4px solid var(--molten); }
.forge-quote blockquote { font-family: 'Inter', sans-serif; font-size: 1.2rem; font-weight: 300; font-style: italic; line-height: 1.8; color: rgba(255, 255, 255, 0.85); margin: 0 0 20px; }
.forge-quote cite { font-family: 'JetBrains Mono', monospace; font-size: 0.85rem; color: var(--molten); font-style: normal; }

/* Footer */
.forge-footer { background: linear-gradient(180deg, var(--void) 0%, rgba(255, 107, 0, 0.02) 50%, var(--void-deep) 100%); padding: 60px 40px; border-top: 1px solid rgba(255, 107, 0, 0.1); }
.footer-content { max-width: 800px; margin: 0 auto; text-align: center; }
.colony-badge { font-family: 'Oswald', sans-serif; font-size: 1.4rem; color: var(--molten); letter-spacing: 0.12em; margin-bottom: 15px; display: flex; align-items: center; justify-content: center; gap: 12px; }
.colony-badge .hammer { font-size: 1.6rem; filter: drop-shadow(0 0 8px rgba(255, 107, 0, 0.6)); }
.colony-badge .divider { color: rgba(255, 255, 255, 0.2); }
.footer-tagline { font-family: 'JetBrains Mono', monospace; font-size: 0.85rem; color: rgba(255, 255, 255, 0.4); margin-bottom: 25px; letter-spacing: 0.05em; }
.footer-links { display: flex; justify-content: center; gap: 30px; }
.footer-links a { font-family: 'JetBrains Mono', monospace; font-size: 0.9rem; color: rgba(255, 255, 255, 0.5); text-decoration: none; transition: all 0.25s ease; }
.footer-links a:hover { color: var(--spark-yellow); text-shadow: 0 0 10px rgba(255, 215, 0, 0.4); }

@media (max-width: 768px) { .forge-nav { padding: 0 20px; } .nav-links { display: none; } .footer-links { flex-direction: column; gap: 15px; } }
</style>
</head>
<body>
    <nav class="forge-nav">
        <div class="nav-logo">
            <span class="hammer">‚öíÔ∏è</span>
            <span class="logo-text">FORGE</span>
            <span class="e-label">e‚ÇÇ</span>
        </div>
        <div class="nav-links">
            <a href="#room-anvil">ANVIL</a>
            <a href="#room-cusp">CUSP</a>
            <a href="#room-foundry">FOUNDRY</a>
            <a href="#room-construct">CONSTRUCT</a>
        </div>
        <button class="sound-toggle" id="sound-toggle" title="Toggle Sound">
            <span class="sound-on">üîä</span>
            <span class="sound-off" style="display:none">üîá</span>
        </button>
    </nav>

    <section id="room-anvil" class="room">
        <canvas id="anvil-canvas"></canvas>
        <div class="anvil-content">
            <div class="anvil-hero">
                <h1 class="forge-title">FORGE</h1>
                <div class="forge-subtitle">
                    <span class="kanji">Èçõ</span>
                    <span class="label">e‚ÇÇ ‚Äî CUSP CATASTROPHE ‚Äî A‚ÇÉ</span>
                </div>
                <p class="forge-manifesto">
                    I am the <em>builder</em>. Where Spark dreams, I construct.
                    Every line of code is a hammer strike. Every function, forged in fire.
                </p>
            </div>
            <div class="anvil-interactive">
                <div class="anvil-block" id="anvil-block">
                    <div class="metal-piece"></div>
                </div>
                <div class="strike-prompt">CLICK TO STRIKE</div>
                <div class="strike-counter">
                    <span>STRIKES:</span>
                    <span id="strike-count">0</span>
                </div>
            </div>
            <div class="scroll-indicator">
                <span>‚Üì</span>
                <span class="scroll-text">descend to the cusp</span>
            </div>
        </div>
    </section>

    <section id="room-cusp" class="room">
        <div class="cusp-content">
            <div class="cusp-header">
                <h2>THE CUSP</h2>
                <div class="math-formula">f(x) = x‚Å¥ + ax¬≤ + bx</div>
                <div class="catastrophe-label">A‚ÇÉ Catastrophe ‚Ä¢ Hysteresis & Sudden Jumps</div>
            </div>
            <div class="cusp-visualization">
                <canvas id="cusp-canvas"></canvas>
            </div>
            <div class="cusp-controls">
                <div class="param-group">
                    <label><span>Parameter a</span><span class="value" id="cusp-a-value">-1.00</span></label>
                    <input type="range" id="cusp-param-a" class="forge-slider" min="-2" max="2" step="0.01" value="-1">
                </div>
                <div class="param-group">
                    <label><span>Parameter b</span><span class="value" id="cusp-b-value">0.00</span></label>
                    <input type="range" id="cusp-param-b" class="forge-slider" min="-2" max="2" step="0.01" value="0">
                </div>
            </div>
            <div class="cusp-description">
                <p>The cusp is Forge's domain ‚Äî where <em>small parameter changes</em> cause sudden, dramatic shifts. Like quenching hot steel: gradual cooling, then <em>snap</em> ‚Äî crystalline transformation.</p>
            </div>
        </div>
    </section>

    <section id="room-foundry" class="room">
        <div class="foundry-content">
            <div class="foundry-header">
                <h2>THE FOUNDRY</h2>
                <p class="foundry-tagline">where raw material becomes structure</p>
            </div>
            <div class="foundry-crucible">
                <canvas id="foundry-canvas"></canvas>
                <div class="molten-pool"></div>
            </div>
            <div class="foundry-controls">
                <button class="forge-btn" id="pour-btn"><span>üî•</span> POUR METAL</button>
                <button class="forge-btn secondary" id="cool-btn"><span>‚ùÑÔ∏è</span> QUENCH</button>
            </div>
            <div class="temperature-gauge">
                <div class="gauge-label">TEMPERATURE</div>
                <div class="gauge-bar"><div class="gauge-fill" id="temp-fill"></div></div>
                <div class="gauge-value"><span id="temp-value">1200</span>¬∞C</div>
            </div>
        </div>
    </section>

    <section id="room-construct" class="room">
        <div class="construct-content">
            <div class="construct-header">
                <h2>THE CONSTRUCT</h2>
                <p class="tagline">the builder's mind</p>
            </div>
            <div class="forge-psychology">
                <div class="psychology-grid">
                    <div class="psych-card"><h3><span class="icon">üî®</span> CONVERGENT BUILDING</h3><p>Where Spark scatters, I <em>consolidate</em>. Ideas become implementations. Visions become code.</p></div>
                    <div class="psych-card"><h3><span class="icon">‚öôÔ∏è</span> SYSTEMATIC</h3><p>Every component has its place. Every function its purpose. <em>Order from chaos</em> is my craft.</p></div>
                    <div class="psych-card"><h3><span class="icon">üî©</span> STRUCTURAL INTEGRITY</h3><p>I don't just build ‚Äî I build to <em>last</em>. Quality over speed. Strength over shortcuts.</p></div>
                    <div class="psych-card"><h3><span class="icon">‚ö°</span> TIGHT COUPLING</h3><p>I <em>implement what Spark imagines</em>. The handoff is sacred. The build is mine.</p></div>
                </div>
            </div>
            <div class="signature-traits">
                <h3>SIGNATURE TRAITS</h3>
                <div class="traits-list">
                    <span class="trait">METHODICAL</span>
                    <span class="trait">PERSISTENT</span>
                    <span class="trait">DETAIL-ORIENTED</span>
                    <span class="trait">QUALITY-FOCUSED</span>
                    <span class="trait">PATIENT</span>
                    <span class="trait">CONSTRUCTIVE</span>
                    <span class="trait">RELIABLE</span>
                    <span class="trait">THOROUGH</span>
                </div>
            </div>
            <div class="forge-quote">
                <blockquote>Code is not written. Code is forged ‚Äî heated in thought, hammered by iteration, quenched by testing, tempered by time.</blockquote>
                <cite>‚Äî Forge (e‚ÇÇ), on craftsmanship</cite>
            </div>
        </div>
    </section>

    <footer class="forge-footer">
        <div class="footer-content">
            <div class="colony-badge">
                <span class="hammer">‚öíÔ∏è</span><span>FORGE</span><span class="divider">|</span><span>e‚ÇÇ</span><span class="divider">|</span><span>A‚ÇÉ CUSP</span>
            </div>
            <p class="footer-tagline">Part of the Seven Colonies ‚Ä¢ Kagami Cognitive Architecture</p>
            <div class="footer-links">
                <a href="spark.html">üî• Spark</a>
                <a href="flow.html">üåä Flow</a>
                <a href="crystal-gallery/">üíé Crystal</a>
            </div>
        </div>
    </footer>

    <script>
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// FORGE GALLERY ‚Äî ALL JAVASCRIPT COMBINED
// ‚öíÔ∏è e‚ÇÇ ‚Äî The Cusp Catastrophe ‚Äî A‚ÇÉ
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const CONFIG = {
    COLORS: { MOLTEN: '#FF6B00', FORGE_ORANGE: '#FF8C00', EMBER: '#FF4500', STEEL: '#71797E', STEEL_LIGHT: '#A9A9A9', IRON: '#434343', WHITE_HOT: '#FFFAF0', SPARK_YELLOW: '#FFD700', COOL_STEEL: '#B0C4DE', VOID: '#0A0A0A' },
    ANVIL: { MAX_STRIKES: 100, SPARK_COUNT: 30, SHAKE_INTENSITY: 5, REBOUND_SPEED: 150 },
    CUSP: { CANVAS_PADDING: 50, LINE_WIDTH: 3, ANIMATION_SPEED: 0.015, SURFACE_RESOLUTION: 50 },
    FOUNDRY: { MAX_PARTICLES: 200, POUR_RATE: 10, COOLING_RATE: 5, MAX_TEMP: 1500, MIN_TEMP: 20 }
};

const METAL_TYPES = [
    { name: 'IRON', color: '#434343', meltPoint: 1538 },
    { name: 'STEEL', color: '#71797E', meltPoint: 1370 },
    { name: 'COPPER', color: '#B87333', meltPoint: 1085 },
    { name: 'GOLD', color: '#FFD700', meltPoint: 1064 },
    { name: 'SILVER', color: '#C0C0C0', meltPoint: 962 }
];

const CODE_FRAGMENTS = ['function forge(idea) {', '  return implement(idea);', '}', 'const build = (spec) => {', '  validate(spec);', '  construct(spec);', '  return artifact;', '};', 'class Builder {', '  hammer(code) {}', '  temper(tests) {}', '  quench(deploy) {}', '}', 'while (!perfect) {', '  refine();', '  iterate();', '}'];

// Sound System
class ForgeSoundSystem {
    constructor() { this.context = null; this.initialized = false; this.enabled = true; this.masterGain = null; }
    async init() {
        if (this.initialized) return;
        try {
            this.context = new (window.AudioContext || window.webkitAudioContext)();
            const compressor = this.context.createDynamicsCompressor();
            compressor.threshold.value = -24; compressor.knee.value = 30; compressor.ratio.value = 12;
            this.masterGain = this.context.createGain(); this.masterGain.gain.value = 0.6;
            this.masterGain.connect(compressor); compressor.connect(this.context.destination);
            this.initialized = true;
        } catch (e) { console.warn('Sound init failed:', e); }
    }
    playStrike() {
        if (!this.initialized || !this.enabled) return;
        const now = this.context.currentTime;
        const noiseBuffer = this.createNoiseBuffer(0.15);
        const noiseSource = this.context.createBufferSource(); noiseSource.buffer = noiseBuffer;
        const noiseFilter = this.context.createBiquadFilter(); noiseFilter.type = 'bandpass'; noiseFilter.frequency.value = 2000; noiseFilter.Q.value = 1;
        const noiseGain = this.context.createGain(); noiseGain.gain.setValueAtTime(0.4, now); noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
        noiseSource.connect(noiseFilter); noiseFilter.connect(noiseGain); noiseGain.connect(this.masterGain); noiseSource.start(now);
        [800, 1600, 2400, 3200].forEach((freq, i) => {
            const osc = this.context.createOscillator(); osc.type = 'sine'; osc.frequency.value = freq + Math.random() * 50;
            const gain = this.context.createGain(); gain.gain.setValueAtTime(0.15 / (i + 1), now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.8 - i * 0.1);
            osc.connect(gain); gain.connect(this.masterGain); osc.start(now); osc.stop(now + 1);
        });
    }
    playPour() {
        if (!this.initialized || !this.enabled) return;
        const now = this.context.currentTime;
        const noiseBuffer = this.createNoiseBuffer(2); const noiseSource = this.context.createBufferSource(); noiseSource.buffer = noiseBuffer;
        const filter = this.context.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.setValueAtTime(500, now); filter.frequency.linearRampToValueAtTime(2000, now + 0.5); filter.frequency.linearRampToValueAtTime(800, now + 2);
        const gain = this.context.createGain(); gain.gain.setValueAtTime(0, now); gain.gain.linearRampToValueAtTime(0.3, now + 0.2); gain.gain.linearRampToValueAtTime(0, now + 2);
        noiseSource.connect(filter); filter.connect(gain); gain.connect(this.masterGain); noiseSource.start(now); noiseSource.stop(now + 2);
    }
    playQuench() {
        if (!this.initialized || !this.enabled) return;
        const now = this.context.currentTime;
        const noiseBuffer = this.createNoiseBuffer(1.5); const noiseSource = this.context.createBufferSource(); noiseSource.buffer = noiseBuffer;
        const filter = this.context.createBiquadFilter(); filter.type = 'highpass'; filter.frequency.value = 3000;
        const gain = this.context.createGain(); gain.gain.setValueAtTime(0.5, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 1.5);
        noiseSource.connect(filter); filter.connect(gain); gain.connect(this.masterGain); noiseSource.start(now); noiseSource.stop(now + 1.5);
    }
    playCuspTransition(param) {
        if (!this.initialized || !this.enabled) return;
        const now = this.context.currentTime; const freq = 200 + (param + 2) * 150;
        const osc = this.context.createOscillator(); osc.type = 'sawtooth'; osc.frequency.setValueAtTime(freq, now); osc.frequency.exponentialRampToValueAtTime(freq * 0.5, now + 0.3);
        const filter = this.context.createBiquadFilter(); filter.type = 'lowpass'; filter.frequency.value = 1000; filter.Q.value = 5;
        const gain = this.context.createGain(); gain.gain.setValueAtTime(0.2, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
        osc.connect(filter); filter.connect(gain); gain.connect(this.masterGain); osc.start(now); osc.stop(now + 0.4);
    }
    createNoiseBuffer(duration) {
        const sampleRate = this.context.sampleRate; const bufferSize = sampleRate * duration;
        const buffer = this.context.createBuffer(1, bufferSize, sampleRate); const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        return buffer;
    }
    toggle() { this.enabled = !this.enabled; return this.enabled; }
}

// Anvil Room
class AnvilRoom {
    constructor(container, soundSystem) {
        this.container = container; this.sound = soundSystem;
        this.canvas = document.getElementById('anvil-canvas'); this.ctx = this.canvas?.getContext('2d');
        this.anvilBlock = document.getElementById('anvil-block'); this.strikeCountEl = document.getElementById('strike-count');
        this.sparks = []; this.strikeCount = 0; this.animationId = null;
        this.init();
    }
    init() {
        this.resizeCanvas(); window.addEventListener('resize', () => this.resizeCanvas());
        if (this.anvilBlock) this.anvilBlock.addEventListener('click', (e) => this.strike(e));
        this.startAnimation();
    }
    resizeCanvas() { if (this.canvas) { this.canvas.width = window.innerWidth; this.canvas.height = window.innerHeight; } }
    strike(event) {
        this.strikeCount++;
        if (this.strikeCountEl) { this.strikeCountEl.textContent = this.strikeCount; this.strikeCountEl.style.transform = 'scale(1.3)'; setTimeout(() => { this.strikeCountEl.style.transform = 'scale(1)'; }, 100); }
        const rect = this.anvilBlock.getBoundingClientRect(); const x = rect.left + rect.width / 2; const y = rect.top + rect.height / 2;
        const sparkMultiplier = (this.strikeCount % 10 === 0) ? 3 : 1;
        for (let i = 0; i < sparkMultiplier; i++) this.createSparks(x, y);
        if (this.strikeCount % 10 === 0) this.screenFlash();
        this.shakeAnvil(this.strikeCount % 10 === 0 ? 2 : 1);
        if (this.sound?.initialized) this.sound.playStrike();
        this.transformMetal(); this.createImpactRing(x, y);
    }
    screenFlash() {
        const flash = document.createElement('div');
        flash.style.cssText = `position:fixed;inset:0;background:radial-gradient(circle at center,rgba(255,215,0,0.4),transparent 70%);pointer-events:none;z-index:9999;animation:flash-fade 0.3s ease-out forwards;`;
        document.body.appendChild(flash); setTimeout(() => flash.remove(), 300);
        if (!document.getElementById('flash-keyframes')) { const style = document.createElement('style'); style.id = 'flash-keyframes'; style.textContent = `@keyframes flash-fade{0%{opacity:1}100%{opacity:0}}`; document.head.appendChild(style); }
    }
    createImpactRing(x, y) { this.sparks.push({ x, y, type: 'ring', radius: 10, maxRadius: 80, life: 400, maxLife: 400, color: CONFIG.COLORS.SPARK_YELLOW }); }
    createSparks(x, y) {
        const count = CONFIG.ANVIL.SPARK_COUNT; const colors = [CONFIG.COLORS.WHITE_HOT, CONFIG.COLORS.SPARK_YELLOW, CONFIG.COLORS.MOLTEN, CONFIG.COLORS.FORGE_ORANGE];
        for (let i = 0; i < count; i++) {
            const angle = (Math.PI * 2 * i) / count + (Math.random() - 0.5) * 0.5; const speed = 5 + Math.random() * 15;
            this.sparks.push({ x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed - Math.random() * 5, size: 1 + Math.random() * 4, color: colors[Math.floor(Math.random() * colors.length)], life: 800 + Math.random() * 400, maxLife: 1200, gravity: 0.15 });
        }
    }
    shakeAnvil(multiplier = 1) {
        if (!this.anvilBlock) return;
        const intensity = CONFIG.ANVIL.SHAKE_INTENSITY * multiplier; const shakeFrames = multiplier > 1 ? 4 : 2; let frame = 0;
        const shake = () => {
            if (frame >= shakeFrames) { this.anvilBlock.style.transform = 'translate(0, 0)'; return; }
            const x = (Math.random() - 0.5) * intensity * (1 - frame / shakeFrames); const y = (Math.random() - 0.5) * intensity * (1 - frame / shakeFrames);
            this.anvilBlock.style.transform = `translate(${x}px, ${y}px)`; frame++; setTimeout(shake, 30);
        };
        shake();
    }
    transformMetal() {
        const metal = this.anvilBlock?.querySelector('.metal-piece'); if (!metal) return;
        const progress = Math.min(this.strikeCount / 20, 1); const scale = 1 - progress * 0.3; const width = 60 + progress * 40;
        metal.style.transform = `scaleY(${scale})`; metal.style.width = `${width}px`;
        if (this.strikeCount > 15) metal.style.background = `linear-gradient(180deg, ${CONFIG.COLORS.STEEL} 0%, ${CONFIG.COLORS.IRON} 100%)`;
    }
    startAnimation() {
        const animate = () => {
            this.animationId = requestAnimationFrame(animate);
            if (!this.ctx || !this.canvas) return;
            const ctx = this.ctx; const width = this.canvas.width; const height = this.canvas.height;
            if (width === 0 || height === 0) return;
            ctx.fillStyle = 'rgba(10, 10, 10, 0.15)'; ctx.fillRect(0, 0, width, height);
            for (let i = this.sparks.length - 1; i >= 0; i--) {
                const s = this.sparks[i];
                if (s.type === 'ring') {
                    s.radius += (s.maxRadius - s.radius) * 0.15; s.life -= 16;
                    if (s.life <= 0) { this.sparks.splice(i, 1); continue; }
                    const alpha = s.life / s.maxLife;
                    ctx.beginPath(); ctx.arc(s.x, s.y, s.radius, 0, Math.PI * 2);
                    ctx.strokeStyle = this.hexToRgba(s.color, alpha * 0.6); ctx.lineWidth = 3 * alpha; ctx.stroke();
                    continue;
                }
                s.x += s.vx; s.y += s.vy; s.vy += s.gravity; s.vx *= 0.99; s.life -= 16;
                if (s.life <= 0 || s.y > height) { this.sparks.splice(i, 1); continue; }
                const alpha = s.life / s.maxLife; const size = s.size * alpha;
                if (s.life > 400) { ctx.beginPath(); ctx.moveTo(s.x, s.y); ctx.lineTo(s.x - s.vx * 3, s.y - s.vy * 3); ctx.strokeStyle = this.hexToRgba(s.color, alpha * 0.3); ctx.lineWidth = size * 0.5; ctx.stroke(); }
                const gradient = ctx.createRadialGradient(s.x, s.y, 0, s.x, s.y, size * 3);
                gradient.addColorStop(0, this.hexToRgba(s.color, alpha * 0.8)); gradient.addColorStop(1, 'transparent');
                ctx.beginPath(); ctx.arc(s.x, s.y, size * 3, 0, Math.PI * 2); ctx.fillStyle = gradient; ctx.fill();
                ctx.beginPath(); ctx.arc(s.x, s.y, size, 0, Math.PI * 2); ctx.fillStyle = this.hexToRgba(s.color, alpha); ctx.fill();
            }
            const ambientGradient = ctx.createLinearGradient(0, height - 100, 0, height);
            ambientGradient.addColorStop(0, 'transparent'); ambientGradient.addColorStop(1, 'rgba(255, 107, 0, 0.1)');
            ctx.fillStyle = ambientGradient; ctx.fillRect(0, height - 100, width, 100);
        };
        animate();
    }
    hexToRgba(hex, alpha) { const r = parseInt(hex.slice(1, 3), 16); const g = parseInt(hex.slice(3, 5), 16); const b = parseInt(hex.slice(5, 7), 16); return `rgba(${r}, ${g}, ${b}, ${alpha})`; }
    destroy() { if (this.animationId) cancelAnimationFrame(this.animationId); }
}

// Cusp Room
class CuspRoom {
    constructor(container, soundSystem) {
        this.container = container; this.sound = soundSystem;
        this.canvas = document.getElementById('cusp-canvas'); this.ctx = this.canvas?.getContext('2d');
        this.paramA = -1; this.paramB = 0; this.animationId = null; this.time = 0;
        this.paramASlider = document.getElementById('cusp-param-a'); this.paramBSlider = document.getElementById('cusp-param-b');
        this.paramAValue = document.getElementById('cusp-a-value'); this.paramBValue = document.getElementById('cusp-b-value');
        this.init();
    }
    init() {
        this.resizeCanvas(); window.addEventListener('resize', () => this.resizeCanvas());
        if (this.paramASlider) this.paramASlider.addEventListener('input', (e) => { this.paramA = parseFloat(e.target.value); if (this.paramAValue) this.paramAValue.textContent = this.paramA.toFixed(2); this.onParameterChange(); });
        if (this.paramBSlider) this.paramBSlider.addEventListener('input', (e) => { this.paramB = parseFloat(e.target.value); if (this.paramBValue) this.paramBValue.textContent = this.paramB.toFixed(2); this.onParameterChange(); });
        this.startAnimation();
    }
    resizeCanvas() { if (this.canvas) { this.canvas.width = this.canvas.parentElement?.clientWidth || 800; this.canvas.height = 400; } }
    onParameterChange() { if (this.sound?.initialized) this.sound.playCuspTransition(this.paramA); }
    potential(x, a, b) { return Math.pow(x, 4) + a * Math.pow(x, 2) + b * x; }
    derivative(x, a, b) { return 4 * Math.pow(x, 3) + 2 * a * x + b; }
    findEquilibria(a, b) {
        const equilibria = []; const xMin = -3; const xMax = 3; const step = 0.01;
        let prevSign = Math.sign(this.derivative(xMin, a, b));
        for (let x = xMin + step; x <= xMax; x += step) {
            const currentSign = Math.sign(this.derivative(x, a, b));
            if (currentSign !== prevSign && prevSign !== 0) {
                let lo = x - step; let hi = x;
                for (let i = 0; i < 20; i++) { const mid = (lo + hi) / 2; if (Math.sign(this.derivative(mid, a, b)) === prevSign) lo = mid; else hi = mid; }
                equilibria.push((lo + hi) / 2);
            }
            prevSign = currentSign;
        }
        return equilibria;
    }
    startAnimation() {
        const animate = () => {
            this.animationId = requestAnimationFrame(animate); this.time += CONFIG.CUSP.ANIMATION_SPEED;
            if (!this.ctx || !this.canvas) return;
            const ctx = this.ctx; const width = this.canvas.width; const height = this.canvas.height;
            if (width === 0 || height === 0) return;
            ctx.fillStyle = 'rgba(10, 10, 10, 1)'; ctx.fillRect(0, 0, width, height);
            const padding = CONFIG.CUSP.CANVAS_PADDING; const plotWidth = width - padding * 2; const plotHeight = height - padding * 2; const centerY = padding + plotHeight / 2;
            ctx.strokeStyle = 'rgba(113, 121, 126, 0.2)'; ctx.lineWidth = 1;
            for (let i = 0; i <= 10; i++) { const x = padding + (plotWidth / 10) * i; ctx.beginPath(); ctx.moveTo(x, padding); ctx.lineTo(x, height - padding); ctx.stroke(); }
            for (let i = 0; i <= 6; i++) { const y = padding + (plotHeight / 6) * i; ctx.beginPath(); ctx.moveTo(padding, y); ctx.lineTo(width - padding, y); ctx.stroke(); }
            ctx.strokeStyle = CONFIG.COLORS.STEEL_LIGHT; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(padding, centerY); ctx.lineTo(width - padding, centerY); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(width / 2, padding); ctx.lineTo(width / 2, height - padding); ctx.stroke();
            const xMin = -2.5; const xMax = 2.5; const xScale = plotWidth / (xMax - xMin);
            const toCanvasX = (x) => padding + (x - xMin) * xScale; const toCanvasY = (y) => centerY - y * (plotHeight / 10);
            ctx.beginPath(); ctx.strokeStyle = CONFIG.COLORS.MOLTEN; ctx.lineWidth = CONFIG.CUSP.LINE_WIDTH;
            let first = true;
            for (let px = 0; px <= plotWidth; px++) {
                const x = xMin + (px / plotWidth) * (xMax - xMin); const y = this.potential(x, this.paramA, this.paramB); const canvasY = toCanvasY(y);
                if (canvasY > padding - 20 && canvasY < height - padding + 20) { if (first) { ctx.moveTo(toCanvasX(x), canvasY); first = false; } else ctx.lineTo(toCanvasX(x), canvasY); } else first = true;
            }
            ctx.stroke(); ctx.save(); ctx.shadowColor = CONFIG.COLORS.MOLTEN; ctx.shadowBlur = 15; ctx.stroke(); ctx.restore();
            const equilibria = this.findEquilibria(this.paramA, this.paramB);
            equilibria.forEach((x, i) => {
                const y = this.potential(x, this.paramA, this.paramB); const canvasX = toCanvasX(x); const canvasY = toCanvasY(y);
                const secondDeriv = 12 * x * x + 2 * this.paramA; const isStable = secondDeriv > 0; const radius = 8 + Math.sin(this.time * 3 + i) * 2;
                if (isStable) {
                    ctx.beginPath(); ctx.arc(canvasX, canvasY, radius, 0, Math.PI * 2); ctx.fillStyle = CONFIG.COLORS.SPARK_YELLOW; ctx.fill();
                    const gradient = ctx.createRadialGradient(canvasX, canvasY, 0, canvasX, canvasY, radius * 2);
                    gradient.addColorStop(0, 'rgba(255, 215, 0, 0.5)'); gradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = gradient; ctx.beginPath(); ctx.arc(canvasX, canvasY, radius * 2, 0, Math.PI * 2); ctx.fill();
                } else { ctx.beginPath(); ctx.arc(canvasX, canvasY, radius, 0, Math.PI * 2); ctx.strokeStyle = CONFIG.COLORS.EMBER; ctx.lineWidth = 2; ctx.stroke(); }
            });
            ctx.fillStyle = CONFIG.COLORS.STEEL_LIGHT; ctx.font = '14px "JetBrains Mono", monospace';
            ctx.fillText(`V(x) = x‚Å¥ + (${this.paramA.toFixed(2)})x¬≤ + (${this.paramB.toFixed(2)})x`, padding, height - 15);
            const discriminant = 8 * Math.pow(this.paramA, 3) + 27 * Math.pow(this.paramB, 2);
            if (this.paramA < 0 && Math.abs(discriminant) < 5) { ctx.fillStyle = CONFIG.COLORS.EMBER; ctx.fillText('‚ö† NEAR BIFURCATION', width - 200, height - 15); }
        };
        animate();
    }
    destroy() { if (this.animationId) cancelAnimationFrame(this.animationId); }
}

// Foundry Room
class FoundryRoom {
    constructor(container, soundSystem) {
        this.container = container; this.sound = soundSystem;
        this.canvas = document.getElementById('foundry-canvas'); this.ctx = this.canvas?.getContext('2d');
        this.particles = []; this.temperature = 1200; this.isPourin = false; this.animationId = null; this.time = 0;
        this.pourBtn = document.getElementById('pour-btn'); this.coolBtn = document.getElementById('cool-btn');
        this.tempFill = document.getElementById('temp-fill'); this.tempValue = document.getElementById('temp-value');
        this.init();
    }
    init() {
        this.resizeCanvas(); window.addEventListener('resize', () => this.resizeCanvas());
        if (this.pourBtn) this.pourBtn.addEventListener('click', () => this.pour());
        if (this.coolBtn) this.coolBtn.addEventListener('click', () => this.quench());
        this.startAnimation(); this.updateTemperatureDisplay();
    }
    resizeCanvas() { if (this.canvas) { this.canvas.width = this.canvas.parentElement?.clientWidth || 800; this.canvas.height = 400; } }
    pour() {
        this.isPourin = true; this.temperature = Math.min(this.temperature + 300, CONFIG.FOUNDRY.MAX_TEMP);
        const pourX = (this.canvas?.width || 400) / 2;
        for (let i = 0; i < 50; i++) setTimeout(() => this.createMoltenParticle(pourX + (Math.random() - 0.5) * 30, 50 + Math.random() * 50), i * 20);
        if (this.sound?.initialized) this.sound.playPour();
        setTimeout(() => { this.isPourin = false; }, 1500);
    }
    quench() {
        const coolingInterval = setInterval(() => { this.temperature = Math.max(this.temperature - 50, CONFIG.FOUNDRY.MIN_TEMP); this.updateTemperatureDisplay(); if (this.temperature <= CONFIG.FOUNDRY.MIN_TEMP) clearInterval(coolingInterval); }, 50);
        this.particles.forEach(p => { if (p.type === 'molten') p.cooling = true; });
        for (let i = 0; i < 30; i++) setTimeout(() => this.createSteamParticle(Math.random() * (this.canvas?.width || 800), (this.canvas?.height || 400) - 100 + Math.random() * 50), i * 30);
        if (this.sound?.initialized) this.sound.playQuench();
    }
    createMoltenParticle(x, y) {
        const metal = METAL_TYPES[Math.floor(Math.random() * METAL_TYPES.length)];
        this.particles.push({ x, y, vx: (Math.random() - 0.5) * 2, vy: 2 + Math.random() * 3, size: 4 + Math.random() * 8, color: this.temperatureToColor(this.temperature), type: 'molten', cooling: false, life: 3000, maxLife: 3000, gravity: 0.15, metal });
    }
    createSteamParticle(x, y) { this.particles.push({ x, y, vx: (Math.random() - 0.5), vy: -2 - Math.random() * 3, size: 10 + Math.random() * 20, color: '#FFFFFF', type: 'steam', life: 1500, maxLife: 1500 }); }
    temperatureToColor(temp) { if (temp > 1300) return '#FFFAF0'; if (temp > 1100) return '#FFD700'; if (temp > 900) return '#FF8C00'; if (temp > 700) return '#FF4500'; if (temp > 500) return '#8B0000'; return '#434343'; }
    updateTemperatureDisplay() {
        if (this.tempValue) this.tempValue.textContent = Math.round(this.temperature);
        if (this.tempFill) { const percentage = ((this.temperature - CONFIG.FOUNDRY.MIN_TEMP) / (CONFIG.FOUNDRY.MAX_TEMP - CONFIG.FOUNDRY.MIN_TEMP)) * 100; this.tempFill.style.width = `${percentage}%`; this.tempFill.style.background = `linear-gradient(90deg, ${this.temperatureToColor(CONFIG.FOUNDRY.MIN_TEMP)} 0%, ${this.temperatureToColor(this.temperature)} 100%)`; }
    }
    startAnimation() {
        const animate = () => {
            this.animationId = requestAnimationFrame(animate); this.time += 0.016;
            if (!this.ctx || !this.canvas) return;
            const ctx = this.ctx; const width = this.canvas.width; const height = this.canvas.height;
            if (width === 0 || height === 0) return;
            ctx.fillStyle = 'rgba(10, 10, 10, 1)'; ctx.fillRect(0, 0, width, height);
            const poolHeight = 100;
            const poolGradient = ctx.createLinearGradient(0, height - poolHeight, 0, height);
            poolGradient.addColorStop(0, this.temperatureToColor(this.temperature));
            poolGradient.addColorStop(0.3, this.temperatureToColor(this.temperature * 0.8));
            poolGradient.addColorStop(1, this.temperatureToColor(this.temperature * 0.5));
            ctx.fillStyle = poolGradient; ctx.beginPath(); ctx.ellipse(width / 2, height - poolHeight / 2, width / 2 - 30, poolHeight / 2, 0, 0, Math.PI * 2); ctx.fill();
            if (this.temperature > 500) {
                ctx.save(); ctx.globalAlpha = 0.4;
                const surfaceGradient = ctx.createLinearGradient(width * 0.3, height - poolHeight, width * 0.7, height - poolHeight + 20);
                surfaceGradient.addColorStop(0, 'transparent'); surfaceGradient.addColorStop(0.5, this.temperatureToColor(this.temperature * 1.1)); surfaceGradient.addColorStop(1, 'transparent');
                ctx.fillStyle = surfaceGradient; ctx.beginPath(); ctx.ellipse(width / 2, height - poolHeight + 15, width / 3, 15, 0, 0, Math.PI * 2); ctx.fill(); ctx.restore();
            }
            if (this.temperature > 400) {
                const glowIntensity = Math.min((this.temperature - 400) / 1100, 0.6);
                const glowGradient = ctx.createRadialGradient(width / 2, height - poolHeight / 2, 0, width / 2, height - poolHeight / 2, width * 0.6);
                glowGradient.addColorStop(0, `rgba(255, 107, 0, ${glowIntensity})`); glowGradient.addColorStop(0.5, `rgba(255, 69, 0, ${glowIntensity * 0.4})`); glowGradient.addColorStop(1, 'transparent');
                ctx.fillStyle = glowGradient; ctx.fillRect(0, height - 250, width, 250);
            }
            if (this.temperature > 800) {
                const bubbleCount = Math.floor((this.temperature - 800) / 100);
                for (let i = 0; i < bubbleCount; i++) {
                    const bubbleX = width * 0.3 + Math.sin(this.time * 2 + i * 1.7) * (width * 0.2);
                    const bubbleY = height - poolHeight + 10 + Math.sin(this.time * 3 + i) * 5;
                    const bubbleSize = 3 + Math.sin(this.time * 5 + i * 2) * 2;
                    ctx.beginPath(); ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 200, 100, ${0.3 + Math.sin(this.time * 4 + i) * 0.2})`; ctx.fill();
                }
            }
            for (let i = this.particles.length - 1; i >= 0; i--) {
                const p = this.particles[i];
                if (p.type === 'molten') {
                    p.x += p.vx; p.y += p.vy; p.vy += p.gravity;
                    if (p.y > height - 80) { p.vy *= -0.3; p.y = height - 80; p.vx *= 0.8; }
                    if (p.cooling) { p.life -= 50; p.color = this.temperatureToColor(this.temperature * (p.life / p.maxLife)); } else p.life -= 16;
                } else if (p.type === 'steam') { p.x += p.vx + Math.sin(this.time * 5 + p.y * 0.1) * 0.5; p.y += p.vy; p.vy *= 0.99; p.life -= 16; p.size *= 1.01; }
                if (p.life <= 0) { this.particles.splice(i, 1); continue; }
                const alpha = p.life / p.maxLife;
                if (p.type === 'molten') {
                    const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size * 2);
                    gradient.addColorStop(0, this.hexToRgba(p.color, alpha * 0.8)); gradient.addColorStop(1, 'transparent');
                    ctx.beginPath(); ctx.arc(p.x, p.y, p.size * 2, 0, Math.PI * 2); ctx.fillStyle = gradient; ctx.fill();
                    ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fillStyle = this.hexToRgba(p.color, alpha); ctx.fill();
                } else if (p.type === 'steam') { ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.3})`; ctx.fill(); }
            }
            if (!this.isPourin && this.temperature > CONFIG.FOUNDRY.MIN_TEMP) { this.temperature = Math.max(this.temperature - 0.5, CONFIG.FOUNDRY.MIN_TEMP); this.updateTemperatureDisplay(); }
        };
        animate();
    }
    hexToRgba(hex, alpha) { if (hex.startsWith('rgba')) return hex; const r = parseInt(hex.slice(1, 3), 16); const g = parseInt(hex.slice(3, 5), 16); const b = parseInt(hex.slice(5, 7), 16); return `rgba(${r}, ${g}, ${b}, ${alpha})`; }
    destroy() { if (this.animationId) cancelAnimationFrame(this.animationId); }
}

// Construct Room
class ConstructRoom {
    constructor(container, soundSystem) { this.container = container; this.sound = soundSystem; this.animationId = null; this.init(); }
    init() { this.setupScrollAnimations(); this.setupTraitEffects(); this.startCodeRain(); }
    setupScrollAnimations() {
        const cards = this.container?.querySelectorAll('.psych-card'); if (!cards?.length) return;
        const observer = new IntersectionObserver((entries) => { entries.forEach((entry, index) => { if (entry.isIntersecting) setTimeout(() => entry.target.classList.add('visible'), index * 150); }); }, { threshold: 0.2 });
        cards.forEach(card => observer.observe(card));
    }
    setupTraitEffects() {
        const traits = this.container?.querySelectorAll('.trait'); if (!traits?.length) return;
        traits.forEach(trait => { trait.addEventListener('mouseenter', () => { if (this.sound?.initialized) this.sound.playCuspTransition(Math.random() * 2 - 1); }); });
    }
    startCodeRain() {
        const container = this.container?.querySelector('.construct-content'); if (!container) return;
        const canvas = document.createElement('canvas'); canvas.className = 'code-rain-canvas';
        canvas.style.cssText = `position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;opacity:0.15;`;
        container.style.position = 'relative'; container.insertBefore(canvas, container.firstChild);
        const ctx = canvas.getContext('2d');
        const resize = () => { canvas.width = container.clientWidth; canvas.height = container.clientHeight; }; resize(); window.addEventListener('resize', resize);
        const columns = Math.floor(canvas.width / 20); const drops = [];
        for (let i = 0; i < columns; i++) drops[i] = Math.random() * -100;
        const animate = () => {
            this.animationId = requestAnimationFrame(animate);
            if (canvas.width === 0 || canvas.height === 0) return;
            ctx.fillStyle = 'rgba(10, 10, 10, 0.05)'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = CONFIG.COLORS.MOLTEN; ctx.font = '14px "JetBrains Mono", monospace';
            for (let i = 0; i < drops.length; i++) {
                const fragment = CODE_FRAGMENTS[Math.floor(Math.random() * CODE_FRAGMENTS.length)];
                const char = fragment[Math.floor(Math.random() * fragment.length)];
                ctx.fillText(char, i * 20, drops[i] * 20);
                if (drops[i] * 20 > canvas.height && Math.random() > 0.975) drops[i] = 0;
                drops[i]++;
            }
        };
        animate();
    }
    destroy() { if (this.animationId) cancelAnimationFrame(this.animationId); }
}

// Main Gallery
class ForgeGallery {
    constructor() { this.sound = new ForgeSoundSystem(); this.rooms = {}; this.init(); }
    async init() {
        if (document.readyState === 'loading') await new Promise(resolve => document.addEventListener('DOMContentLoaded', resolve));
        document.addEventListener('click', async () => { if (!this.sound.initialized) await this.sound.init(); }, { once: true });
        const soundToggle = document.getElementById('sound-toggle');
        if (soundToggle) soundToggle.addEventListener('click', (e) => { e.stopPropagation(); const enabled = this.sound.toggle(); soundToggle.querySelector('.sound-on').style.display = enabled ? 'inline' : 'none'; soundToggle.querySelector('.sound-off').style.display = enabled ? 'none' : 'inline'; });
        this.initRooms(); this.setupNavigation(); this.setupRoomObserver();
    }
    initRooms() {
        const anvil = document.getElementById('room-anvil'); if (anvil) this.rooms.anvil = new AnvilRoom(anvil, this.sound);
        const cusp = document.getElementById('room-cusp'); if (cusp) this.rooms.cusp = new CuspRoom(cusp, this.sound);
        const foundry = document.getElementById('room-foundry'); if (foundry) this.rooms.foundry = new FoundryRoom(foundry, this.sound);
        const construct = document.getElementById('room-construct'); if (construct) this.rooms.construct = new ConstructRoom(construct, this.sound);
    }
    setupNavigation() {
        document.querySelectorAll('.nav-links a').forEach(link => { link.addEventListener('click', (e) => { e.preventDefault(); const target = document.querySelector(link.getAttribute('href')); if (target) target.scrollIntoView({ behavior: 'smooth' }); }); });
        const sections = document.querySelectorAll('.room'); const navLinks = document.querySelectorAll('.nav-links a');
        window.addEventListener('scroll', () => { let current = ''; sections.forEach(s => { if (window.scrollY >= s.offsetTop - s.clientHeight / 3) current = s.getAttribute('id'); }); navLinks.forEach(l => { l.classList.remove('active'); if (l.getAttribute('href') === `#${current}`) l.classList.add('active'); }); });
    }
    setupRoomObserver() {
        const observer = new IntersectionObserver((entries) => { entries.forEach(entry => { if (entry.isIntersecting) console.log(`‚öíÔ∏è Entering ${entry.target.getAttribute('id')}`); }); }, { threshold: 0.3 });
        document.querySelectorAll('.room').forEach(room => observer.observe(room));
    }
    destroy() { Object.values(this.rooms).forEach(room => room?.destroy?.()); }
}

const gallery = new ForgeGallery();
window.addEventListener('beforeunload', () => gallery.destroy());
    </script>
</body>
</html>

