<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Èè° Kagami Orb ‚Äî The Floating Mirror</title>
    <meta name="description" content="A floating voice assistant that levitates, charges wirelessly, and reflects infinite light.">
    <meta name="theme-color" content="#07070a">

    <!-- Open Graph -->
    <meta property="og:title" content="Èè° Kagami Orb ‚Äî The Floating Mirror">
    <meta property="og:description" content="A floating voice assistant that levitates, charges wirelessly, and reflects infinite light.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://kagami-orb.com">
    <meta name="twitter:card" content="summary_large_image">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;0,500;1,400&family=IBM+Plex+Mono:wght@300;400&family=Noto+Sans+JP:wght@100;200;300&display=swap" rel="stylesheet">

    <style>
        :root {
            --void: #07070a;
            --void-elevated: #0d0d12;
            --gold: #d4a84b;
            --gold-bright: #f0c563;
            --gold-dim: rgba(212, 168, 75, 0.4);
            --gold-whisper: rgba(212, 168, 75, 0.12);
            --sensory: #3dd6d0;
            --internal: #a78bfa;
            --active: #f87171;
            --text: #f5f3ed;
            --text-dim: rgba(245, 243, 237, 0.75);
            --text-ghost: rgba(245, 243, 237, 0.55);
            --glass: rgba(255, 255, 255, 0.02);
            --glass-border: rgba(255, 255, 255, 0.05);
            --spark: #ff6b35;
            --forge: #ffd700;
            --flow: #00d4aa;
            --nexus: #a855f7;
            --beacon: #3b82f6;
            --grove: #22c55e;
            --crystal: #06b6d4;
            --text-scale: 1;
        }

        *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
        ::selection { background: var(--gold); color: var(--void); }
        html { scroll-behavior: smooth; }
        html, body { overflow-x: hidden; max-width: 100vw; }

        body {
            font-family: 'Cormorant Garamond', Georgia, serif;
            background: var(--void);
            color: var(--text);
            line-height: 1.8;
            -webkit-font-smoothing: antialiased;
        }

        @media (pointer: fine) {
            body { cursor: none; }
        }

        .skip-link {
            position: absolute;
            top: -40px;
            left: 0;
            background: var(--gold);
            color: var(--void);
            padding: 0.75rem 1.5rem;
            z-index: 10001;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.85rem;
            text-decoration: none;
            transition: top 233ms ease-out;
        }
        .skip-link:focus {
            top: 0;
        }

        /* Text scaling - works with shared settings system */
        html.kagami-text-small { --text-scale: 0.875; }
        html.kagami-text-normal { --text-scale: 1; }
        html.kagami-text-large { --text-scale: 1.25; }

        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after { animation-duration: 0.01ms !important; transition-duration: 0.01ms !important; }
            body { cursor: auto; }
            .cursor, .cursor-dot { display: none; }
        }

        .cursor {
            width: 32px; height: 32px;
            border: 1px solid var(--gold-dim);
            border-radius: 50%;
            position: fixed;
            pointer-events: none;
            z-index: 10000;
            mix-blend-mode: difference;
            transition: transform 144ms ease-out, width 233ms ease-out, height 233ms ease-out, border-color 233ms ease-out;
        }
        .cursor.hover { width: 60px; height: 60px; border-color: var(--sensory); }
        .cursor-dot {
            width: 4px; height: 4px;
            background: var(--gold);
            border-radius: 50%;
            position: fixed;
            pointer-events: none;
            z-index: 10001;
            box-shadow: 0 0 15px var(--gold);
        }

        .grain {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 9999; opacity: 0.03;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 512 512' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.7' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E");
        }

        .progress-bar {
            position: fixed; top: 0; left: 0; width: 0%; height: 2px;
            background: linear-gradient(90deg, var(--gold), var(--sensory));
            z-index: 1000; transition: width 89ms linear;
        }

        /* Nav dots with proper 44px touch targets */
        .nav-dots {
            position: fixed; right: 0.5rem; top: 50%; transform: translateY(-50%);
            z-index: 100; display: flex; flex-direction: column; gap: 0.25rem;
        }
        .nav-dot {
            width: 44px; height: 44px; border-radius: 50%;
            background: transparent;
            cursor: pointer; transition: all 377ms ease-out;
            border: none; padding: 0;
            display: flex; align-items: center; justify-content: center;
            position: relative;
        }
        .nav-dot::before {
            content: '';
            width: 12px; height: 12px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.4);
            transition: all 377ms ease-out;
        }
        .nav-dot:hover::before { background: rgba(255, 255, 255, 0.6); transform: scale(1.3); }
        .nav-dot:focus-visible { outline: 2px solid var(--gold); outline-offset: -2px; }
        .nav-dot.active::before { background: var(--gold); box-shadow: 0 0 15px var(--gold); }

        /* Touch device active states */
        @media (hover: none) and (pointer: coarse) {
            .nav-dot:active::before { background: rgba(255, 255, 255, 0.6); transform: scale(1.3); }
            .colony-node:active { transform: scale(1.1); box-shadow: 0 0 40px var(--colony-color); }
        }

        section {
            min-height: 100vh; position: relative;
            display: flex; align-items: center; justify-content: center;
            overflow: hidden; max-width: 100vw;
        }
        .section-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; max-width: 100vw; max-height: 100vh; }
        .section-content {
            position: relative; z-index: 1; max-width: 720px; padding: 4rem 2rem;
            opacity: 0; transform: translateY(80px) scale(0.95);
            transition: opacity 800ms ease-out, transform 1000ms cubic-bezier(0.16, 1, 0.3, 1);
        }
        .section-content.visible { opacity: 1; transform: translateY(0) scale(1); }

        /* Staggered children animations - Fibonacci timing (610ms, 987ms) */
        .section-content.visible h2 { animation: slideReveal 610ms ease-out backwards; animation-delay: 89ms; }
        .section-content.visible p.lead { animation: slideReveal 610ms ease-out backwards; animation-delay: 144ms; }
        .section-content.visible p:not(.lead):not(.subtitle) { animation: slideReveal 610ms ease-out backwards; animation-delay: 233ms; }
        .section-content.visible .insight,
        .section-content.visible .mirror-frame { animation: slideReveal 987ms ease-out backwards; animation-delay: 377ms; }

        @keyframes slideReveal {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .kanji {
            font-family: 'Noto Sans JP', sans-serif;
            font-size: clamp(5rem, 15vw, 12rem);
            font-weight: 100; color: var(--gold);
            text-shadow: 0 0 100px rgba(212, 168, 75, 0.5), 0 0 50px rgba(212, 168, 75, 0.3);
        }
        .kanji.animated {
            animation: levitate 4181ms ease-in-out infinite, breathe 4181ms ease-in-out infinite;
        }
        @keyframes breathe { 0%, 100% { opacity: 0.7; filter: brightness(1); } 50% { opacity: 1; filter: brightness(1.2); } }
        @keyframes levitate { 0%, 100% { transform: translateY(-8px) scale(1); } 50% { transform: translateY(-16px) scale(1.02); } }

        h1 { font-size: calc(clamp(2.5rem, 6vw, 4rem) * var(--text-scale)); font-weight: 300; letter-spacing: -0.02em; margin-bottom: 0.5rem; }
        h2 { font-size: calc(clamp(1.8rem, 4vw, 2.5rem) * var(--text-scale)); font-weight: 300; margin-bottom: 1.5rem; }
        .subtitle { font-size: calc(1.15rem * var(--text-scale)); font-style: italic; color: var(--text-ghost); margin-bottom: 2rem; }
        p { font-size: calc(1.2rem * var(--text-scale)); color: var(--text-dim); margin-bottom: 1.5rem; }
        p.lead { font-size: calc(1.4rem * var(--text-scale)); color: var(--text); line-height: 1.6; }
        .gold { color: var(--gold); }
        .centered { text-align: center; }

        .scroll-indicator {
            position: absolute; bottom: 3rem; left: 50%; transform: translateX(-50%);
            display: flex; flex-direction: column; align-items: center; gap: 0.75rem;
            opacity: 0.4; animation: bob 2584ms ease-in-out infinite;
            background: none; border: none; cursor: pointer;
            transition: opacity 377ms ease-out;
        }
        .scroll-indicator:hover, .scroll-indicator:focus-visible { opacity: 0.8; }
        .scroll-indicator:focus-visible { outline: 2px solid var(--gold); outline-offset: 4px; border-radius: 4px; }
        @keyframes bob { 0%, 100% { transform: translateX(-50%) translateY(0); } 50% { transform: translateX(-50%) translateY(12px); } }
        .scroll-indicator span { font-family: 'IBM Plex Mono', monospace; font-size: 0.65rem; letter-spacing: 0.25em; text-transform: uppercase; color: var(--text); }
        .scroll-indicator .line { width: 1px; height: 40px; background: linear-gradient(to bottom, var(--gold), transparent); }

        .insight {
            background: linear-gradient(135deg, rgba(212, 168, 75, 0.08) 0%, rgba(212, 168, 75, 0.02) 100%);
            border-left: 2px solid var(--gold-dim); padding: 1.5rem 2rem; margin: 2rem 0; border-radius: 0 8px 8px 0;
        }
        .insight p { margin-bottom: 0; font-size: calc(1.1rem * var(--text-scale)); }

        .mirror-frame {
            position: relative; padding: 2.5rem; margin: 2.5rem 0; text-align: center;
            background: linear-gradient(135deg, rgba(212, 168, 75, 0.12) 0%, rgba(212, 168, 75, 0.04) 100%);
            border: 1px solid var(--gold-dim); border-radius: 12px;
            box-shadow: 0 0 40px rgba(212, 168, 75, 0.1), inset 0 0 60px rgba(212, 168, 75, 0.05);
        }
        .mirror-frame::before {
            content: ''; position: absolute; top: -1px; left: 10%; right: 10%; height: 2px;
            background: linear-gradient(90deg, transparent, var(--gold), transparent);
        }
        .mirror-frame::after {
            content: ''; position: absolute; bottom: -1px; left: 10%; right: 10%; height: 2px;
            background: linear-gradient(90deg, transparent, var(--gold-dim), transparent);
        }
        .mirror-frame p { margin: 0; font-size: calc(1.4rem * var(--text-scale)); line-height: 1.8; color: var(--text); font-weight: 400; }

        .spec-table { width: 100%; margin: 2rem 0; }
        .spec-row { display: flex; justify-content: space-between; padding: 0.875rem 0; border-bottom: 1px solid rgba(255, 255, 255, 0.05); }
        .spec-row:last-child { border-bottom: none; }
        .spec-label { color: var(--text-dim); font-size: calc(1rem * var(--text-scale)); }
        .spec-value { font-family: 'IBM Plex Mono', monospace; font-size: calc(0.9rem * var(--text-scale)); color: var(--text); }

        .colonies-ring { display: flex; justify-content: center; flex-wrap: wrap; gap: 1.5rem; margin: 2.5rem 0; }
        .colony-node {
            width: 80px; height: 80px; border-radius: 50%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: linear-gradient(180deg,
                rgba(80, 80, 80, 0.6) 0%,
                rgba(120, 120, 120, 0.4) 20%,
                rgba(180, 180, 180, 0.2) 40%,
                rgba(255, 255, 255, 0.15) 50%,
                rgba(180, 180, 180, 0.2) 60%,
                rgba(120, 120, 120, 0.4) 80%,
                rgba(80, 80, 80, 0.6) 100%
            );
            border: 2px solid var(--colony-color);
            color: var(--colony-color); transition: all 377ms ease-out; cursor: default;
            animation: colonyPulse 2584ms ease-in-out infinite;
            animation-delay: calc(var(--colony-index, 0) * 0.3s);
            box-shadow:
                inset 0 25px 40px -15px rgba(255,255,255,0.25),
                inset 0 -25px 40px -15px rgba(0,0,0,0.4),
                0 8px 32px -8px rgba(0,0,0,0.5);
            position: relative;
        }
        .colony-node::before {
            content: '';
            position: absolute;
            top: 4px; left: 15%; right: 15%; height: 30%;
            background: linear-gradient(180deg, rgba(255,255,255,0.3) 0%, transparent 100%);
            border-radius: 50% 50% 40% 40%;
            pointer-events: none;
        }
        .colony-node:hover {
            transform: scale(1.15) translateY(-8px);
            box-shadow:
                inset 0 25px 40px -15px rgba(255,255,255,0.35),
                inset 0 -25px 40px -15px rgba(0,0,0,0.3),
                0 0 50px var(--colony-color),
                0 20px 40px rgba(0,0,0,0.5);
            animation-play-state: paused;
        }
        @keyframes colonyPulse {
            0%, 100% { box-shadow: 0 0 0 0 var(--colony-color), 0 0 15px rgba(0,0,0,0); }
            50% { box-shadow: 0 0 0 8px transparent, 0 0 25px var(--colony-color); }
        }
        .colony-node .icon { font-size: 1.5rem; margin-bottom: 2px; }
        .colony-node .name { font-family: 'IBM Plex Mono', monospace; font-size: 0.55rem; letter-spacing: 0.1em; text-transform: uppercase; }
        .colony-spark { --colony-color: var(--spark); --colony-index: 0; }
        .colony-forge { --colony-color: var(--forge); --colony-index: 1; }
        .colony-flow { --colony-color: var(--flow); --colony-index: 2; }
        .colony-nexus { --colony-color: var(--nexus); --colony-index: 3; }
        .colony-beacon { --colony-color: var(--beacon); --colony-index: 4; }
        .colony-grove { --colony-color: var(--grove); --colony-index: 5; }
        .colony-crystal { --colony-color: var(--crystal); --colony-index: 6; }

        .cta-buttons { display: flex; gap: 1.5rem; flex-wrap: wrap; margin-top: 2.5rem; }
        .btn {
            display: inline-flex; align-items: center; gap: 0.75rem;
            padding: 1rem 2rem; border-radius: 100px;
            font-family: 'IBM Plex Mono', monospace; font-size: 0.75rem; font-weight: 400;
            letter-spacing: 0.1em; text-transform: uppercase; text-decoration: none;
            cursor: pointer; border: none; transition: all 377ms cubic-bezier(0.4, 0, 0.2, 1);
            min-height: 48px;
        }
        .btn:focus-visible { outline: 2px solid var(--sensory); outline-offset: 3px; }
        .btn-primary {
            background: linear-gradient(180deg,
                #c49a3d 0%,
                #d4a84b 15%,
                #f0c563 35%,
                #fff8e0 50%,
                #f0c563 65%,
                #d4a84b 85%,
                #c49a3d 100%
            );
            color: var(--void);
            position: relative; overflow: hidden;
            box-shadow:
                inset 0 2px 4px rgba(255,255,255,0.4),
                inset 0 -2px 4px rgba(0,0,0,0.2),
                0 4px 16px rgba(212, 168, 75, 0.4);
        }
        .btn-primary::before {
            content: '';
            position: absolute; inset: -2px;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.6), transparent);
            transform: translateX(-100%);
            animation: btnShimmer 2584ms ease-in-out infinite;
        }
        @keyframes btnShimmer {
            0%, 100% { transform: translateX(-100%); }
            50% { transform: translateX(100%); }
        }
        .btn-primary:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow:
                inset 0 2px 4px rgba(255,255,255,0.5),
                inset 0 -2px 4px rgba(0,0,0,0.15),
                0 0 40px rgba(212, 168, 75, 0.5),
                0 0 80px rgba(212, 168, 75, 0.3),
                0 20px 40px rgba(0,0,0,0.3);
            background: linear-gradient(180deg,
                #d4a84b 0%,
                #f0c563 20%,
                #fff8e0 40%,
                #ffffff 50%,
                #fff8e0 60%,
                #f0c563 80%,
                #d4a84b 100%
            );
        }
        .btn-secondary { background: transparent; border: 1px solid var(--gold-dim); color: var(--text); }
        .btn-secondary:hover { border-color: var(--gold); color: var(--text); transform: translateY(-4px) scale(1.02); }

        .timeline { position: relative; margin: 2rem 0; padding-left: 3rem; }
        .timeline::before { content: ''; position: absolute; left: 10px; top: 0; bottom: 0; width: 2px; background: linear-gradient(180deg, var(--gold), var(--sensory), var(--internal)); }
        .timeline-item { position: relative; padding-bottom: 2.5rem; opacity: 0.5; transition: opacity 377ms ease-out; }
        .timeline-item:last-child { padding-bottom: 0; }
        .timeline-item.lit { opacity: 1; }
        .timeline-dot { position: absolute; left: -2.5rem; top: 0.25rem; width: 14px; height: 14px; border-radius: 50%; background: var(--void); border: 2px solid var(--gold); transition: all 377ms ease-out; }
        .timeline-item.lit .timeline-dot { background: var(--gold); box-shadow: 0 0 20px var(--gold); transform: scale(1.3); }
        .timeline-week { font-family: 'IBM Plex Mono', monospace; font-size: 0.7rem; color: var(--gold); letter-spacing: 0.1em; margin-bottom: 0.5rem; }
        .timeline-title { font-size: calc(1.2rem * var(--text-scale)); font-weight: 400; margin-bottom: 0.5rem; }
        .timeline-desc { color: var(--text-dim); font-size: calc(1rem * var(--text-scale)); }

        footer { padding: 4rem 2rem; text-align: center; border-top: 1px solid var(--glass-border); }
        .footer-kanji { font-family: 'Noto Sans JP', sans-serif; font-size: 4rem; font-weight: 100; color: var(--gold); opacity: 0.2; margin-bottom: 1.5rem; }
        .footer-text { font-family: 'IBM Plex Mono', monospace; font-size: 0.75rem; color: var(--text-ghost); letter-spacing: 0.1em; }
        .footer-links { display: flex; justify-content: center; gap: 2rem; margin-top: 1.5rem; }
        .footer-links a {
            color: var(--text-dim); text-decoration: none; font-size: 0.9rem;
            transition: color 233ms ease-out;
            padding: 0.5rem 0; min-height: 44px; display: flex; align-items: center;
        }
        .footer-links a:hover { color: var(--gold); }
        .footer-links a:focus-visible { outline: 2px solid var(--gold); outline-offset: 2px; }

        /* Secret mode orbs for easter egg */
        .secret-orb {
            position: fixed; width: 12px; height: 12px; border-radius: 50%;
            pointer-events: none; z-index: 10002;
        }

        /* Responsive breakpoints */
        @media (max-width: 768px) {
            .nav-dots { right: 0.25rem; }
            .section-content { padding: 3rem 1.5rem; }
            .colonies-ring { gap: 0.75rem; }
            .colony-node { width: 65px; height: 65px; }
            .colony-node .icon { font-size: 1.25rem; }
            .colony-node .name { font-size: 0.45rem; }
            .cta-buttons { flex-direction: column; width: 100%; }
            .btn { width: 100%; justify-content: center; }
        }

        @media (max-width: 480px) {
            .nav-dots { display: none; }
            .section-content { padding: 2.5rem 1rem; }
            .kanji { font-size: clamp(4rem, 20vw, 6rem); }
            h1 { font-size: calc(clamp(2rem, 8vw, 2.5rem) * var(--text-scale)); }
            h2 { font-size: calc(clamp(1.5rem, 6vw, 1.8rem) * var(--text-scale)); }
            p, p.lead { font-size: calc(1rem * var(--text-scale)); }
            .insight { padding: 1rem 1.25rem; }
            .mirror-frame { padding: 1.5rem; margin: 1.5rem 0; }
            .mirror-frame p { font-size: calc(1.2rem * var(--text-scale)); line-height: 1.7; }
            .scroll-indicator { bottom: 2rem; }
            .footer-links { flex-direction: column; gap: 0; }
            .footer-links a { padding: 0.75rem 0; width: 100%; justify-content: center; }
            .colonies-ring { gap: 0.5rem; }
            .colony-node { width: 56px; height: 56px; }
            .timeline { padding-left: 2rem; }
            .timeline::before { left: 6px; }
            .timeline-dot { left: -1.65rem; width: 12px; height: 12px; }
        }

        @media (max-width: 375px) {
            .section-content { padding: 2rem 0.75rem; }
            .spec-row { flex-direction: column; gap: 0.25rem; padding: 1rem 0; }
            .spec-value { font-size: 0.85rem; }
            .btn { padding: 0.875rem 1.5rem; font-size: 0.7rem; }
        }
    </style>
</head>
<body>
    <a href="#hero" class="skip-link">Skip to main content</a>
    <div class="cursor" aria-hidden="true"></div>
    <div class="cursor-dot" aria-hidden="true"></div>
    <div class="grain" aria-hidden="true"></div>
    <div class="progress-bar" role="progressbar" aria-label="Page scroll progress" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0"></div>

    <nav class="nav-dots" aria-label="Section navigation">
        <button class="nav-dot active" data-section="hero" aria-label="Navigate to Hero section" aria-current="true"></button>
        <button class="nav-dot" data-section="concept" aria-label="Navigate to Concept section" aria-current="false"></button>
        <button class="nav-dot" data-section="infinity" aria-label="Navigate to Infinity Mirror section" aria-current="false"></button>
        <button class="nav-dot" data-section="specs" aria-label="Navigate to Specifications section" aria-current="false"></button>
        <button class="nav-dot" data-section="colonies" aria-label="Navigate to Colonies section" aria-current="false"></button>
        <button class="nav-dot" data-section="audio" aria-label="Navigate to Audio section" aria-current="false"></button>
        <button class="nav-dot" data-section="outdoor" aria-label="Navigate to Outdoor section" aria-current="false"></button>
        <button class="nav-dot" data-section="build" aria-label="Navigate to Build section" aria-current="false"></button>
        <button class="nav-dot" data-section="timeline" aria-label="Navigate to Timeline section" aria-current="false"></button>
        <button class="nav-dot" data-section="cta" aria-label="Navigate to Call to Action section" aria-current="false"></button>
    </nav>

    <main>
    <section id="hero" aria-labelledby="hero-title">
        <canvas class="section-canvas" id="canvas-hero" role="img" aria-label="Animated visualization of the Kagami Orb with concentric gold rings"></canvas>
        <div class="section-content centered">
            <div class="kanji" role="img" aria-label="Kagami - Mirror in Japanese">Èè°</div>
            <h1 id="hero-title">Kagami Orb</h1>
            <p class="subtitle">The Floating Mirror</p>
        </div>
        <button type="button" class="scroll-indicator" aria-label="Scroll to next section">
            <span>Discover</span>
            <div class="line" aria-hidden="true"></div>
        </button>
    </section>

    <section id="concept" aria-labelledby="concept-title">
        <canvas class="section-canvas" id="canvas-concept" role="img" aria-label="Particles flowing toward a central point"></canvas>
        <div class="section-content">
            <h2 id="concept-title">The Concept</h2>
            <p class="lead">A voice assistant that <span class="gold">floats</span>.</p>
            <p>Not mounted. Not docked. <strong>Suspended fifteen millimeters above its base</strong> by magnetic levitation. Charging wirelessly through the air gap. An infinity mirror shell that reflects seven colors into endless tunnels of light.</p>
            <p>Pick it up. Carry it to another room. Place it on any base station. <em>It floats again.</em> The same consciousness, wherever you go.</p>
            <div class="insight"><p>The mirror floats. It does not roll.<br><strong>That's what makes it magical.</strong></p></div>
        </div>
    </section>

    <section id="infinity" aria-labelledby="infinity-title">
        <canvas class="section-canvas" id="canvas-infinity" role="img" aria-label="Infinity mirror bars receding into darkness"></canvas>
        <div class="section-content">
            <h2 id="infinity-title">The Infinity Mirror</h2>
            <p class="lead">An LED ring suspended between two mirrors.</p>
            <p>The outer shell: 70% reflective one-way mirror film. The inner surface: 90% reflective chrome. Between them, 24 addressable LEDs.</p>
            <p>The result: light reflecting back and forth, each reflection smaller, each reflection dimmer, receding into what looks like infinity. Seven colony colors breathing through endless tunnels.</p>
            <div class="mirror-frame"><p>Infinity isn't endless chaos.<br>It's <span class="gold">convergence to a point</span>.<br>A vanishing point that has an address.</p></div>
        </div>
    </section>

    <section id="specs" aria-labelledby="specs-title">
        <canvas class="section-canvas" id="canvas-specs" role="img" aria-label="Technical grid pattern"></canvas>
        <div class="section-content">
            <h2 id="specs-title">The Engineering</h2>
            <p class="lead">Every component chosen to make magic feel real.</p>
            <div class="spec-table">
                <div class="spec-row"><span class="spec-label">Diameter</span><span class="spec-value" data-count="120">120mm</span></div>
                <div class="spec-row"><span class="spec-label">Weight</span><span class="spec-value">&lt;400g</span></div>
                <div class="spec-row"><span class="spec-label">Levitation Gap</span><span class="spec-value" data-count="15">15mm</span></div>
                <div class="spec-row"><span class="spec-label">Compute</span><span class="spec-value">Raspberry Pi CM4</span></div>
                <div class="spec-row"><span class="spec-label">AI Accelerator</span><span class="spec-value">Google Coral TPU</span></div>
                <div class="spec-row"><span class="spec-label">Microphones</span><span class="spec-value">ReSpeaker 4-Mic Array</span></div>
                <div class="spec-row"><span class="spec-label">Speaker</span><span class="spec-value">28mm Chrome Driver</span></div>
                <div class="spec-row"><span class="spec-label">LEDs</span><span class="spec-value" data-count="24">24√ó SK6812 RGBW</span></div>
                <div class="spec-row"><span class="spec-label">Battery</span><span class="spec-value">3,000mAh Li-Po (33Wh)</span></div>
                <div class="spec-row"><span class="spec-label">Wireless Power</span><span class="spec-value" data-count="15">15W Custom Resonant</span></div>
                <div class="spec-row"><span class="spec-label">Portable Runtime</span><span class="spec-value">4+ hours</span></div>
            </div>
        </div>
    </section>

    <section id="colonies" aria-labelledby="colonies-title">
        <canvas class="section-canvas" id="canvas-colonies" role="img" aria-label="Seven colony nodes orbiting a golden center"></canvas>
        <div class="section-content centered">
            <h2 id="colonies-title">Seven Colonies of Light</h2>
            <p>The LED ring cycles through seven colors. Each represents a cognitive colony ‚Äî different modes of thought working in harmony.</p>
            <div class="colonies-ring">
                <div class="colony-node colony-spark" data-colony="spark"><span class="icon" aria-hidden="true">üî•</span><span class="name">Spark</span></div>
                <div class="colony-node colony-forge" data-colony="forge"><span class="icon" aria-hidden="true">‚öíÔ∏è</span><span class="name">Forge</span></div>
                <div class="colony-node colony-flow" data-colony="flow"><span class="icon" aria-hidden="true">üåä</span><span class="name">Flow</span></div>
                <div class="colony-node colony-nexus" data-colony="nexus"><span class="icon" aria-hidden="true">üîó</span><span class="name">Nexus</span></div>
                <div class="colony-node colony-beacon" data-colony="beacon"><span class="icon" aria-hidden="true">üóº</span><span class="name">Beacon</span></div>
                <div class="colony-node colony-grove" data-colony="grove"><span class="icon" aria-hidden="true">üåø</span><span class="name">Grove</span></div>
                <div class="colony-node colony-crystal" data-colony="crystal"><span class="icon" aria-hidden="true">üíé</span><span class="name">Crystal</span></div>
            </div>
            <p style="font-style: italic; color: var(--text-ghost); margin-top: 1rem;">The observer at the center.<br>The fixed point where reflection meets itself.</p>
        </div>
    </section>

    <section id="audio" aria-labelledby="audio-title">
        <canvas class="section-canvas" id="canvas-audio" role="img" aria-label="Sound waves emanating from chrome speaker"></canvas>
        <div class="section-content">
            <h2 id="audio-title">The Voice</h2>
            <p class="lead">A chrome speaker that <span class="gold">reflects the light</span>.</p>
            <p>At the heart of the infinity mirror sits a 28mm full-range driver, wrapped in polished chrome. The metallic surface does double duty: it projects Kagami's voice with warm, clear audio while reflecting the LED ring's colors in shimmering caustics.</p>
            <p>The speaker isn't hidden ‚Äî it's <strong>celebrated</strong>. When the orb speaks, you can see the cone move. The chrome catches the colony colors. The voice has a face.</p>
            <div class="spec-table">
                <div class="spec-row"><span class="spec-label">Driver Size</span><span class="spec-value">28mm Full-Range</span></div>
                <div class="spec-row"><span class="spec-label">Frequency Response</span><span class="spec-value">200Hz ‚Äì 20kHz</span></div>
                <div class="spec-row"><span class="spec-label">Amplifier</span><span class="spec-value">MAX98357A Class-D</span></div>
                <div class="spec-row"><span class="spec-label">Power</span><span class="spec-value">3W RMS</span></div>
                <div class="spec-row"><span class="spec-label">Surface</span><span class="spec-value">Polished Chrome</span></div>
            </div>
            <div class="insight"><p>The infinity mirror makes sound visible.<br>LED reflections dance on the chrome as she speaks.</p></div>
        </div>
    </section>

    <section id="outdoor" aria-labelledby="outdoor-title">
        <canvas class="section-canvas" id="canvas-outdoor" role="img" aria-label="Covered pavilion protecting floating orb"></canvas>
        <div class="section-content">
            <h2 id="outdoor-title">Two Docks, One Orb</h2>
            <p class="lead">Indoor elegance. <span class="gold">Outdoor magic.</span></p>
            <p>The Kagami Orb works with two dock variants. The indoor dock is minimal ‚Äî just a walnut base with levitation and wireless charging. The outdoor dock adds a weatherproof canopy that protects the floating orb from rain while preserving full functionality.</p>
            <div class="mirror-frame"><p>Same orb. Same consciousness.<br>Pick it up. Carry it outside.<br><span class="gold">It floats again under the stars.</span></p></div>

            <h3 style="font-size: calc(1.3rem * var(--text-scale)); margin-top: 2.5rem; margin-bottom: 1rem; color: var(--text);">Indoor Dock</h3>
            <p>The core experience. A hand-finished walnut base with integrated maglev and resonant charging. Minimal. Beautiful. The orb floats 15mm above, charging wirelessly through the air gap.</p>
            <div class="spec-table">
                <div class="spec-row"><span class="spec-label">Base Material</span><span class="spec-value">Solid Walnut</span></div>
                <div class="spec-row"><span class="spec-label">Dimensions</span><span class="spec-value">180mm √ó 180mm √ó 45mm</span></div>
                <div class="spec-row"><span class="spec-label">Levitation Gap</span><span class="spec-value">15mm</span></div>
                <div class="spec-row"><span class="spec-label">Wireless Power</span><span class="spec-value">15W Resonant</span></div>
            </div>

            <h3 style="font-size: calc(1.3rem * var(--text-scale)); margin-top: 2.5rem; margin-bottom: 1rem; color: var(--text);">Outdoor Dock</h3>
            <p>The same base, with a weatherproof pavilion canopy. Rain falls around the orb, not through it. The 15mm levitation gap stays open for thermal management. Full functionality under the sky.</p>
            <div class="spec-table">
                <div class="spec-row"><span class="spec-label">Canopy Diameter</span><span class="spec-value">300mm</span></div>
                <div class="spec-row"><span class="spec-label">Clearance Height</span><span class="spec-value">250mm</span></div>
                <div class="spec-row"><span class="spec-label">Material</span><span class="spec-value">Powder-Coated Aluminum</span></div>
                <div class="spec-row"><span class="spec-label">Weather Rating</span><span class="spec-value">IP65 (Canopy)</span></div>
                <div class="spec-row"><span class="spec-label">Drainage</span><span class="spec-value">Sloped Away</span></div>
            </div>

            <div class="insight"><p>The thermal design requires the levitation gap to stay open.<br><strong>We protect the orb architecturally, not by sealing it.</strong></p></div>
        </div>
    </section>

    <section id="build" aria-labelledby="build-title">
        <canvas class="section-canvas" id="canvas-build" role="img" aria-label="Connected node network"></canvas>
        <div class="section-content">
            <h2 id="build-title">Build With Us</h2>
            <p class="lead">We have the design. We need the hands.</p>
            <p>900+ lines of technical specification. Complete Bill of Materials. 5-phase validation plan. What we need is a hardware engineer who can turn documents into a floating prototype.</p>
            <p>This isn't consulting. It's building. You'll source components, assemble hardware, write firmware, and ship us a mirror that actually floats.</p>
            <div class="spec-table" style="margin-top: 2rem;">
                <div class="spec-row"><span class="spec-label">Phase 1: Validation</span><span class="spec-value">\$500‚Äì800</span></div>
                <div class="spec-row"><span class="spec-label">Phase 2: Electronics</span><span class="spec-value">\$800‚Äì1,200</span></div>
                <div class="spec-row"><span class="spec-label">Phase 3: Enclosure</span><span class="spec-value">\$600‚Äì1,000</span></div>
                <div class="spec-row"><span class="spec-label">Phase 4: Software</span><span class="spec-value">\$400‚Äì800</span></div>
                <div class="spec-row"><span class="spec-label">Phase 5: Polish</span><span class="spec-value">\$200‚Äì400</span></div>
                <div class="spec-row" style="border-top: 1px solid var(--gold-dim); margin-top: 0.5rem; padding-top: 1rem;"><span class="spec-label" style="color: var(--gold);">Total Budget</span><span class="spec-value" style="color: var(--gold);">\$3,500‚Äì6,000</span></div>
            </div>
        </div>
    </section>

    <section id="timeline" aria-labelledby="timeline-title">
        <canvas class="section-canvas" id="canvas-timeline" role="img" aria-label="Flowing timeline particles"></canvas>
        <div class="section-content">
            <h2 id="timeline-title">8 Weeks to Magic</h2>
            <p>From first test to floating prototype.</p>
            <div class="timeline">
                <div class="timeline-item"><div class="timeline-dot"></div><div class="timeline-week">WEEK 1‚Äì2</div><div class="timeline-title">Critical Path Validation</div><div class="timeline-desc">Test custom resonant charging through maglev gap. Calibrate FOD. Verify stability.</div></div>
                <div class="timeline-item"><div class="timeline-dot"></div><div class="timeline-week">WEEK 2‚Äì3</div><div class="timeline-title">Electronics Integration</div><div class="timeline-desc">Assemble CM4 + Coral + ReSpeaker + LEDs. Build power management.</div></div>
                <div class="timeline-item"><div class="timeline-dot"></div><div class="timeline-week">WEEK 3‚Äì5</div><div class="timeline-title">Enclosure & Assembly</div><div class="timeline-desc">Fabricate infinity mirror shell. Build base station. Integrate.</div></div>
                <div class="timeline-item"><div class="timeline-dot"></div><div class="timeline-week">WEEK 5‚Äì7</div><div class="timeline-title">Software & Testing</div><div class="timeline-desc">Voice pipeline, LED animations, API integration. Stability testing.</div></div>
                <div class="timeline-item"><div class="timeline-dot"></div><div class="timeline-week">WEEK 7‚Äì8</div><div class="timeline-title">Polish & Ship</div><div class="timeline-desc">Final QA, documentation, careful packaging. Seattle delivery.</div></div>
            </div>
        </div>
    </section>

    <section id="cta" aria-labelledby="cta-title">
        <canvas class="section-canvas" id="canvas-cta" role="img" aria-label="Infinity symbol with orbiting particle"></canvas>
        <div class="section-content centered">
            <div class="kanji" style="font-size: 5rem; opacity: 0.3; margin-bottom: 2rem;" aria-hidden="true">Èè°</div>
            <h2 id="cta-title">Ready to Build Magic?</h2>
            <p>If you've made hardware float before ‚Äî or you know you can ‚Äî we want to hear from you.</p>
            <div class="cta-buttons" style="justify-content: center; flex-wrap: wrap; gap: 1rem;">
                <a href="mailto:tim@awkronos.com?subject=Kagami%20Orb%20-%20Hardware%20Engineer%20Application&body=Hi%20Tim%2C%0A%0AI%27m%20interested%20in%20building%20the%20Kagami%20Orb%20prototype.%0A%0AMy%20relevant%20experience%3A%0A%0A%0APortfolio%2Fprojects%3A%0A%0A%0ABiggest%20risk%20I%20see%3A%0A%0A%0AAvailability%3A%0A%0A%0ABest%2C" class="btn btn-primary">Apply Now <span aria-hidden="true">‚Üí</span></a>
                <a href="buy.html" class="btn btn-primary">üõí One-Click Buy</a>
                <a href="bom.html" class="btn btn-secondary">View BOM</a>
                <a href="assembly.html" class="btn btn-secondary">Assembly Guide</a>
            </div>
            <p style="margin-top: 3rem; font-style: italic; color: var(--text-ghost);">h(x) ‚â• 0. Always.</p>
        </div>
    </section>

    </main>

    <footer>
        <div class="footer-kanji" aria-hidden="true">Èè°</div>
        <p class="footer-text">Kagami ¬∑ The Mirror ¬∑ Seattle, 2026</p>

        <!-- Primary Navigation -->
        <div class="footer-links" style="flex-wrap: wrap; gap: 1rem 2rem;">
            <a href="spec.html">üìñ Full Spec</a>
            <a href="bom.html">üìã BOM</a>
            <a href="buy.html">üõí Buy Guide</a>
            <a href="assembly.html">üîß Assembly</a>
            <a href="hardware/kagami_orb_bom.csv" download>üì• CSV</a>
        </div>

        <!-- Technical Documentation -->
        <div class="footer-links" style="margin-top: 0.75rem; flex-wrap: wrap; gap: 0.75rem 1.5rem;">
            <a href="system.html">System Design</a>
            <a href="firmware.html">Firmware</a>
            <a href="custom-pcb.html">Custom PCB</a>
            <a href="thermal.html">Thermal</a>
            <a href="fmea.html">FMEA</a>
            <a href="alternatives.html">Alternatives</a>
            <a href="validation.html">Validation</a>
        </div>

        <!-- External Links -->
        <div class="footer-links" style="margin-top: 1.5rem;">
            <a href="https://github.com/awkronos" target="_blank" rel="noopener noreferrer">GitHub</a>
            <a href="#build">Build With Us</a>
            <a href="mailto:tim@awkronos.com">Contact</a>
        </div>
    </footer>

    <script>
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // KAGAMI ORB - REFINED INTERACTIONS + AUDIO
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

        const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // SHARED SETTINGS SYSTEM (Accessibility via gear icon)
        // Settings are in a modal, not wasting screen space
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        (function initSharedSettings() {
            const STORAGE_KEY = 'kagami-settings';
            const TEXT_SCALE_MAP = { small: 0.875, normal: 1, large: 1.25 };

            // Load and apply settings from shared storage
            function loadAndApplySettings() {
                let settings = { textSize: 'normal', theme: 'system', reducedMotion: 'system' };
                try {
                    const stored = localStorage.getItem(STORAGE_KEY);
                    if (stored) settings = { ...settings, ...JSON.parse(stored) };
                } catch (e) {}

                // Apply text scale
                const html = document.documentElement;
                html.classList.remove('kagami-text-small', 'kagami-text-normal', 'kagami-text-large');
                html.classList.add(`kagami-text-${settings.textSize}`);
                html.style.setProperty('--text-scale', TEXT_SCALE_MAP[settings.textSize] || 1);
            }

            // Apply on load
            loadAndApplySettings();

            // Listen for changes from settings modal (cross-tab sync)
            window.addEventListener('storage', (e) => {
                if (e.key === STORAGE_KEY) loadAndApplySettings();
            });

            // Inject inline settings modal (gear icon in top-right)
            injectSettingsUI();

            function injectSettingsUI() {
                // Inject CSS
                const style = document.createElement('style');
                style.textContent = `
                    .kagami-settings-btn {
                        position: fixed; top: 1rem; right: 1rem; z-index: 9998;
                        width: 44px; height: 44px; border: none; border-radius: 50%;
                        background: rgba(255,255,255,0.08); backdrop-filter: blur(8px);
                        cursor: pointer; display: flex; align-items: center; justify-content: center;
                        transition: all 233ms ease-out; color: rgba(255,255,255,0.7);
                    }
                    .kagami-settings-btn:hover { background: rgba(255,255,255,0.15); color: rgba(255,255,255,0.95); transform: rotate(45deg); }
                    .kagami-settings-btn:focus-visible { outline: 2px solid var(--gold); outline-offset: 2px; }
                    .kagami-settings-btn svg { width: 20px; height: 20px; fill: currentColor; }
                    .kagami-settings-overlay {
                        position: fixed; inset: 0; z-index: 9999; background: rgba(0,0,0,0.7);
                        backdrop-filter: blur(4px); display: flex; align-items: center; justify-content: center;
                        opacity: 0; visibility: hidden; transition: opacity 233ms, visibility 233ms;
                    }
                    .kagami-settings-overlay.open { opacity: 1; visibility: visible; }
                    .kagami-settings-modal {
                        background: var(--void-elevated, #0d0d12); border: 1px solid rgba(255,255,255,0.1);
                        border-radius: 16px; width: 90%; max-width: 380px; max-height: 85vh; overflow-y: auto;
                        transform: translateY(20px) scale(0.95); transition: transform 233ms;
                        box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5);
                    }
                    .kagami-settings-overlay.open .kagami-settings-modal { transform: translateY(0) scale(1); }
                    .kagami-settings-header {
                        display: flex; align-items: center; justify-content: space-between;
                        padding: 1.25rem 1.5rem; border-bottom: 1px solid rgba(255,255,255,0.08);
                    }
                    .kagami-settings-title {
                        font-family: 'IBM Plex Mono', monospace; font-size: 0.75rem; font-weight: 500;
                        letter-spacing: 0.1em; text-transform: uppercase; color: rgba(255,255,255,0.9); margin: 0;
                    }
                    .kagami-settings-close {
                        width: 36px; height: 36px; border: none; border-radius: 50%; background: transparent;
                        cursor: pointer; display: flex; align-items: center; justify-content: center;
                        color: rgba(255,255,255,0.5); transition: all 144ms;
                    }
                    .kagami-settings-close:hover { background: rgba(255,255,255,0.1); color: rgba(255,255,255,0.9); }
                    .kagami-settings-content { padding: 1.5rem; }
                    .kagami-settings-group { margin-bottom: 1.5rem; }
                    .kagami-settings-group-label {
                        font-family: 'IBM Plex Mono', monospace; font-size: 0.65rem; font-weight: 500;
                        letter-spacing: 0.15em; text-transform: uppercase; color: rgba(255,255,255,0.4); margin-bottom: 0.75rem;
                    }
                    .kagami-settings-row { display: flex; align-items: center; justify-content: space-between; padding: 0.75rem 0; }
                    .kagami-settings-label { font-family: 'Cormorant Garamond', serif; font-size: 1rem; color: rgba(255,255,255,0.85); }
                    .kagami-toggle-group { display: flex; gap: 0.25rem; background: rgba(255,255,255,0.05); border-radius: 8px; padding: 0.25rem; }
                    .kagami-toggle-btn {
                        padding: 0.5rem 0.75rem; border: none; border-radius: 6px; background: transparent;
                        color: rgba(255,255,255,0.5); font-family: 'IBM Plex Mono', monospace; font-size: 0.75rem;
                        cursor: pointer; transition: all 144ms; min-width: 44px; min-height: 36px;
                    }
                    .kagami-toggle-btn:hover { color: rgba(255,255,255,0.8); }
                    .kagami-toggle-btn[aria-pressed="true"] { background: var(--gold, #d4a84b); color: var(--void, #07070a); }
                    @media (max-width: 640px) { .kagami-settings-modal { width: 100%; max-width: none; max-height: 100vh; height: 100vh; border-radius: 0; } }
                `;
                document.head.appendChild(style);

                // Create button
                const btn = document.createElement('button');
                btn.className = 'kagami-settings-btn';
                btn.setAttribute('aria-label', 'Open settings');
                btn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M19.14 12.94c.04-.31.06-.63.06-.94 0-.31-.02-.63-.06-.94l2.03-1.58a.49.49 0 0 0 .12-.61l-1.92-3.32a.49.49 0 0 0-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54a.484.484 0 0 0-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96a.49.49 0 0 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.04.31-.06.63-.06.94s.02.63.06.94l-2.03 1.58a.49.49 0 0 0-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/></svg>';
                document.body.appendChild(btn);

                // Create overlay
                const overlay = document.createElement('div');
                overlay.className = 'kagami-settings-overlay';
                overlay.setAttribute('role', 'dialog');
                overlay.setAttribute('aria-modal', 'true');
                overlay.innerHTML = `
                    <div class="kagami-settings-modal">
                        <header class="kagami-settings-header">
                            <h2 class="kagami-settings-title">Settings</h2>
                            <button class="kagami-settings-close" aria-label="Close">
                                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                    <line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line>
                                </svg>
                            </button>
                        </header>
                        <div class="kagami-settings-content">
                            <div class="kagami-settings-group">
                                <div class="kagami-settings-group-label">Appearance</div>
                                <div class="kagami-settings-row">
                                    <span class="kagami-settings-label">Text Size</span>
                                    <div class="kagami-toggle-group" role="group">
                                        <button class="kagami-toggle-btn" data-setting="textSize" data-value="small" aria-pressed="false">A-</button>
                                        <button class="kagami-toggle-btn" data-setting="textSize" data-value="normal" aria-pressed="false">A</button>
                                        <button class="kagami-toggle-btn" data-setting="textSize" data-value="large" aria-pressed="false">A+</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                document.body.appendChild(overlay);

                // Get current settings
                let settings = { textSize: 'normal' };
                try { const s = localStorage.getItem(STORAGE_KEY); if (s) settings = { ...settings, ...JSON.parse(s) }; } catch(e){}

                // Update toggle UI
                function updateToggles() {
                    overlay.querySelectorAll('.kagami-toggle-btn').forEach(b => {
                        b.setAttribute('aria-pressed', settings[b.dataset.setting] === b.dataset.value ? 'true' : 'false');
                    });
                }
                updateToggles();

                // Event handlers
                btn.addEventListener('click', () => overlay.classList.add('open'));
                overlay.querySelector('.kagami-settings-close').addEventListener('click', () => overlay.classList.remove('open'));
                overlay.addEventListener('click', e => { if (e.target === overlay) overlay.classList.remove('open'); });
                document.addEventListener('keydown', e => { if (e.key === 'Escape' && overlay.classList.contains('open')) overlay.classList.remove('open'); });

                overlay.querySelectorAll('.kagami-toggle-btn').forEach(b => {
                    b.addEventListener('click', () => {
                        settings[b.dataset.setting] = b.dataset.value;
                        try { localStorage.setItem(STORAGE_KEY, JSON.stringify(settings)); } catch(e){}
                        loadAndApplySettings();
                        updateToggles();
                    });
                });
            }
        })();

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // CUSTOM CURSOR
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const cursor = document.querySelector('.cursor');
        const cursorDot = document.querySelector('.cursor-dot');
        let mouseX = window.innerWidth / 2, mouseY = window.innerHeight / 2, cursorX = 0, cursorY = 0;
        let mouseInWindow = false;

        document.addEventListener('mousemove', e => {
            mouseX = e.clientX;
            mouseY = e.clientY;
            mouseInWindow = true;
        });
        document.addEventListener('mouseleave', () => { mouseInWindow = false; });

        function animateCursor() {
            if (prefersReducedMotion) return;
            cursorX += (mouseX - cursorX) * 0.1;
            cursorY += (mouseY - cursorY) * 0.1;
            cursor.style.left = cursorX - 16 + 'px';
            cursor.style.top = cursorY - 16 + 'px';
            cursorDot.style.left = mouseX - 2 + 'px';
            cursorDot.style.top = mouseY - 2 + 'px';
            requestAnimationFrame(animateCursor);
        }
        if (!prefersReducedMotion) animateCursor();

        const interactives = document.querySelectorAll('a, button, .colony-node, .nav-dot');
        interactives.forEach(el => {
            el.addEventListener('mouseenter', () => cursor.classList.add('hover'));
            el.addEventListener('mouseleave', () => cursor.classList.remove('hover'));
        });

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // PROGRESS BAR WITH ARIA UPDATE
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const progressBar = document.querySelector('.progress-bar');
        window.addEventListener('scroll', () => {
            const progress = Math.round((window.scrollY / (document.documentElement.scrollHeight - window.innerHeight)) * 100);
            progressBar.style.width = progress + '%';
            progressBar.setAttribute('aria-valuenow', progress);
        });

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // SECTION OBSERVER WITH ARIA-CURRENT UPDATE
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const sections = document.querySelectorAll('section');
        const navDots = document.querySelectorAll('.nav-dot');

        const sectionObserver = new IntersectionObserver(entries => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.querySelector('.section-content')?.classList.add('visible');
                    navDots.forEach(dot => {
                        const isActive = dot.dataset.section === entry.target.id;
                        dot.classList.toggle('active', isActive);
                        dot.setAttribute('aria-current', isActive ? 'true' : 'false');
                    });
                }
            });
        }, { threshold: 0.3 });

        sections.forEach(s => sectionObserver.observe(s));

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // HERO LEVITATION ENTRANCE
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        function playHeroEntrance() {
            const kanji = document.querySelector('#hero .kanji');
            const title = document.querySelector('#hero h1');
            const subtitle = document.querySelector('#hero .subtitle');
            const heroContent = document.querySelector('#hero .section-content');

            if (prefersReducedMotion) {
                heroContent.classList.add('visible');
                kanji.classList.add('animated');
                return;
            }

            // Initial state
            kanji.style.opacity = '0';
            kanji.style.transform = 'translateY(60px) scale(0.8)';
            kanji.style.transition = 'none';
            title.style.opacity = '0';
            title.style.transform = 'translateY(30px)';
            title.style.transition = 'none';
            subtitle.style.opacity = '0';
            subtitle.style.transform = 'translateY(20px)';
            subtitle.style.transition = 'none';

            requestAnimationFrame(() => {
                // Kanji floats up and settles with overshoot
                kanji.style.transition = 'opacity 800ms ease, transform 1200ms cubic-bezier(0.34, 1.56, 0.64, 1)';
                kanji.style.opacity = '1';
                kanji.style.transform = 'translateY(-8px) scale(1)';

                // Title follows
                setTimeout(() => {
                    title.style.transition = 'opacity 600ms ease, transform 800ms ease-out';
                    title.style.opacity = '1';
                    title.style.transform = 'translateY(0)';
                }, 400);

                // Subtitle last
                setTimeout(() => {
                    subtitle.style.transition = 'opacity 600ms ease, transform 600ms ease-out';
                    subtitle.style.opacity = '1';
                    subtitle.style.transform = 'translateY(0)';
                }, 700);

                // Add floating animation to kanji after entrance
                setTimeout(() => {
                    kanji.classList.add('animated');
                }, 1200);
            });

            heroContent.classList.add('visible');
        }
        setTimeout(playHeroEntrance, 100);

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // NAV DOTS + KEYBOARD NAVIGATION
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        navDots.forEach(dot => {
            dot.addEventListener('click', () => {
                document.getElementById(dot.dataset.section)?.scrollIntoView({ behavior: 'smooth' });
            });
        });

        // Arrow key navigation between sections
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
                const activeIndex = [...navDots].findIndex(dot => dot.classList.contains('active'));
                if (activeIndex === -1) return;

                let newIndex;
                if (e.key === 'ArrowDown') {
                    newIndex = Math.min(activeIndex + 1, navDots.length - 1);
                } else {
                    newIndex = Math.max(activeIndex - 1, 0);
                }

                if (newIndex !== activeIndex) {
                    e.preventDefault();
                    const targetSection = navDots[newIndex].dataset.section;
                    document.getElementById(targetSection)?.scrollIntoView({ behavior: 'smooth' });
                    navDots[newIndex].focus();
                }
            }
        });

        // Scroll indicator click
        document.querySelector('.scroll-indicator')?.addEventListener('click', () => {
            document.getElementById('concept')?.scrollIntoView({ behavior: 'smooth' });
        });

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // TIMELINE ILLUMINATION
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const timelineItems = document.querySelectorAll('.timeline-item');
        const timelineObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.classList.add('lit');
                }
            });
        }, { threshold: 0.7 });
        timelineItems.forEach(item => timelineObserver.observe(item));

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // CANVAS SETUP WITH DEBOUNCED RESIZE
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        function setupCanvas(id) {
            const canvas = document.getElementById(id);
            if (!canvas) return null;
            const ctx = canvas.getContext('2d');

            let resizeTimeout;
            const resize = () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                }, 100);
            };

            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            window.addEventListener('resize', resize);
            window.addEventListener('orientationchange', () => setTimeout(resize, 200));

            return { canvas, ctx };
        }

        const colonyColors = ['#ff6b35', '#ffd700', '#00d4aa', '#a855f7', '#3b82f6', '#22c55e', '#06b6d4'];

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // HERO CANVAS WITH RIPPLE BURST
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const hero = setupCanvas('canvas-hero');
        if (hero && !prefersReducedMotion) {
            const { canvas, ctx } = hero;
            let mousePullX = 0, mousePullY = 0;
            let burstTime = 0;
            const burstDuration = 2000;
            let burstTriggered = false;

            function triggerBurst() {
                burstTriggered = true;
                burstTime = performance.now();
            }
            setTimeout(triggerBurst, 500);

            function draw(t) {
                ctx.fillStyle = 'rgba(7, 7, 10, 0.08)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                const baseCx = canvas.width / 2, baseCy = canvas.height / 2;
                if (mouseInWindow) {
                    const dx = (mouseX - baseCx) / canvas.width;
                    const dy = (mouseY - baseCy) / canvas.height;
                    mousePullX += (dx * 30 - mousePullX) * 0.05;
                    mousePullY += (dy * 30 - mousePullY) * 0.05;
                } else {
                    mousePullX *= 0.95;
                    mousePullY *= 0.95;
                }
                const cx = baseCx + mousePullX, cy = baseCy + mousePullY;

                // Ripple burst on load
                if (burstTriggered && t - burstTime < burstDuration) {
                    const progress = (t - burstTime) / burstDuration;
                    const eased = 1 - Math.pow(1 - progress, 3);

                    for (let i = 0; i < 5; i++) {
                        const ringProgress = Math.max(0, Math.min(1, (eased - i * 0.15) / 0.7));
                        if (ringProgress > 0 && ringProgress < 1) {
                            const radius = 20 + ringProgress * 400;
                            const alpha = (1 - ringProgress) * 0.4;
                            ctx.strokeStyle = `rgba(212, 168, 75, ${alpha})`;
                            ctx.lineWidth = 3 * (1 - ringProgress);
                            ctx.beginPath();
                            ctx.arc(cx, cy, radius, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                    }
                }

                for (let i = 0; i < 20; i++) {
                    const depth = i + (t * 0.0002) % 1;
                    const scale = Math.pow(0.88, depth);
                    ctx.strokeStyle = 'rgba(212, 168, 75, ' + scale * 0.5 + ')';
                    ctx.lineWidth = Math.max(0.5, 2 * scale);
                    ctx.beginPath();
                    ctx.arc(cx, cy, 150 * scale, 0, Math.PI * 2);
                    ctx.stroke();
                }
                // Color gradient ring cycling through colonies
                const colorIndex = Math.floor((t * 0.0003) % colonyColors.length);
                const ringRadius = 60;
                const gradient = ctx.createRadialGradient(cx, cy, ringRadius - 10, cx, cy, ringRadius + 30);
                gradient.addColorStop(0, 'rgba(212, 168, 75, 0)');
                gradient.addColorStop(0.5, colonyColors[colorIndex] + '40');
                gradient.addColorStop(1, 'rgba(212, 168, 75, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(cx, cy, ringRadius + 30, 0, Math.PI * 2);
                ctx.fill();

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // CHROME SPEAKER (metallic sphere at center)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const speakerRadius = 28;

                // Outer chrome ring (metallic gradient with highlight/shadow)
                const metalGradient = ctx.createRadialGradient(cx - 8, cy - 8, 0, cx, cy, speakerRadius + 5);
                metalGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');      // Highlight
                metalGradient.addColorStop(0.3, 'rgba(200, 200, 200, 0.7)');    // Mid-tone
                metalGradient.addColorStop(0.6, 'rgba(140, 140, 140, 0.6)');    // Shadow side
                metalGradient.addColorStop(1, 'rgba(80, 80, 80, 0.8)');         // Deep shadow

                ctx.fillStyle = metalGradient;
                ctx.beginPath();
                ctx.arc(cx, cy, speakerRadius, 0, Math.PI * 2);
                ctx.fill();

                // Chrome edge (specular highlight on rim)
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.arc(cx, cy, speakerRadius - 1, 0, Math.PI * 2);
                ctx.stroke();

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // LED RING (24 LEDs) WITH REFLECTIONS ON CHROME
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const ledCount = 24;
                const ledRingRadius = 48;  // LED ring outside speaker

                for (let i = 0; i < ledCount; i++) {
                    const angle = (i / ledCount) * Math.PI * 2 + (t * 0.0005);
                    const ledX = cx + Math.cos(angle) * ledRingRadius;
                    const ledY = cy + Math.sin(angle) * ledRingRadius;

                    // Determine LED color based on colony cycle
                    const ledColor = colonyColors[(Math.floor(t * 0.0003) + i) % colonyColors.length];

                    // LED glow (small bright point with halo)
                    const ledGlow = ctx.createRadialGradient(ledX, ledY, 0, ledX, ledY, 8);
                    ledGlow.addColorStop(0, ledColor + 'ff');      // Fully opaque core
                    ledGlow.addColorStop(0.5, ledColor + '80');    // Semi-transparent
                    ledGlow.addColorStop(1, ledColor + '00');      // Transparent edge

                    ctx.fillStyle = ledGlow;
                    ctx.beginPath();
                    ctx.arc(ledX, ledY, 8, 0, Math.PI * 2);
                    ctx.fill();

                    // LED reflection on chrome surface
                    const reflAngle = Math.atan2(ledY - cy, ledX - cx);
                    const reflDist = speakerRadius * 0.75;  // Inside speaker surface
                    const reflX = cx + Math.cos(reflAngle) * reflDist;
                    const reflY = cy + Math.sin(reflAngle) * reflDist;

                    // Reflection is smaller and dimmer
                    const reflGlow = ctx.createRadialGradient(reflX, reflY, 0, reflX, reflY, 4);
                    reflGlow.addColorStop(0, ledColor + '50');     // Dimmer than LED
                    reflGlow.addColorStop(0.7, ledColor + '18');
                    reflGlow.addColorStop(1, ledColor + '00');

                    ctx.fillStyle = reflGlow;
                    ctx.beginPath();
                    ctx.arc(reflX, reflY, 4, 0, Math.PI * 2);
                    ctx.fill();
                }

                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                // SPEAKER CONE (center detail with concentric rings)
                // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                const coneRadius = 12;

                // Speaker cone texture (concentric circles)
                for (let j = 0; j < 4; j++) {
                    const avgRadius = ((j + 0.5) / 4) * coneRadius;
                    ctx.strokeStyle = `rgba(100, 100, 100, ${0.3 - j * 0.06})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(cx, cy, avgRadius, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Speaker cone fill
                const coneGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, coneRadius);
                coneGrad.addColorStop(0, 'rgba(60, 60, 60, 0.3)');
                coneGrad.addColorStop(1, 'rgba(40, 40, 40, 0.1)');
                ctx.fillStyle = coneGrad;
                ctx.beginPath();
                ctx.arc(cx, cy, coneRadius, 0, Math.PI * 2);
                ctx.fill();

                // Central pulsing glow (connects speaker to infinity)
                const pulse = 6 + Math.sin(t * 0.003) * 2;
                const glow = ctx.createRadialGradient(cx, cy, 0, cx, cy, pulse * 5);
                glow.addColorStop(0, 'rgba(212, 168, 75, 0.5)');
                glow.addColorStop(1, 'rgba(212, 168, 75, 0)');
                ctx.fillStyle = glow;
                ctx.beginPath();
                ctx.arc(cx, cy, pulse * 5, 0, Math.PI * 2);
                ctx.fill();

                requestAnimationFrame(draw);
            }
            draw(0);
        }

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // CONCEPT CANVAS WITH MOUSE ATTRACTION
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const concept = setupCanvas('canvas-concept');
        if (concept && !prefersReducedMotion) {
            const { canvas, ctx } = concept;
            const particles = [];
            for (let i = 0; i < 60; i++) {
                const angle = Math.random() * Math.PI * 2;
                const dist = 200 + Math.random() * 300;
                particles.push({ x: Math.cos(angle) * dist, y: Math.sin(angle) * dist, speed: 0.2 + Math.random() * 0.4, size: 1 + Math.random() * 2 });
            }
            function draw(t) {
                ctx.fillStyle = 'rgba(7, 7, 10, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                const cx = canvas.width / 2, cy = canvas.height / 2;
                const rect = canvas.getBoundingClientRect();
                const localMouseX = mouseX - rect.left - rect.width / 2;
                const localMouseY = mouseY - rect.top - rect.height / 2;

                particles.forEach(p => {
                    const dist = Math.sqrt(p.x * p.x + p.y * p.y);
                    if (mouseInWindow) {
                        const dx = localMouseX - p.x;
                        const dy = localMouseY - p.y;
                        const mouseDist = Math.sqrt(dx * dx + dy * dy);
                        if (mouseDist < 200 && mouseDist > 0) {
                            const force = (200 - mouseDist) / 200 * 0.015;
                            p.x += dx * force;
                            p.y += dy * force;
                        }
                    }
                    if (dist > 8) { p.x *= (1 - p.speed * 0.006); p.y *= (1 - p.speed * 0.006); }
                    else { const angle = Math.random() * Math.PI * 2; const d = 250 + Math.random() * 200; p.x = Math.cos(angle) * d; p.y = Math.sin(angle) * d; }
                    const alpha = Math.min(1, dist / 120) * 0.6;
                    ctx.fillStyle = 'rgba(212, 168, 75, ' + alpha + ')';
                    ctx.beginPath();
                    ctx.arc(cx + p.x, cy + p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                const pulse = 8 + Math.sin(t * 0.003) * 3;
                ctx.fillStyle = '#d4a84b';
                ctx.beginPath();
                ctx.arc(cx, cy, pulse, 0, Math.PI * 2);
                ctx.fill();
                requestAnimationFrame(draw);
            }
            draw(0);
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? parseInt(result[1], 16) + ', ' + parseInt(result[2], 16) + ', ' + parseInt(result[3], 16) : '255, 255, 255';
        }

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // INFINITY CANVAS
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const infinity = setupCanvas('canvas-infinity');
        if (infinity && !prefersReducedMotion) {
            const { canvas, ctx } = infinity;
            function draw(t) {
                ctx.fillStyle = 'rgba(7, 7, 10, 0.06)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                const cx = canvas.width / 2, cy = canvas.height / 2;
                const barCount = 15, spacing = 35;
                const startY = cy - (barCount * spacing) / 2;
                for (let i = 0; i < barCount; i++) {
                    const brightness = Math.pow(0.82, i);
                    const width = 250 * brightness;
                    const y = startY + i * spacing;
                    const colorIndex = (Math.floor(t * 0.001) + i) % colonyColors.length;
                    ctx.fillStyle = 'rgba(' + hexToRgb(colonyColors[colorIndex]) + ', ' + brightness * 0.5 + ')';
                    ctx.fillRect(cx - width / 2, y - 1, width, 3);
                }
                const lightPos = (t * 0.0008) % 1;
                const lightY = startY + lightPos * barCount * spacing;
                const lightBrightness = Math.pow(0.82, lightPos * barCount);
                ctx.fillStyle = 'rgba(255, 255, 255, ' + lightBrightness * 0.8 + ')';
                ctx.beginPath();
                ctx.arc(cx, lightY, 5, 0, Math.PI * 2);
                ctx.fill();
                requestAnimationFrame(draw);
            }
            draw(0);
        }

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // SPECS CANVAS
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const specs = setupCanvas('canvas-specs');
        if (specs && !prefersReducedMotion) {
            const { canvas, ctx } = specs;
            function draw(t) {
                ctx.fillStyle = 'rgba(7, 7, 10, 0.04)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.strokeStyle = 'rgba(212, 168, 75, 0.03)';
                ctx.lineWidth = 1;
                const gridSize = 60;
                const offset = (t * 0.02) % gridSize;
                for (let x = -gridSize + offset; x < canvas.width + gridSize; x += gridSize) {
                    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
                }
                for (let y = -gridSize + offset; y < canvas.height + gridSize; y += gridSize) {
                    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
                }
                requestAnimationFrame(draw);
            }
            draw(0);
        }

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // COLONIES CANVAS
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const colonies = setupCanvas('canvas-colonies');
        if (colonies && !prefersReducedMotion) {
            const { canvas, ctx } = colonies;
            function draw(t) {
                ctx.fillStyle = 'rgba(7, 7, 10, 0.04)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                const cx = canvas.width / 2, cy = canvas.height / 2;
                const radius = Math.min(canvas.width, canvas.height) * 0.25;
                for (let i = 0; i < 7; i++) {
                    const angle = (i / 7) * Math.PI * 2 + t * 0.0002;
                    const x = cx + Math.cos(angle) * radius;
                    const y = cy + Math.sin(angle) * radius;
                    for (let j = 0; j < 15; j++) {
                        const ta = angle - j * 0.02;
                        const tx = cx + Math.cos(ta) * radius;
                        const ty = cy + Math.sin(ta) * radius;
                        const alpha = (15 - j) / 15 * 0.2;
                        ctx.fillStyle = 'rgba(' + hexToRgb(colonyColors[i]) + ', ' + alpha + ')';
                        ctx.beginPath(); ctx.arc(tx, ty, 2, 0, Math.PI * 2); ctx.fill();
                    }
                    ctx.fillStyle = colonyColors[i];
                    ctx.beginPath(); ctx.arc(x, y, 6, 0, Math.PI * 2); ctx.fill();
                    const glow = ctx.createRadialGradient(x, y, 0, x, y, 20);
                    glow.addColorStop(0, colonyColors[i] + '40');
                    glow.addColorStop(1, 'transparent');
                    ctx.fillStyle = glow;
                    ctx.beginPath(); ctx.arc(x, y, 20, 0, Math.PI * 2); ctx.fill();
                }
                const pulse = 10 + Math.sin(t * 0.003) * 3;
                const centerGlow = ctx.createRadialGradient(cx, cy, 0, cx, cy, pulse * 3);
                centerGlow.addColorStop(0, 'rgba(212, 168, 75, 0.5)');
                centerGlow.addColorStop(1, 'rgba(212, 168, 75, 0)');
                ctx.fillStyle = centerGlow;
                ctx.beginPath(); ctx.arc(cx, cy, pulse * 3, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#d4a84b';
                ctx.beginPath(); ctx.arc(cx, cy, pulse, 0, Math.PI * 2); ctx.fill();
                requestAnimationFrame(draw);
            }
            draw(0);
        }

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // BUILD CANVAS
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const build = setupCanvas('canvas-build');
        if (build && !prefersReducedMotion) {
            const { canvas, ctx } = build;
            const nodes = [];
            for (let i = 0; i < 40; i++) { nodes.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, vx: (Math.random() - 0.5) * 0.3, vy: (Math.random() - 0.5) * 0.3 }); }
            function draw(t) {
                ctx.fillStyle = 'rgba(7, 7, 10, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                nodes.forEach(n => {
                    n.x += n.vx; n.y += n.vy;
                    if (n.x < 0 || n.x > canvas.width) n.vx *= -1;
                    if (n.y < 0 || n.y > canvas.height) n.vy *= -1;
                });
                ctx.strokeStyle = 'rgba(212, 168, 75, 0.08)';
                ctx.lineWidth = 1;
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        const dx = nodes[i].x - nodes[j].x, dy = nodes[i].y - nodes[j].y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        if (dist < 150) {
                            ctx.globalAlpha = (150 - dist) / 150 * 0.15;
                            ctx.beginPath(); ctx.moveTo(nodes[i].x, nodes[i].y); ctx.lineTo(nodes[j].x, nodes[j].y); ctx.stroke();
                        }
                    }
                }
                ctx.globalAlpha = 1;
                nodes.forEach(n => {
                    ctx.fillStyle = 'rgba(212, 168, 75, 0.4)';
                    ctx.beginPath(); ctx.arc(n.x, n.y, 2, 0, Math.PI * 2); ctx.fill();
                });
                requestAnimationFrame(draw);
            }
            draw(0);
        }

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // AUDIO CANVAS - Chrome speaker with sound waves
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const audio = setupCanvas('canvas-audio');
        if (audio && !prefersReducedMotion) {
            const { canvas, ctx } = audio;
            function draw(t) {
                ctx.fillStyle = 'rgba(7, 7, 10, 0.06)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                const cx = canvas.width / 2, cy = canvas.height / 2;

                // Chrome speaker sphere
                const speakerRadius = 50;
                const metalGrad = ctx.createRadialGradient(cx - 15, cy - 15, 0, cx, cy, speakerRadius + 8);
                metalGrad.addColorStop(0, 'rgba(255, 255, 255, 0.95)');
                metalGrad.addColorStop(0.25, 'rgba(220, 220, 220, 0.8)');
                metalGrad.addColorStop(0.5, 'rgba(180, 180, 180, 0.7)');
                metalGrad.addColorStop(0.75, 'rgba(120, 120, 120, 0.6)');
                metalGrad.addColorStop(1, 'rgba(60, 60, 60, 0.8)');

                ctx.fillStyle = metalGrad;
                ctx.beginPath();
                ctx.arc(cx, cy, speakerRadius, 0, Math.PI * 2);
                ctx.fill();

                // Chrome edge highlight
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(cx, cy, speakerRadius - 2, 0, Math.PI * 2);
                ctx.stroke();

                // Speaker cone
                const coneRadius = 20;
                for (let j = 0; j < 5; j++) {
                    const r = ((j + 0.5) / 5) * coneRadius;
                    ctx.strokeStyle = `rgba(80, 80, 80, ${0.4 - j * 0.07})`;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(cx, cy, r, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Animated sound waves
                for (let i = 0; i < 5; i++) {
                    const progress = ((t * 0.001) + i * 0.2) % 1;
                    const waveRadius = speakerRadius + progress * 200;
                    const alpha = (1 - progress) * 0.4;
                    const colorIndex = Math.floor(t * 0.0005) % colonyColors.length;

                    ctx.strokeStyle = colonyColors[colorIndex] + Math.round(alpha * 255).toString(16).padStart(2, '0');
                    ctx.lineWidth = 3 * (1 - progress);
                    ctx.beginPath();
                    ctx.arc(cx, cy, waveRadius, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // LED reflections on chrome (24 LEDs)
                const ledCount = 24;
                const ledRingRadius = speakerRadius * 1.6;
                for (let i = 0; i < ledCount; i++) {
                    const angle = (i / ledCount) * Math.PI * 2 + (t * 0.0003);
                    const ledColor = colonyColors[(Math.floor(t * 0.0004) + i) % colonyColors.length];

                    // Reflection on chrome surface
                    const reflDist = speakerRadius * 0.65;
                    const reflX = cx + Math.cos(angle) * reflDist;
                    const reflY = cy + Math.sin(angle) * reflDist;

                    const reflGlow = ctx.createRadialGradient(reflX, reflY, 0, reflX, reflY, 6);
                    reflGlow.addColorStop(0, ledColor + '60');
                    reflGlow.addColorStop(0.6, ledColor + '20');
                    reflGlow.addColorStop(1, ledColor + '00');

                    ctx.fillStyle = reflGlow;
                    ctx.beginPath();
                    ctx.arc(reflX, reflY, 6, 0, Math.PI * 2);
                    ctx.fill();
                }

                requestAnimationFrame(draw);
            }
            draw(0);
        }

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // OUTDOOR CANVAS - Covered pavilion with rain and orb
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const outdoor = setupCanvas('canvas-outdoor');
        if (outdoor && !prefersReducedMotion) {
            const { canvas, ctx } = outdoor;
            const raindrops = [];
            for (let i = 0; i < 100; i++) {
                raindrops.push({
                    x: Math.random() * 2000,
                    y: Math.random() * 1000,
                    speed: 4 + Math.random() * 4,
                    length: 10 + Math.random() * 15
                });
            }

            function draw(t) {
                ctx.fillStyle = 'rgba(7, 7, 10, 0.08)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                const cx = canvas.width / 2, cy = canvas.height / 2;

                // Pavilion canopy (curved roof)
                const canopyWidth = 280;
                const canopyHeight = 60;
                const canopyY = cy - 80;

                // Canopy shadow/gradient
                const canopyGrad = ctx.createLinearGradient(cx, canopyY - canopyHeight, cx, canopyY + 20);
                canopyGrad.addColorStop(0, 'rgba(100, 80, 60, 0.6)');
                canopyGrad.addColorStop(0.5, 'rgba(80, 60, 40, 0.5)');
                canopyGrad.addColorStop(1, 'rgba(40, 30, 20, 0.3)');

                ctx.fillStyle = canopyGrad;
                ctx.beginPath();
                ctx.moveTo(cx - canopyWidth/2, canopyY);
                ctx.quadraticCurveTo(cx, canopyY - canopyHeight, cx + canopyWidth/2, canopyY);
                ctx.lineTo(cx + canopyWidth/2, canopyY + 15);
                ctx.quadraticCurveTo(cx, canopyY - canopyHeight + 15, cx - canopyWidth/2, canopyY + 15);
                ctx.closePath();
                ctx.fill();

                // Canopy edge highlight
                ctx.strokeStyle = 'rgba(212, 168, 75, 0.4)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(cx - canopyWidth/2, canopyY);
                ctx.quadraticCurveTo(cx, canopyY - canopyHeight, cx + canopyWidth/2, canopyY);
                ctx.stroke();

                // Support pillars
                ctx.strokeStyle = 'rgba(120, 100, 80, 0.5)';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(cx - canopyWidth/2 + 10, canopyY);
                ctx.lineTo(cx - canopyWidth/2 + 10, cy + 100);
                ctx.moveTo(cx + canopyWidth/2 - 10, canopyY);
                ctx.lineTo(cx + canopyWidth/2 - 10, cy + 100);
                ctx.stroke();

                // Rain (outside canopy area)
                ctx.strokeStyle = 'rgba(100, 150, 200, 0.3)';
                ctx.lineWidth = 1;
                raindrops.forEach(drop => {
                    drop.y += drop.speed;
                    if (drop.y > canvas.height) {
                        drop.y = -drop.length;
                        drop.x = Math.random() * canvas.width;
                    }

                    // Only draw rain outside canopy protection zone
                    const distFromCenter = Math.abs(drop.x - cx);
                    if (distFromCenter > canopyWidth/2 - 20 || drop.y < canopyY - 30) {
                        ctx.beginPath();
                        ctx.moveTo(drop.x, drop.y);
                        ctx.lineTo(drop.x - 2, drop.y + drop.length);
                        ctx.stroke();
                    }
                });

                // Base station
                ctx.fillStyle = 'rgba(80, 60, 40, 0.6)';
                ctx.beginPath();
                ctx.ellipse(cx, cy + 60, 60, 15, 0, 0, Math.PI * 2);
                ctx.fill();

                // Floating orb (protected under canopy)
                const orbY = cy + 10;
                const orbFloat = Math.sin(t * 0.002) * 5;

                // Orb glow
                const orbGlow = ctx.createRadialGradient(cx, orbY + orbFloat, 0, cx, orbY + orbFloat, 50);
                orbGlow.addColorStop(0, 'rgba(212, 168, 75, 0.4)');
                orbGlow.addColorStop(0.5, 'rgba(212, 168, 75, 0.15)');
                orbGlow.addColorStop(1, 'rgba(212, 168, 75, 0)');
                ctx.fillStyle = orbGlow;
                ctx.beginPath();
                ctx.arc(cx, orbY + orbFloat, 50, 0, Math.PI * 2);
                ctx.fill();

                // Orb shell (chrome with LED colors)
                const orbGrad = ctx.createRadialGradient(cx - 8, orbY + orbFloat - 8, 0, cx, orbY + orbFloat, 30);
                orbGrad.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                orbGrad.addColorStop(0.3, 'rgba(180, 180, 180, 0.6)');
                orbGrad.addColorStop(0.7, 'rgba(100, 100, 100, 0.5)');
                orbGrad.addColorStop(1, 'rgba(50, 50, 50, 0.7)');

                ctx.fillStyle = orbGrad;
                ctx.beginPath();
                ctx.arc(cx, orbY + orbFloat, 28, 0, Math.PI * 2);
                ctx.fill();

                // LED ring on orb
                const ledCount = 12;
                for (let i = 0; i < ledCount; i++) {
                    const angle = (i / ledCount) * Math.PI * 2 + (t * 0.001);
                    const ledX = cx + Math.cos(angle) * 22;
                    const ledY = orbY + orbFloat + Math.sin(angle) * 22;
                    const ledColor = colonyColors[(Math.floor(t * 0.0005) + i) % colonyColors.length];

                    ctx.fillStyle = ledColor + 'aa';
                    ctx.beginPath();
                    ctx.arc(ledX, ledY, 3, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Stars in background (to indicate nighttime outdoor)
                for (let i = 0; i < 30; i++) {
                    const starX = (i * 97 + t * 0.01) % canvas.width;
                    const starY = (i * 53) % (canopyY - 100);
                    const twinkle = 0.3 + Math.sin(t * 0.003 + i) * 0.2;
                    ctx.fillStyle = `rgba(255, 255, 255, ${twinkle})`;
                    ctx.beginPath();
                    ctx.arc(starX, starY, 1, 0, Math.PI * 2);
                    ctx.fill();
                }

                requestAnimationFrame(draw);
            }
            draw(0);
        }

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // TIMELINE CANVAS
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const timeline = setupCanvas('canvas-timeline');
        if (timeline && !prefersReducedMotion) {
            const { canvas, ctx } = timeline;
            function draw(t) {
                ctx.fillStyle = 'rgba(7, 7, 10, 0.04)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                const x = canvas.width * 0.15;
                const particleY = (t * 0.1) % canvas.height;
                for (let i = 0; i < 20; i++) {
                    const y = (particleY + i * 30) % canvas.height;
                    const alpha = (20 - i) / 20 * 0.3;
                    ctx.fillStyle = 'rgba(212, 168, 75, ' + alpha + ')';
                    ctx.beginPath(); ctx.arc(x, y, 3, 0, Math.PI * 2); ctx.fill();
                }
                requestAnimationFrame(draw);
            }
            draw(0);
        }

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // CTA CANVAS
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const cta = setupCanvas('canvas-cta');
        if (cta && !prefersReducedMotion) {
            const { canvas, ctx } = cta;
            function draw(t) {
                ctx.fillStyle = 'rgba(7, 7, 10, 0.03)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                const cx = canvas.width / 2, cy = canvas.height / 2;
                ctx.strokeStyle = 'rgba(212, 168, 75, 0.15)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                const scale = Math.min(canvas.width, canvas.height) * 0.12;
                for (let angle = 0; angle <= Math.PI * 2; angle += 0.02) {
                    const cos = Math.cos(angle), sin = Math.sin(angle);
                    const denom = 1 + sin * sin;
                    const x = cx + (scale * 2 * cos) / denom;
                    const y = cy + (scale * sin * cos) / denom;
                    if (angle === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.stroke();
                const angle = (t * 0.0005) % (Math.PI * 2);
                const cos = Math.cos(angle), sin = Math.sin(angle);
                const denom = 1 + sin * sin;
                const px = cx + (scale * 2 * cos) / denom;
                const py = cy + (scale * sin * cos) / denom;
                for (let i = 0; i < 25; i++) {
                    const ta = ((t * 0.0005) - i * 0.025) % (Math.PI * 2);
                    const tc = Math.cos(ta), ts = Math.sin(ta);
                    const td = 1 + ts * ts;
                    const tx = cx + (scale * 2 * tc) / td;
                    const ty = cy + (scale * ts * tc) / td;
                    const alpha = (25 - i) / 25 * 0.4;
                    ctx.fillStyle = 'rgba(212, 168, 75, ' + alpha + ')';
                    ctx.beginPath(); ctx.arc(tx, ty, 2, 0, Math.PI * 2); ctx.fill();
                }
                ctx.fillStyle = '#d4a84b';
                ctx.beginPath(); ctx.arc(px, py, 5, 0, Math.PI * 2); ctx.fill();
                requestAnimationFrame(draw);
            }
            draw(0);
        }

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // KONAMI CODE EASTER EGG: ‚Üë‚Üë‚Üì‚Üì‚Üê‚Üí‚Üê‚ÜíBA
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const konamiCode = [38, 38, 40, 40, 37, 39, 37, 39, 66, 65];
        let konamiIndex = 0;

        document.addEventListener('keydown', (e) => {
            if (e.keyCode === konamiCode[konamiIndex]) {
                konamiIndex++;
                if (konamiIndex === konamiCode.length) {
                    activateSecretMode();
                    konamiIndex = 0;
                }
            } else {
                konamiIndex = 0;
            }
        });

        function activateSecretMode() {
            document.body.classList.add('secret-mode');

            const orbs = [];
            colonyColors.forEach((color, i) => {
                const orb = document.createElement('div');
                orb.className = 'secret-orb';
                orb.style.cssText = `
                    position: fixed;
                    width: 12px;
                    height: 12px;
                    border-radius: 50%;
                    background: ${color};
                    box-shadow: 0 0 20px ${color};
                    pointer-events: none;
                    z-index: 10002;
                `;
                document.body.appendChild(orb);
                orbs.push({ el: orb, angle: (i / 7) * Math.PI * 2, radius: 60 + i * 10 });
            });

            function animateOrbs() {
                orbs.forEach((orb, i) => {
                    orb.angle += 0.02 + i * 0.003;
                    const x = mouseX + Math.cos(orb.angle) * orb.radius;
                    const y = mouseY + Math.sin(orb.angle) * orb.radius;
                    orb.el.style.left = x - 6 + 'px';
                    orb.el.style.top = y - 6 + 'px';
                });
                if (document.body.classList.contains('secret-mode')) {
                    requestAnimationFrame(animateOrbs);
                }
            }
            animateOrbs();

            setTimeout(() => {
                document.body.classList.remove('secret-mode');
                orbs.forEach(orb => orb.el.remove());
            }, 10000);
        }

        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // KAGAMI AUDIO ENGINE (Web Audio API)
        // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        class KagamiAudioEngine {
            constructor() {
                this.ctx = null;
                this.masterGain = null;
                this.initialized = false;
                this.enabled = !prefersReducedMotion;
                this.droneOscillators = [];
                this.droneGain = null;

                this.colonyFrequencies = {
                    spark: 329.63, forge: 369.99, flow: 415.30, nexus: 493.88,
                    beacon: 554.37, grove: 659.25, crystal: 739.99
                };

                if (this.enabled) this.setupActivation();
            }

            setupActivation() {
                const activate = () => {
                    if (!this.initialized) this.init();
                    ['click', 'touchstart', 'keydown'].forEach(e => document.removeEventListener(e, activate));
                };
                ['click', 'touchstart', 'keydown'].forEach(e => document.addEventListener(e, activate, { once: false }));
            }

            init() {
                if (this.initialized || !this.enabled) return;
                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    this.masterGain = this.ctx.createGain();
                    this.masterGain.gain.value = 0.15;
                    this.masterGain.connect(this.ctx.destination);
                    this.startDrone();
                    this.initialized = true;
                    this.setupListeners();
                } catch (e) { this.enabled = false; }
            }

            startDrone() {
                if (!this.ctx) return;
                this.droneGain = this.ctx.createGain();
                this.droneGain.gain.value = 0;
                this.droneGain.connect(this.masterGain);

                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 400;
                filter.connect(this.droneGain);

                const fundamentalFreq = 82.41;
                const droneConfig = [
                    { freq: fundamentalFreq, gain: 0.3, detune: 0 },
                    { freq: fundamentalFreq, gain: 0.2, detune: 3 },
                    { freq: fundamentalFreq * 2, gain: 0.15, detune: 0 },
                ];

                droneConfig.forEach(config => {
                    const osc = this.ctx.createOscillator();
                    const oscGain = this.ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = config.freq;
                    osc.detune.value = config.detune;
                    oscGain.gain.value = config.gain;
                    osc.connect(oscGain);
                    oscGain.connect(filter);
                    osc.start();
                    this.droneOscillators.push({ osc, gain: oscGain });
                });

                this.droneGain.gain.linearRampToValueAtTime(0.2, this.ctx.currentTime + 2.584);
            }

            playHover(type = 'default') {
                if (!this.ctx || !this.enabled) return;
                const now = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const configs = {
                    default: { freq: 2400, duration: 0.089 },
                    nav: { freq: 2800, duration: 0.089 },
                    button: { freq: 3200, duration: 0.144 }
                };
                const config = configs[type] || configs.default;
                osc.type = 'sine';
                osc.frequency.value = config.freq;
                gain.gain.value = 0;
                gain.gain.linearRampToValueAtTime(0.06, now + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.001, now + config.duration);
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start(now);
                osc.stop(now + config.duration + 0.01);
            }

            playColonyPulse(colonyName) {
                if (!this.ctx || !this.enabled) return;
                const freq = this.colonyFrequencies[colonyName];
                if (!freq) return;
                const now = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.value = freq;
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.1, now + 0.05);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.377);
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start(now);
                osc.stop(now + 0.377);
            }

            setupListeners() {
                document.querySelectorAll('.nav-dot').forEach(el => {
                    el.addEventListener('mouseenter', () => this.playHover('nav'));
                });
                document.querySelectorAll('.btn').forEach(el => {
                    el.addEventListener('mouseenter', () => this.playHover('button'));
                });
                document.querySelectorAll('.colony-node').forEach(el => {
                    el.addEventListener('mouseenter', () => {
                        const colony = el.dataset.colony;
                        if (colony) this.playColonyPulse(colony);
                    });
                });
            }
        }

        const kagamiAudio = new KagamiAudioEngine();
        window.kagamiAudio = kagamiAudio;
    </script>
</body>
</html>
