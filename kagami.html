<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>鏡 — KAGAMI — ∞ Infinity Mirror Room</title>
    <meta name="description" content="Step inside the mirror. Become infinite. A Kusama-inspired infinity room where seven colonies float as luminous orbs in endless reflection.">
    <style>
/* ═══════════════════════════════════════════════════════════════════════════════════
   鏡 KAGAMI — INFINITY MIRROR ROOM
   Inspired by Yayoi Kusama's Infinity Rooms
   OVER 9000 REFLECTIONS
═══════════════════════════════════════════════════════════════════════════════════ */

* { margin: 0; padding: 0; box-sizing: border-box; }

html, body {
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: #000;
}

#infinity-room {
    position: fixed;
    inset: 0;
    background: #000;
}

/* Navigation - minimal, ethereal */
.nav-overlay {
    position: fixed;
    bottom: 2rem;
    left: 50%;
    transform: translateX(-50%);
    z-index: 100;
    display: flex;
    gap: 0.75rem;
    opacity: 0;
    animation: fade-in 2s ease 1s forwards;
}

@keyframes fade-in {
    to { opacity: 1; }
}

.nav-orb {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    transition: all 0.4s cubic-bezier(0.23, 1, 0.32, 1);
    position: relative;
}

.nav-orb[data-colony="spark"] { background: #FF6B35; box-shadow: 0 0 15px #FF6B35; }
.nav-orb[data-colony="forge"] { background: #FF9F1C; box-shadow: 0 0 15px #FF9F1C; }
.nav-orb[data-colony="flow"] { background: #00D4AA; box-shadow: 0 0 15px #00D4AA; }
.nav-orb[data-colony="nexus"] { background: #AF52DE; box-shadow: 0 0 15px #AF52DE; }
.nav-orb[data-colony="beacon"] { background: #FFD60A; box-shadow: 0 0 15px #FFD60A; }
.nav-orb[data-colony="grove"] { background: #32D74B; box-shadow: 0 0 15px #32D74B; }
.nav-orb[data-colony="crystal"] { background: #64D2FF; box-shadow: 0 0 15px #64D2FF; }

.nav-orb:hover {
    transform: scale(2);
    box-shadow: 0 0 30px currentColor, 0 0 60px currentColor;
}

/* Loading */
.loading {
    position: fixed;
    inset: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: #000;
    z-index: 1000;
    transition: opacity 2s ease;
}

.loading.hidden {
    opacity: 0;
    pointer-events: none;
}

.loading-kanji {
    font-size: 8rem;
    color: rgba(255,255,255,0.05);
    font-family: serif;
    animation: pulse 2s ease-in-out infinite;
}

@keyframes pulse {
    0%, 100% { opacity: 0.05; transform: scale(1); }
    50% { opacity: 0.15; transform: scale(1.05); }
}

.loading-text {
    font-size: 0.7rem;
    letter-spacing: 0.5em;
    color: rgba(255,255,255,0.2);
    text-transform: uppercase;
    margin-top: 2rem;
    font-family: system-ui, sans-serif;
}
    </style>
</head>
<body>
    <div class="loading">
        <div class="loading-kanji">鏡</div>
        <span class="loading-text">Entering the infinite...</span>
    </div>
    
    <div id="infinity-room"></div>
    
    <nav class="nav-overlay">
        <a href="spark.html" class="nav-orb" data-colony="spark" title="Spark"></a>
        <a href="forge.html" class="nav-orb" data-colony="forge" title="Forge"></a>
        <a href="flow.html" class="nav-orb" data-colony="flow" title="Flow"></a>
        <a href="nexus.html" class="nav-orb" data-colony="nexus" title="Nexus"></a>
        <a href="beacon.html" class="nav-orb" data-colony="beacon" title="Beacon"></a>
        <a href="grove-gallery/" class="nav-orb" data-colony="grove" title="Grove"></a>
        <a href="crystal-gallery/" class="nav-orb" data-colony="crystal" title="Crystal"></a>
    </nav>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
/* ═══════════════════════════════════════════════════════════════════════════════════
   INFINITY MIRROR ROOM — TRUE KUSAMA STYLE
   
   Key insight: Real infinity rooms work by having MIRRORS reflect LIGHTS.
   The lights appear to recede infinitely because each reflection is slightly dimmer.
   
   Implementation:
   1. Mirrored environment using CubeCamera
   2. Multiple layers of orbs at different depths
   3. Strategic positioning to maximize reflection recursion
   4. Vibrant, saturated colors with strong glow
═══════════════════════════════════════════════════════════════════════════════════ */

class InfinityMirrorRoom {
    constructor() {
        this.container = document.getElementById('infinity-room');
        this.mainOrbs = [];
        this.smallOrbs = [];
        this.reflectionOrbs = []; // Additional layers for depth
        this.time = 0;
        this.mouseX = 0;
        this.mouseY = 0;
        
        // Colony colors - VIBRANT
        this.colors = {
            spark:   0xFF4422, // Hot red-orange
            forge:   0xFFAA00, // Bright amber
            flow:    0x00FFCC, // Electric cyan
            nexus:   0xBB44FF, // Vivid purple
            beacon:  0xFFDD00, // Pure gold
            grove:   0x22FF66, // Neon green
            crystal: 0x44DDFF  // Ice blue
        };
        this.colorArray = Object.values(this.colors);
        
        this.init();
        this.createEnvironment();
        this.createInfiniteOrbs();
        this.setupInteraction();
        this.animate();
        
        setTimeout(() => {
            document.querySelector('.loading').classList.add('hidden');
        }, 2000);
    }
    
    init() {
        // Scene
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x000000);
        
        // Camera - inside the room
        this.camera = new THREE.PerspectiveCamera(
            85, // Wide FOV for immersion
            window.innerWidth / window.innerHeight,
            0.01,
            1000
        );
        this.camera.position.set(0, 0, 0);
        
        // Renderer - high quality
        this.renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            powerPreference: "high-performance"
        });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
        this.renderer.toneMappingExposure = 1.0;
        this.renderer.outputEncoding = THREE.sRGBEncoding;
        this.container.appendChild(this.renderer.domElement);
        
        // Cube camera for real reflections
        this.cubeRenderTarget = new THREE.WebGLCubeRenderTarget(512, {
            format: THREE.RGBAFormat,
            generateMipmaps: true,
            minFilter: THREE.LinearMipmapLinearFilter
        });
        this.cubeCamera = new THREE.CubeCamera(0.01, 100, this.cubeRenderTarget);
        this.scene.add(this.cubeCamera);
    }
    
    createEnvironment() {
        // Create the mirror box - 6 reflective walls
        const roomSize = 30;
        
        // Mirror material
        const mirrorMaterial = new THREE.MeshStandardMaterial({
            color: 0x0a0a0a,
            metalness: 0.98,
            roughness: 0.02,
            envMap: this.cubeRenderTarget.texture,
            envMapIntensity: 3.0,
            side: THREE.BackSide
        });
        
        const roomGeometry = new THREE.BoxGeometry(roomSize, roomSize, roomSize);
        this.room = new THREE.Mesh(roomGeometry, mirrorMaterial);
        this.scene.add(this.room);
        
        // Very subtle ambient - most light comes from orbs
        const ambient = new THREE.AmbientLight(0xffffff, 0.02);
        this.scene.add(ambient);
    }
    
    createInfiniteOrbs() {
        // Layer 1: The Seven Main Colony Orbs (large, prominent)
        const mainPositions = [
            { x: 0, y: 3, z: -8 },      // Spark - top center
            { x: -5, y: -2, z: -7 },    // Forge - lower left
            { x: 5, y: -2, z: -7 },     // Flow - lower right
            { x: 0, y: -4, z: -9 },     // Nexus - bottom center
            { x: -4, y: 2, z: -6 },     // Beacon - upper left
            { x: 4, y: 2, z: -6 },      // Grove - upper right
            { x: 0, y: 0, z: -10 }      // Crystal - dead center back
        ];
        
        this.colorArray.forEach((color, i) => {
            const orb = this.createGlowingOrb(color, 0.5 + Math.random() * 0.3);
            const pos = mainPositions[i];
            orb.position.set(pos.x, pos.y, pos.z);
            
            // Strong point light
            const light = new THREE.PointLight(color, 3, 15);
            light.position.copy(orb.position);
            this.scene.add(light);
            
            orb.userData = {
                basePos: { ...pos },
                phase: Math.random() * Math.PI * 2,
                speed: 0.2 + Math.random() * 0.2,
                light: light,
                type: 'main'
            };
            
            this.mainOrbs.push(orb);
            this.scene.add(orb);
        });
        
        // Layer 2: Medium orbs scattered around
        for (let i = 0; i < 50; i++) {
            const color = this.colorArray[Math.floor(Math.random() * this.colorArray.length)];
            const orb = this.createGlowingOrb(color, 0.15 + Math.random() * 0.2);
            
            const angle = Math.random() * Math.PI * 2;
            const distance = 3 + Math.random() * 10;
            const height = (Math.random() - 0.5) * 12;
            
            orb.position.set(
                Math.cos(angle) * distance,
                height,
                Math.sin(angle) * distance - 5
            );
            
            // Smaller lights
            const light = new THREE.PointLight(color, 0.8, 6);
            light.position.copy(orb.position);
            this.scene.add(light);
            
            orb.userData = {
                basePos: { ...orb.position },
                phase: Math.random() * Math.PI * 2,
                speed: 0.1 + Math.random() * 0.3,
                light: light,
                type: 'medium'
            };
            
            this.smallOrbs.push(orb);
            this.scene.add(orb);
        }
        
        // Layer 3: Tiny floating dots - the "polka dots"
        for (let i = 0; i < 300; i++) {
            const color = this.colorArray[Math.floor(Math.random() * this.colorArray.length)];
            const orb = this.createGlowingOrb(color, 0.03 + Math.random() * 0.08);
            
            // Distribute in a sphere around viewer
            const phi = Math.random() * Math.PI * 2;
            const theta = Math.random() * Math.PI;
            const r = 2 + Math.random() * 12;
            
            orb.position.set(
                r * Math.sin(theta) * Math.cos(phi),
                r * Math.sin(theta) * Math.sin(phi) - 2,
                r * Math.cos(theta) - 5
            );
            
            orb.userData = {
                basePos: { ...orb.position },
                phase: Math.random() * Math.PI * 2,
                speed: 0.05 + Math.random() * 0.2,
                type: 'tiny'
            };
            
            this.smallOrbs.push(orb);
            this.scene.add(orb);
        }
        
        // Layer 4: "Reflection" orbs - placed behind the mirrors for depth illusion
        for (let i = 0; i < 100; i++) {
            const color = this.colorArray[Math.floor(Math.random() * this.colorArray.length)];
            const size = 0.1 + Math.random() * 0.3;
            
            const geometry = new THREE.SphereGeometry(size, 16, 16);
            const material = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.3 + Math.random() * 0.4
            });
            
            const orb = new THREE.Mesh(geometry, material);
            
            // Place at edges of room
            const edge = (Math.random() > 0.5 ? 1 : -1) * (12 + Math.random() * 3);
            const axis = Math.floor(Math.random() * 3);
            
            if (axis === 0) orb.position.set(edge, (Math.random() - 0.5) * 20, (Math.random() - 0.5) * 20);
            else if (axis === 1) orb.position.set((Math.random() - 0.5) * 20, edge, (Math.random() - 0.5) * 20);
            else orb.position.set((Math.random() - 0.5) * 20, (Math.random() - 0.5) * 20, edge - 5);
            
            orb.userData = {
                phase: Math.random() * Math.PI * 2,
                speed: 0.02 + Math.random() * 0.05
            };
            
            this.reflectionOrbs.push(orb);
            this.scene.add(orb);
        }
    }
    
    createGlowingOrb(color, size) {
        // Core sphere
        const geometry = new THREE.SphereGeometry(size, 32, 32);
        const material = new THREE.MeshStandardMaterial({
            color: color,
            emissive: color,
            emissiveIntensity: 2.5,
            metalness: 0.1,
            roughness: 0.2
        });
        
        const orb = new THREE.Mesh(geometry, material);
        
        // Add glow sprite
        const spriteMaterial = new THREE.SpriteMaterial({
            map: this.createGlowTexture(),
            color: color,
            transparent: true,
            blending: THREE.AdditiveBlending,
            opacity: 0.6
        });
        
        const sprite = new THREE.Sprite(spriteMaterial);
        sprite.scale.set(size * 6, size * 6, 1);
        orb.add(sprite);
        
        return orb;
    }
    
    createGlowTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 128;
        canvas.height = 128;
        const ctx = canvas.getContext('2d');
        
        const gradient = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
        gradient.addColorStop(0, 'rgba(255,255,255,1)');
        gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
        gradient.addColorStop(0.4, 'rgba(255,255,255,0.3)');
        gradient.addColorStop(1, 'rgba(255,255,255,0)');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 128, 128);
        
        const texture = new THREE.CanvasTexture(canvas);
        return texture;
    }
    
    setupInteraction() {
        window.addEventListener('resize', () => {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Mouse look
        document.addEventListener('mousemove', (e) => {
            this.mouseX = (e.clientX / window.innerWidth) * 2 - 1;
            this.mouseY = (e.clientY / window.innerHeight) * 2 - 1;
        });
        
        // Touch
        document.addEventListener('touchmove', (e) => {
            if (e.touches.length > 0) {
                this.mouseX = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
                this.mouseY = (e.touches[0].clientY / window.innerHeight) * 2 - 1;
            }
        }, { passive: true });
        
        // Gyroscope
        if (window.DeviceOrientationEvent) {
            window.addEventListener('deviceorientation', (e) => {
                if (e.gamma !== null) {
                    this.mouseX = Math.max(-1, Math.min(1, e.gamma / 30));
                    this.mouseY = Math.max(-1, Math.min(1, (e.beta - 60) / 30));
                }
            });
        }
    }
    
    animate() {
        requestAnimationFrame(() => this.animate());
        
        this.time += 0.006;
        
        // Smooth camera rotation
        const targetRotX = this.mouseY * 0.4;
        const targetRotY = this.mouseX * 0.6;
        
        this.camera.rotation.x += (targetRotX - this.camera.rotation.x) * 0.03;
        this.camera.rotation.y += (targetRotY - this.camera.rotation.y) * 0.03;
        
        // Gentle camera drift
        this.camera.position.x = Math.sin(this.time * 0.5) * 0.3;
        this.camera.position.y = Math.cos(this.time * 0.3) * 0.2;
        
        // Animate main orbs
        this.mainOrbs.forEach(orb => {
            const d = orb.userData;
            const t = this.time * d.speed + d.phase;
            
            orb.position.x = d.basePos.x + Math.sin(t) * 0.5;
            orb.position.y = d.basePos.y + Math.cos(t * 0.7) * 0.6;
            orb.position.z = d.basePos.z + Math.sin(t * 0.5) * 0.3;
            
            // Pulse
            const pulse = 1.8 + Math.sin(t * 2) * 0.7;
            orb.material.emissiveIntensity = pulse;
            
            d.light.position.copy(orb.position);
            d.light.intensity = pulse * 1.5;
        });
        
        // Animate small orbs
        this.smallOrbs.forEach(orb => {
            const d = orb.userData;
            const t = this.time * d.speed + d.phase;
            
            orb.position.x = d.basePos.x + Math.sin(t) * 0.3;
            orb.position.y = d.basePos.y + Math.cos(t * 0.8) * 0.4;
            orb.position.z = d.basePos.z + Math.sin(t * 0.6) * 0.2;
            
            if (d.light) {
                d.light.position.copy(orb.position);
                d.light.intensity = 0.5 + Math.sin(t * 2) * 0.3;
            }
            
            if (orb.material.emissiveIntensity !== undefined) {
                orb.material.emissiveIntensity = 2 + Math.sin(t * 2) * 0.5;
            }
        });
        
        // Animate reflection orbs
        this.reflectionOrbs.forEach(orb => {
            const d = orb.userData;
            orb.material.opacity = 0.2 + Math.sin(this.time * d.speed + d.phase) * 0.15;
        });
        
        // Update cube camera for reflections
        this.room.visible = false;
        this.cubeCamera.update(this.renderer, this.scene);
        this.room.visible = true;
        
        this.renderer.render(this.scene, this.camera);
    }
}

// Initialize
document.addEventListener('DOMContentLoaded', () => {
    new InfinityMirrorRoom();
});
    </script>
</body>
</html>
