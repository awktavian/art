<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Seven Elementary Catastrophes — A Mathematical Atlas</title>
    <style>
        :root {
            --ink: #1a1a1a;
            --paper: #fefefa;
            --gray-1: #f5f5f3;
            --gray-2: #e8e8e4;
            --gray-3: #d0d0c8;
            --gray-4: #888880;
            --gray-5: #666660;
            --accent: #c4a35a;
            --spark: #e91e63;
            --forge: #c62828;
            --flow: #00838f;
            --nexus: #6a1b9a;
            --beacon: #f9a825;
            --grove: #2e7d32;
            --crystal: #1565c0;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        html {
            font-size: 16px;
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Palatino Linotype', 'Book Antiqua', Palatino, Georgia, serif;
            background: var(--paper);
            color: var(--ink);
            line-height: 1.6;
            max-width: 1400px;
            margin: 0 auto;
            padding: 3rem 2rem;
        }

        /* === TYPOGRAPHY === */
        h1 {
            font-size: 2rem;
            font-weight: normal;
            letter-spacing: 0.02em;
            margin-bottom: 0.5rem;
            border-bottom: 1px solid var(--gray-3);
            padding-bottom: 0.5rem;
        }

        .subtitle {
            font-style: italic;
            color: var(--gray-5);
            margin-bottom: 3rem;
        }

        h2 {
            font-size: 1.3rem;
            font-weight: normal;
            margin: 3rem 0 1rem;
            color: var(--ink);
        }

        h3 {
            font-size: 1rem;
            font-weight: normal;
            font-style: italic;
            margin: 1.5rem 0 0.5rem;
            color: var(--gray-5);
        }

        p {
            max-width: 65ch;
            margin-bottom: 1rem;
        }

        .small { font-size: 0.85rem; }
        .muted { color: var(--gray-5); }

        /* === MATH === */
        .math {
            font-family: 'Times New Roman', Times, serif;
            font-style: italic;
        }

        .equation {
            display: block;
            text-align: center;
            margin: 1.5rem 0;
            font-family: 'Times New Roman', Times, serif;
            font-size: 1.1rem;
        }

        .equation-label {
            float: right;
            color: var(--gray-4);
            font-size: 0.85rem;
        }

        sup { font-size: 0.7em; vertical-align: super; }
        sub { font-size: 0.7em; vertical-align: sub; }

        /* === DIMENSIONAL TABLE === */
        .dim-table {
            width: 100%;
            border-collapse: collapse;
            margin: 2rem 0;
            font-size: 0.9rem;
        }

        .dim-table th {
            text-align: left;
            font-weight: normal;
            font-style: italic;
            padding: 0.5rem 1rem 0.5rem 0;
            border-bottom: 1px solid var(--ink);
            color: var(--gray-5);
        }

        .dim-table td {
            padding: 0.6rem 1rem 0.6rem 0;
            border-bottom: 1px solid var(--gray-2);
            vertical-align: top;
        }

        .dim-table tr:last-child td {
            border-bottom: 1px solid var(--ink);
        }

        .dim-table .name {
            font-weight: 500;
        }

        .dim-table .colony {
            font-size: 0.8rem;
            padding: 0.15rem 0.4rem;
            border-radius: 2px;
            color: white;
        }

        /* === VISUALIZATION GRID === */
        .catastrophe-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            margin: 2rem 0;
        }

        .catastrophe-card {
            background: var(--gray-1);
            padding: 1.5rem;
            position: relative;
        }

        .catastrophe-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
        }

        .card-fold::before { background: var(--spark); }
        .card-cusp::before { background: var(--forge); }
        .card-swallowtail::before { background: var(--flow); }
        .card-butterfly::before { background: var(--nexus); }
        .card-hyperbolic::before { background: var(--beacon); }
        .card-elliptic::before { background: var(--grove); }
        .card-parabolic::before { background: var(--crystal); }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--gray-3);
        }

        .card-title {
            font-size: 1.1rem;
            font-weight: 500;
        }

        .card-class {
            font-family: 'Times New Roman', Times, serif;
            font-style: italic;
            color: var(--gray-5);
        }

        .card-equation {
            font-family: 'Times New Roman', Times, serif;
            font-size: 1rem;
            margin: 1rem 0;
            text-align: center;
            padding: 0.75rem;
            background: var(--paper);
            border-left: 2px solid var(--gray-3);
        }

        .card-dims {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
            margin: 1rem 0;
            font-size: 0.8rem;
        }

        .dim-box {
            text-align: center;
            padding: 0.5rem;
            background: var(--paper);
        }

        .dim-label {
            color: var(--gray-5);
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .dim-value {
            font-size: 1.2rem;
            font-weight: 500;
            margin-top: 0.2rem;
        }

        /* === CANVAS VISUALIZATIONS === */
        .viz-container {
            position: relative;
            margin: 1rem 0;
        }

        .viz-row {
            display: flex;
            gap: 1rem;
        }

        .viz-cell {
            flex: 1;
            position: relative;
        }

        .viz-label {
            font-size: 0.75rem;
            color: var(--gray-5);
            text-align: center;
            margin-top: 0.3rem;
            font-style: italic;
        }

        canvas {
            width: 100%;
            height: auto;
            display: block;
            background: var(--paper);
        }

        /* === SPARKLINES === */
        .sparkline-row {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin: 0.5rem 0;
        }

        .sparkline-label {
            width: 80px;
            font-size: 0.8rem;
            color: var(--gray-5);
            text-align: right;
        }

        .sparkline {
            flex: 1;
            height: 40px;
        }

        /* === MARGIN NOTES (Tufte style) === */
        .content-with-margin {
            display: grid;
            grid-template-columns: 1fr 200px;
            gap: 2rem;
        }

        .margin-note {
            font-size: 0.8rem;
            color: var(--gray-5);
            line-height: 1.5;
            padding-left: 1rem;
            border-left: 1px solid var(--gray-3);
        }

        /* === BIFURCATION DIAGRAM === */
        .bifurcation-section {
            margin: 3rem 0;
        }

        .bif-canvas-container {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
            margin: 1.5rem 0;
        }

        .bif-item {
            text-align: center;
        }

        .bif-item canvas {
            border: 1px solid var(--gray-2);
        }

        .bif-caption {
            font-size: 0.75rem;
            margin-top: 0.5rem;
            color: var(--gray-5);
        }

        /* === UMBILIC SECTION === */
        .umbilic-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 2rem;
            margin: 2rem 0;
        }

        .umbilic-card {
            position: relative;
        }

        .surface-canvas {
            width: 100%;
            aspect-ratio: 1;
        }

        /* === SMALL MULTIPLES === */
        .small-multiples {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 0.5rem;
            margin: 2rem 0;
        }

        .multiple {
            aspect-ratio: 1;
            position: relative;
        }

        .multiple canvas {
            width: 100%;
            height: 100%;
        }

        .multiple-label {
            position: absolute;
            bottom: 0.25rem;
            left: 0.25rem;
            font-size: 0.6rem;
            color: var(--gray-5);
        }

        /* === RESPONSIVE === */
        @media (max-width: 900px) {
            .content-with-margin {
                grid-template-columns: 1fr;
            }
            .margin-note {
                border-left: none;
                border-top: 1px solid var(--gray-3);
                padding-left: 0;
                padding-top: 1rem;
                margin-top: 1rem;
            }
            .bif-canvas-container {
                grid-template-columns: repeat(2, 1fr);
            }
            .umbilic-grid {
                grid-template-columns: 1fr;
            }
            .small-multiples {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        @media print {
            body { max-width: none; padding: 1cm; }
            .catastrophe-card { break-inside: avoid; }
        }
    </style>
</head>
<body>
    <header>
        <h1>The Seven Elementary Catastrophes</h1>
        <p class="subtitle">A mathematical atlas following Thom's classification theorem (1972)</p>
    </header>

    <section class="content-with-margin">
        <div>
            <p>
                René Thom proved that for systems with up to four control parameters and two state variables,
                there exist exactly seven topologically distinct ways for stable equilibria to appear, disappear,
                or exchange stability. These are the <em>elementary catastrophes</em>.
            </p>
            <p>
                Each catastrophe is characterized by a <strong>potential function</strong> <span class="math">V</span>,
                whose critical points (∂<span class="math">V</span>/∂<span class="math">x</span> = 0) determine
                equilibrium states. Stability requires ∂²<span class="math">V</span>/∂<span class="math">x</span>² &gt; 0.
            </p>
        </div>
        <aside class="margin-note">
            The dimension count: <em>n</em> control parameters + <em>m</em> state variables determines 
            which catastrophes are possible. For gradient systems, codimension ≤ 4 admits exactly 7 types.
        </aside>
    </section>

    <!-- DIMENSIONAL SUMMARY TABLE -->
    <section>
        <h2>Dimensional Structure</h2>
        <table class="dim-table">
            <thead>
                <tr>
                    <th>Catastrophe</th>
                    <th>Class</th>
                    <th>Control dim</th>
                    <th>State dim</th>
                    <th>Codimension</th>
                    <th>Bifurcation set</th>
                    <th>Colony</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td class="name">Fold</td>
                    <td class="math">A₂</td>
                    <td>1</td>
                    <td>1</td>
                    <td>1</td>
                    <td>point</td>
                    <td><span class="colony" style="background: var(--spark)">Spark</span></td>
                </tr>
                <tr>
                    <td class="name">Cusp</td>
                    <td class="math">A₃</td>
                    <td>2</td>
                    <td>1</td>
                    <td>2</td>
                    <td>cusp curve</td>
                    <td><span class="colony" style="background: var(--forge)">Forge</span></td>
                </tr>
                <tr>
                    <td class="name">Swallowtail</td>
                    <td class="math">A₄</td>
                    <td>3</td>
                    <td>1</td>
                    <td>3</td>
                    <td>swallowtail surface</td>
                    <td><span class="colony" style="background: var(--flow)">Flow</span></td>
                </tr>
                <tr>
                    <td class="name">Butterfly</td>
                    <td class="math">A₅</td>
                    <td>4</td>
                    <td>1</td>
                    <td>4</td>
                    <td>3-manifold</td>
                    <td><span class="colony" style="background: var(--nexus)">Nexus</span></td>
                </tr>
                <tr>
                    <td class="name">Hyperbolic Umbilic</td>
                    <td class="math">D₄⁺</td>
                    <td>3</td>
                    <td>2</td>
                    <td>3</td>
                    <td>ruled surface</td>
                    <td><span class="colony" style="background: var(--beacon)">Beacon</span></td>
                </tr>
                <tr>
                    <td class="name">Elliptic Umbilic</td>
                    <td class="math">D₄⁻</td>
                    <td>3</td>
                    <td>2</td>
                    <td>3</td>
                    <td>3-fold symmetric</td>
                    <td><span class="colony" style="background: var(--grove)">Grove</span></td>
                </tr>
                <tr>
                    <td class="name">Parabolic Umbilic</td>
                    <td class="math">D₅</td>
                    <td>4</td>
                    <td>2</td>
                    <td>4</td>
                    <td>mushroom</td>
                    <td><span class="colony" style="background: var(--crystal)">Crystal</span></td>
                </tr>
            </tbody>
        </table>
    </section>

    <!-- CUSPOID FAMILY -->
    <section>
        <h2>I. The Cuspoid Family (<span class="math">A<sub>k</sub></span>)</h2>
        <p>
            One state variable <span class="math">x</span>. The potential is a polynomial of degree <span class="math">k+1</span>.
            Critical points satisfy <span class="math">dV/dx = 0</span>, a polynomial of degree <span class="math">k</span>.
        </p>

        <div class="catastrophe-grid">
            <!-- FOLD -->
            <div class="catastrophe-card card-fold">
                <div class="card-header">
                    <span class="card-title">Fold</span>
                    <span class="card-class">A₂</span>
                </div>
                <div class="card-equation">
                    V(x; a) = x³ + ax
                </div>
                <div class="card-dims">
                    <div class="dim-box">
                        <div class="dim-label">Control</div>
                        <div class="dim-value">1</div>
                    </div>
                    <div class="dim-box">
                        <div class="dim-label">State</div>
                        <div class="dim-value">1</div>
                    </div>
                    <div class="dim-box">
                        <div class="dim-label">Codim</div>
                        <div class="dim-value">1</div>
                    </div>
                </div>
                <div class="viz-container">
                    <div class="viz-row">
                        <div class="viz-cell">
                            <canvas id="fold-potential" width="200" height="150"></canvas>
                            <div class="viz-label">V(x) for varying a</div>
                        </div>
                        <div class="viz-cell">
                            <canvas id="fold-bifurcation" width="200" height="150"></canvas>
                            <div class="viz-label">Equilibria vs a</div>
                        </div>
                    </div>
                </div>
                <p class="small muted">
                    Critical points: 3x² + a = 0 → x = ±√(−a/3).<br>
                    Two equilibria for a &lt; 0, none for a &gt; 0.<br>
                    Bifurcation at a = 0.
                </p>
            </div>

            <!-- CUSP -->
            <div class="catastrophe-card card-cusp">
                <div class="card-header">
                    <span class="card-title">Cusp</span>
                    <span class="card-class">A₃</span>
                </div>
                <div class="card-equation">
                    V(x; a, b) = x⁴ + ax² + bx
                </div>
                <div class="card-dims">
                    <div class="dim-box">
                        <div class="dim-label">Control</div>
                        <div class="dim-value">2</div>
                    </div>
                    <div class="dim-box">
                        <div class="dim-label">State</div>
                        <div class="dim-value">1</div>
                    </div>
                    <div class="dim-box">
                        <div class="dim-label">Codim</div>
                        <div class="dim-value">2</div>
                    </div>
                </div>
                <div class="viz-container">
                    <div class="viz-row">
                        <div class="viz-cell">
                            <canvas id="cusp-surface" width="200" height="150"></canvas>
                            <div class="viz-label">Equilibrium surface</div>
                        </div>
                        <div class="viz-cell">
                            <canvas id="cusp-bifurcation" width="200" height="150"></canvas>
                            <div class="viz-label">Bifurcation set (a,b)</div>
                        </div>
                    </div>
                </div>
                <p class="small muted">
                    Bifurcation set: 8a³ + 27b² = 0.<br>
                    Inside cusp: 3 equilibria. Outside: 1.<br>
                    Hysteresis: path-dependent jumps.
                </p>
            </div>

            <!-- SWALLOWTAIL -->
            <div class="catastrophe-card card-swallowtail">
                <div class="card-header">
                    <span class="card-title">Swallowtail</span>
                    <span class="card-class">A₄</span>
                </div>
                <div class="card-equation">
                    V(x; a,b,c) = x⁵ + ax³ + bx² + cx
                </div>
                <div class="card-dims">
                    <div class="dim-box">
                        <div class="dim-label">Control</div>
                        <div class="dim-value">3</div>
                    </div>
                    <div class="dim-box">
                        <div class="dim-label">State</div>
                        <div class="dim-value">1</div>
                    </div>
                    <div class="dim-box">
                        <div class="dim-label">Codim</div>
                        <div class="dim-value">3</div>
                    </div>
                </div>
                <div class="viz-container">
                    <canvas id="swallowtail-surface" width="400" height="150"></canvas>
                    <div class="viz-label">Bifurcation surface (section at c = const)</div>
                </div>
                <p class="small muted">
                    The bifurcation surface has a characteristic "swallowtail" shape with self-intersection curves
                    and cusp ridges where the surface meets itself.
                </p>
            </div>

            <!-- BUTTERFLY -->
            <div class="catastrophe-card card-butterfly">
                <div class="card-header">
                    <span class="card-title">Butterfly</span>
                    <span class="card-class">A₅</span>
                </div>
                <div class="card-equation">
                    V(x; a,b,c,d) = x⁶ + ax⁴ + bx³ + cx² + dx
                </div>
                <div class="card-dims">
                    <div class="dim-box">
                        <div class="dim-label">Control</div>
                        <div class="dim-value">4</div>
                    </div>
                    <div class="dim-box">
                        <div class="dim-label">State</div>
                        <div class="dim-value">1</div>
                    </div>
                    <div class="dim-box">
                        <div class="dim-label">Codim</div>
                        <div class="dim-value">4</div>
                    </div>
                </div>
                <div class="viz-container">
                    <canvas id="butterfly-section" width="400" height="150"></canvas>
                    <div class="viz-label">2D section through 4D bifurcation manifold</div>
                </div>
                <p class="small muted">
                    The "pocket of compromise" — a region where three stable and two unstable equilibria coexist.
                    Requires projection from 4D to visualize.
                </p>
            </div>
        </div>
    </section>

    <!-- UMBILIC FAMILY -->
    <section>
        <h2>II. The Umbilic Family (<span class="math">D<sub>k</sub></span>)</h2>
        <p>
            Two state variables (<span class="math">x, y</span>). The Hessian matrix determines stability.
            These catastrophes occur at "umbilic" points where both principal curvatures are equal.
        </p>

        <div class="umbilic-grid">
            <!-- HYPERBOLIC -->
            <div class="catastrophe-card card-hyperbolic">
                <div class="card-header">
                    <span class="card-title">Hyperbolic</span>
                    <span class="card-class">D₄⁺</span>
                </div>
                <div class="card-equation">
                    V = x³ + y³ + axy + bx + cy
                </div>
                <canvas id="hyperbolic-surface" class="surface-canvas" width="250" height="250"></canvas>
                <p class="small muted">
                    Saddle-like. Bifurcation set is a ruled surface (straight lines on a curved surface).
                    Focus caustics in optics.
                </p>
            </div>

            <!-- ELLIPTIC -->
            <div class="catastrophe-card card-elliptic">
                <div class="card-header">
                    <span class="card-title">Elliptic</span>
                    <span class="card-class">D₄⁻</span>
                </div>
                <div class="card-equation">
                    V = x³ − 3xy² + a(x²+y²) + bx + cy
                </div>
                <canvas id="elliptic-surface" class="surface-canvas" width="250" height="250"></canvas>
                <p class="small muted">
                    Three-fold rotational symmetry. The "monkey saddle" — a point where three valleys meet.
                    Bifurcation set has Δ₃ symmetry.
                </p>
            </div>

            <!-- PARABOLIC -->
            <div class="catastrophe-card card-parabolic">
                <div class="card-header">
                    <span class="card-title">Parabolic</span>
                    <span class="card-class">D₅</span>
                </div>
                <div class="card-equation">
                    V = x²y + y⁴ + ax² + by² + cx + dy
                </div>
                <canvas id="parabolic-surface" class="surface-canvas" width="250" height="250"></canvas>
                <p class="small muted">
                    The edge between hyperbolic and elliptic. Bifurcation set is the "mushroom" —
                    the boundary where crystallization occurs.
                </p>
            </div>
        </div>
    </section>

    <!-- SMALL MULTIPLES: Potential Landscapes -->
    <section>
        <h2>III. Potential Landscapes</h2>
        <p>
            Small multiples showing V(x) for each cuspoid catastrophe as control parameters vary.
            Stable equilibria are minima; unstable are maxima.
        </p>
        
        <h3>Fold: V = x³ + ax</h3>
        <div class="small-multiples" id="fold-multiples"></div>
        
        <h3>Cusp: V = x⁴ + ax² + bx (varying b, fixed a = −1)</h3>
        <div class="small-multiples" id="cusp-multiples"></div>
    </section>

    <!-- HYSTERESIS -->
    <section class="bifurcation-section">
        <h2>IV. Hysteresis in the Cusp</h2>
        <div class="content-with-margin">
            <div>
                <p>
                    The cusp catastrophe exhibits <em>hysteresis</em>: the system's state depends on its history.
                    Traversing around the cusp point in different directions yields different jump sequences.
                </p>
                <canvas id="hysteresis-demo" width="600" height="300"></canvas>
            </div>
            <aside class="margin-note">
                This is the geometry of commitment. Once you cross the fold line, the previous state no longer exists.
                The path you took to get here matters.
            </aside>
        </div>
    </section>

    <!-- UNFOLDING THEOREM -->
    <section>
        <h2>V. The Unfolding Theorem</h2>
        <p>
            Thom's classification rests on the concept of <em>versal unfolding</em>. A deformation
            F(x; u₁, ..., uₖ) of f(x) is <strong>versal</strong> if every other deformation can be
            obtained from F by coordinate changes and reparametrization.
        </p>
        <div class="equation">
            F(x; u) = f(x) + Σᵢ uᵢ · gᵢ(x)
            <span class="equation-label">(versal unfolding)</span>
        </div>
        <p>
            The minimum number of parameters uᵢ needed for versality equals the <strong>codimension</strong>
            of the singularity. For the seven elementary catastrophes, this ranges from 1 to 4.
        </p>
    </section>

    <!-- COLONY MAPPING -->
    <section>
        <h2>VI. Mapping to the Colony System</h2>
        <p>
            The seven colonies (e₁ through e₇) map to the seven catastrophes via the octonion imaginary units.
            Each catastrophe describes a different mode of transition at the edge of stability.
        </p>
        
        <table class="dim-table">
            <thead>
                <tr>
                    <th>Colony</th>
                    <th>Octonion</th>
                    <th>Catastrophe</th>
                    <th>Phenomenology</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><span class="colony" style="background: var(--spark)">Spark</span></td>
                    <td class="math">e₁</td>
                    <td>Fold (A₂)</td>
                    <td>Sudden appearance/disappearance. Ignition. The tipping point.</td>
                </tr>
                <tr>
                    <td><span class="colony" style="background: var(--forge)">Forge</span></td>
                    <td class="math">e₂</td>
                    <td>Cusp (A₃)</td>
                    <td>Hysteresis. Commitment. Irreversible decisions.</td>
                </tr>
                <tr>
                    <td><span class="colony" style="background: var(--flow)">Flow</span></td>
                    <td class="math">e₃</td>
                    <td>Swallowtail (A₄)</td>
                    <td>Resilience. New stable states emerging from collapse.</td>
                </tr>
                <tr>
                    <td><span class="colony" style="background: var(--nexus)">Nexus</span></td>
                    <td class="math">e₄</td>
                    <td>Butterfly (A₅)</td>
                    <td>The pocket of compromise. Holding contradictions.</td>
                </tr>
                <tr>
                    <td><span class="colony" style="background: var(--beacon)">Beacon</span></td>
                    <td class="math">e₅</td>
                    <td>Hyperbolic (D₄⁺)</td>
                    <td>Bifurcation. Focus. Architectural decisions.</td>
                </tr>
                <tr>
                    <td><span class="colony" style="background: var(--grove)">Grove</span></td>
                    <td class="math">e₆</td>
                    <td>Elliptic (D₄⁻)</td>
                    <td>Three-fold symmetry. The shifting ground. Knowledge that transforms.</td>
                </tr>
                <tr>
                    <td><span class="colony" style="background: var(--crystal)">Crystal</span></td>
                    <td class="math">e₇</td>
                    <td>Parabolic (D₅)</td>
                    <td>The edge of chaos. Phase transitions. Crystallization.</td>
                </tr>
            </tbody>
        </table>
        
        <p class="muted" style="margin-top: 2rem;">
            And <strong>Kagami</strong> (鏡, e₀ = 1, Real) is the observer — the split circle that appears
            in every painting. The strange loop that watches the transitions without participating in them.
            The identity element. The mirror.
        </p>
    </section>

    <footer style="margin-top: 4rem; padding-top: 2rem; border-top: 1px solid var(--gray-3);">
        <p class="small muted">
            References: Thom, R. (1972). <em>Structural Stability and Morphogenesis</em>. 
            Arnol'd, V. I. (1992). <em>Catastrophe Theory</em>. 
            Zeeman, E. C. (1977). <em>Catastrophe Theory: Selected Papers</em>.
        </p>
    </footer>

    <script>
        // === UTILITIES ===
        function getContext(id) {
            const canvas = document.getElementById(id);
            if (!canvas) return null;
            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            return { ctx, w: rect.width, h: rect.height };
        }

        const colors = {
            ink: '#1a1a1a',
            gray3: '#d0d0c8',
            gray4: '#888880',
            spark: '#e91e63',
            forge: '#c62828',
            flow: '#00838f',
            nexus: '#6a1b9a',
            beacon: '#f9a825',
            grove: '#2e7d32',
            crystal: '#1565c0'
        };

        // === FOLD CATASTROPHE ===
        function drawFoldPotential() {
            const c = getContext('fold-potential');
            if (!c) return;
            const { ctx, w, h } = c;
            
            const margin = { left: 30, right: 10, top: 10, bottom: 25 };
            const plotW = w - margin.left - margin.right;
            const plotH = h - margin.top - margin.bottom;
            
            // Axes
            ctx.strokeStyle = colors.gray4;
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.moveTo(margin.left, margin.top);
            ctx.lineTo(margin.left, h - margin.bottom);
            ctx.lineTo(w - margin.right, h - margin.bottom);
            ctx.stroke();
            
            // Labels
            ctx.fillStyle = colors.gray4;
            ctx.font = '10px Palatino';
            ctx.textAlign = 'center';
            ctx.fillText('x', w - margin.right, h - margin.bottom + 15);
            ctx.save();
            ctx.translate(12, margin.top + plotH/2);
            ctx.rotate(-Math.PI/2);
            ctx.fillText('V(x)', 0, 0);
            ctx.restore();
            
            // Draw V(x) = x³ + ax for different a values
            const aValues = [-1, -0.5, 0, 0.5, 1];
            const xRange = [-1.5, 1.5];
            const vRange = [-2, 2];
            
            function xToPixel(x) {
                return margin.left + (x - xRange[0]) / (xRange[1] - xRange[0]) * plotW;
            }
            function vToPixel(v) {
                return h - margin.bottom - (v - vRange[0]) / (vRange[1] - vRange[0]) * plotH;
            }
            
            aValues.forEach((a, i) => {
                const alpha = 0.3 + i * 0.15;
                ctx.beginPath();
                ctx.strokeStyle = `rgba(233, 30, 99, ${alpha})`;
                ctx.lineWidth = a === 0 ? 1.5 : 1;
                
                for (let x = xRange[0]; x <= xRange[1]; x += 0.02) {
                    const v = Math.pow(x, 3) + a * x;
                    const px = xToPixel(x);
                    const py = vToPixel(v);
                    
                    if (x === xRange[0]) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.stroke();
            });
            
            // Annotation
            ctx.fillStyle = colors.gray4;
            ctx.font = 'italic 9px Palatino';
            ctx.textAlign = 'right';
            ctx.fillText('a: −1 → +1', w - margin.right, margin.top + 12);
        }

        function drawFoldBifurcation() {
            const c = getContext('fold-bifurcation');
            if (!c) return;
            const { ctx, w, h } = c;
            
            const margin = { left: 30, right: 10, top: 10, bottom: 25 };
            const plotW = w - margin.left - margin.right;
            const plotH = h - margin.top - margin.bottom;
            
            // Axes
            ctx.strokeStyle = colors.gray4;
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.moveTo(margin.left, margin.top);
            ctx.lineTo(margin.left, h - margin.bottom);
            ctx.lineTo(w - margin.right, h - margin.bottom);
            ctx.stroke();
            
            ctx.fillStyle = colors.gray4;
            ctx.font = '10px Palatino';
            ctx.textAlign = 'center';
            ctx.fillText('a', w - margin.right, h - margin.bottom + 15);
            ctx.save();
            ctx.translate(12, margin.top + plotH/2);
            ctx.rotate(-Math.PI/2);
            ctx.fillText('x*', 0, 0);
            ctx.restore();
            
            const aRange = [-1.5, 0.5];
            const xRange = [-1.2, 1.2];
            
            function aToPixel(a) {
                return margin.left + (a - aRange[0]) / (aRange[1] - aRange[0]) * plotW;
            }
            function xToPixel(x) {
                return h - margin.bottom - (x - xRange[0]) / (xRange[1] - xRange[0]) * plotH;
            }
            
            // Stable branch (x* = sqrt(-a/3))
            ctx.beginPath();
            ctx.strokeStyle = colors.spark;
            ctx.lineWidth = 1.5;
            for (let a = aRange[0]; a <= 0; a += 0.01) {
                const x = Math.sqrt(-a / 3);
                const pa = aToPixel(a);
                const px = xToPixel(x);
                if (a === aRange[0]) ctx.moveTo(pa, px);
                else ctx.lineTo(pa, px);
            }
            ctx.stroke();
            
            // Unstable branch (x* = -sqrt(-a/3))
            ctx.beginPath();
            ctx.setLineDash([3, 3]);
            for (let a = aRange[0]; a <= 0; a += 0.01) {
                const x = -Math.sqrt(-a / 3);
                const pa = aToPixel(a);
                const px = xToPixel(x);
                if (a === aRange[0]) ctx.moveTo(pa, px);
                else ctx.lineTo(pa, px);
            }
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Bifurcation point
            ctx.beginPath();
            ctx.arc(aToPixel(0), xToPixel(0), 4, 0, Math.PI * 2);
            ctx.fillStyle = colors.spark;
            ctx.fill();
        }

        // === CUSP CATASTROPHE ===
        function drawCuspBifurcation() {
            const c = getContext('cusp-bifurcation');
            if (!c) return;
            const { ctx, w, h } = c;
            
            const margin = { left: 25, right: 10, top: 10, bottom: 25 };
            const plotW = w - margin.left - margin.right;
            const plotH = h - margin.top - margin.bottom;
            const cx = margin.left + plotW / 2;
            const cy = margin.top + plotH / 2;
            
            // Axes
            ctx.strokeStyle = colors.gray4;
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.moveTo(margin.left, cy);
            ctx.lineTo(w - margin.right, cy);
            ctx.moveTo(cx, margin.top);
            ctx.lineTo(cx, h - margin.bottom);
            ctx.stroke();
            
            ctx.fillStyle = colors.gray4;
            ctx.font = '10px Palatino';
            ctx.textAlign = 'center';
            ctx.fillText('b', w - margin.right, cy - 5);
            ctx.fillText('a', cx + 10, margin.top + 10);
            
            // Draw cusp curve: 8a³ + 27b² = 0 → a = -∛(27b²/8) = -(27/8)^(1/3) * |b|^(2/3) * sign(b)^(2/3)
            // Parametric: a = -3t²/4, b = t³/2
            ctx.beginPath();
            ctx.strokeStyle = colors.forge;
            ctx.lineWidth = 1.5;
            
            const scale = plotW * 0.25;
            
            for (let t = -2; t <= 2; t += 0.02) {
                const a = -3 * t * t / 4;
                const b = t * t * t / 2;
                
                const px = cx + b * scale;
                const py = cy - a * scale;
                
                if (t === -2) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.stroke();
            
            // Shade interior
            ctx.beginPath();
            for (let t = -2; t <= 2; t += 0.02) {
                const a = -3 * t * t / 4;
                const b = t * t * t / 2;
                const px = cx + b * scale;
                const py = cy - a * scale;
                if (t === -2) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fillStyle = 'rgba(198, 40, 40, 0.1)';
            ctx.fill();
            
            // Annotations
            ctx.font = 'italic 8px Palatino';
            ctx.fillStyle = colors.gray4;
            ctx.fillText('3 roots', cx - 20, cy + 30);
            ctx.fillText('1 root', cx + 30, cy - 20);
        }

        function drawCuspSurface() {
            const c = getContext('cusp-surface');
            if (!c) return;
            const { ctx, w, h } = c;
            
            const margin = { left: 20, right: 10, top: 10, bottom: 20 };
            
            // Simple perspective view of equilibrium surface
            ctx.strokeStyle = colors.forge;
            ctx.lineWidth = 0.5;
            
            const cx = w / 2;
            const cy = h / 2;
            const scale = 30;
            
            // Draw level curves of x at different a values
            for (let a = -1.5; a <= 0.5; a += 0.15) {
                ctx.beginPath();
                ctx.globalAlpha = 0.3 + (a + 1.5) * 0.2;
                
                for (let b = -1.5; b <= 1.5; b += 0.05) {
                    // Critical points: 4x³ + 2ax + b = 0
                    // We'll just sketch the fold structure
                    const disc = -8 * a / 3;
                    
                    let x;
                    if (disc > 0 && 8 * Math.pow(a, 3) + 27 * b * b < 0) {
                        // Inside cusp: use middle root approximation
                        x = -b / (2 * a) * 0.5;
                    } else {
                        // Outside: single root approximation
                        x = -Math.cbrt(b / 4);
                    }
                    
                    // Isometric-ish projection
                    const px = cx + (b * 0.8 + a * 0.3) * scale;
                    const py = cy - (x * 0.9 - a * 0.2) * scale;
                    
                    if (b === -1.5) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
        }

        // === SWALLOWTAIL ===
        function drawSwallowtail() {
            const c = getContext('swallowtail-surface');
            if (!c) return;
            const { ctx, w, h } = c;
            
            const cx = w / 2;
            const cy = h / 2;
            const scale = h * 0.35;
            
            // Parametric swallowtail: 
            // a = 3t², b = -2t³ (bifurcation set in (a,b) plane at c=0)
            ctx.beginPath();
            ctx.strokeStyle = colors.flow;
            ctx.lineWidth = 1.5;
            
            for (let t = -1.5; t <= 1.5; t += 0.01) {
                const a = 3 * t * t;
                const b = -2 * t * t * t;
                
                const px = cx + b * scale * 0.5;
                const py = cy - a * scale * 0.3;
                
                if (t === -1.5) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.stroke();
            
            // Self-intersection
            ctx.beginPath();
            ctx.setLineDash([2, 2]);
            ctx.strokeStyle = colors.flow;
            ctx.lineWidth = 1;
            ctx.moveTo(cx, cy);
            ctx.lineTo(cx, cy + scale * 0.35);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Labels
            ctx.fillStyle = colors.gray4;
            ctx.font = 'italic 9px Palatino';
            ctx.fillText('self-intersection', cx + 5, cy + scale * 0.25);
        }

        // === BUTTERFLY ===
        function drawButterfly() {
            const c = getContext('butterfly-section');
            if (!c) return;
            const { ctx, w, h } = c;
            
            const cx = w / 2;
            const cy = h / 2;
            const scale = h * 0.3;
            
            // Draw butterfly curve (a 2D section)
            // r = e^sin(θ) - 2cos(4θ) + sin⁵((2θ-π)/24)
            ctx.beginPath();
            ctx.strokeStyle = colors.nexus;
            ctx.lineWidth = 1.5;
            
            for (let theta = 0; theta <= Math.PI * 2; theta += 0.02) {
                const r = Math.exp(Math.sin(theta)) - 2 * Math.cos(4 * theta) + 
                          Math.pow(Math.sin((2 * theta - Math.PI) / 24), 5);
                
                const px = cx + r * Math.cos(theta) * scale * 0.25;
                const py = cy - r * Math.sin(theta) * scale * 0.25;
                
                if (theta === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.stroke();
            
            // Mark "pocket"
            ctx.beginPath();
            ctx.arc(cx, cy, 8, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(106, 27, 154, 0.2)';
            ctx.fill();
            
            ctx.fillStyle = colors.gray4;
            ctx.font = 'italic 9px Palatino';
            ctx.fillText('"pocket of compromise"', cx + 30, cy);
        }

        // === UMBILIC SURFACES ===
        function drawHyperbolicUmbilic() {
            const c = getContext('hyperbolic-surface');
            if (!c) return;
            const { ctx, w, h } = c;
            
            const cx = w / 2;
            const cy = h / 2;
            const scale = w * 0.12;
            
            // V = x³ + y³ + axy
            // Critical: 3x² + ay = 0, 3y² + ax = 0
            // Draw contour lines of V
            
            ctx.strokeStyle = colors.beacon;
            
            for (let level = -2; level <= 2; level += 0.3) {
                ctx.beginPath();
                ctx.globalAlpha = 0.2 + Math.abs(level) * 0.1;
                ctx.lineWidth = level === 0 ? 1.5 : 0.5;
                
                // Draw level curve V = level (approximate with sampling)
                for (let theta = 0; theta < Math.PI * 2; theta += 0.05) {
                    for (let r = 0.1; r < 2; r += 0.1) {
                        const x = r * Math.cos(theta);
                        const y = r * Math.sin(theta);
                        const V = Math.pow(x, 3) + Math.pow(y, 3) - 0.5 * x * y;
                        
                        if (Math.abs(V - level) < 0.15) {
                            const px = cx + x * scale;
                            const py = cy - y * scale;
                            ctx.beginPath();
                            ctx.arc(px, py, 1, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
            }
            ctx.globalAlpha = 1;
            
            // Axes
            ctx.strokeStyle = colors.gray3;
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.moveTo(cx - scale * 2, cy);
            ctx.lineTo(cx + scale * 2, cy);
            ctx.moveTo(cx, cy - scale * 2);
            ctx.lineTo(cx, cy + scale * 2);
            ctx.stroke();
        }

        function drawEllipticUmbilic() {
            const c = getContext('elliptic-surface');
            if (!c) return;
            const { ctx, w, h } = c;
            
            const cx = w / 2;
            const cy = h / 2;
            const scale = w * 0.12;
            
            // V = x³ - 3xy²  (monkey saddle)
            // Draw contour lines
            
            ctx.fillStyle = colors.grove;
            
            for (let level = -2; level <= 2; level += 0.25) {
                ctx.globalAlpha = 0.15 + Math.abs(level) * 0.08;
                
                for (let theta = 0; theta < Math.PI * 2; theta += 0.03) {
                    for (let r = 0.1; r < 2; r += 0.08) {
                        const x = r * Math.cos(theta);
                        const y = r * Math.sin(theta);
                        const V = Math.pow(x, 3) - 3 * x * y * y;
                        
                        if (Math.abs(V - level) < 0.12) {
                            const px = cx + x * scale;
                            const py = cy - y * scale;
                            ctx.beginPath();
                            ctx.arc(px, py, 1, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
            }
            ctx.globalAlpha = 1;
            
            // Three-fold symmetry lines
            ctx.strokeStyle = colors.gray3;
            ctx.lineWidth = 0.5;
            for (let i = 0; i < 3; i++) {
                const angle = i * Math.PI * 2 / 3;
                ctx.beginPath();
                ctx.moveTo(cx, cy);
                ctx.lineTo(cx + Math.cos(angle) * scale * 2, cy - Math.sin(angle) * scale * 2);
                ctx.stroke();
            }
        }

        function drawParabolicUmbilic() {
            const c = getContext('parabolic-surface');
            if (!c) return;
            const { ctx, w, h } = c;
            
            const cx = w / 2;
            const cy = h / 2;
            const scale = w * 0.1;
            
            // V = x²y + y⁴
            ctx.fillStyle = colors.crystal;
            
            for (let level = -1.5; level <= 1.5; level += 0.2) {
                ctx.globalAlpha = 0.1 + Math.abs(level) * 0.1;
                
                for (let x = -2; x <= 2; x += 0.08) {
                    for (let y = -2; y <= 2; y += 0.08) {
                        const V = x * x * y + Math.pow(y, 4);
                        
                        if (Math.abs(V - level) < 0.15) {
                            const px = cx + x * scale;
                            const py = cy - y * scale;
                            ctx.beginPath();
                            ctx.arc(px, py, 1, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
            }
            ctx.globalAlpha = 1;
            
            // Axes
            ctx.strokeStyle = colors.gray3;
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.moveTo(cx - scale * 2, cy);
            ctx.lineTo(cx + scale * 2, cy);
            ctx.moveTo(cx, cy - scale * 2);
            ctx.lineTo(cx, cy + scale * 2);
            ctx.stroke();
        }

        // === SMALL MULTIPLES ===
        function createSmallMultiples(containerId, drawFn, params, color) {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            params.forEach((p, i) => {
                const div = document.createElement('div');
                div.className = 'multiple';
                
                const canvas = document.createElement('canvas');
                canvas.width = 80;
                canvas.height = 80;
                div.appendChild(canvas);
                
                const label = document.createElement('div');
                label.className = 'multiple-label';
                label.textContent = typeof p === 'number' ? p.toFixed(1) : p;
                div.appendChild(label);
                
                container.appendChild(div);
                
                const ctx = canvas.getContext('2d');
                const dpr = window.devicePixelRatio || 1;
                canvas.width = 80 * dpr;
                canvas.height = 80 * dpr;
                ctx.scale(dpr, dpr);
                
                drawFn(ctx, 80, 80, p, color);
            });
        }

        function drawFoldMultiple(ctx, w, h, a, color) {
            const margin = 8;
            const plotW = w - 2 * margin;
            const plotH = h - 2 * margin;
            
            ctx.strokeStyle = '#d0d0c8';
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.moveTo(margin, h/2);
            ctx.lineTo(w - margin, h/2);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            
            for (let x = -1.5; x <= 1.5; x += 0.05) {
                const v = Math.pow(x, 3) + a * x;
                const px = margin + (x + 1.5) / 3 * plotW;
                const py = h/2 - v * plotH / 4;
                
                if (py > margin && py < h - margin) {
                    if (x === -1.5) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
            }
            ctx.stroke();
            
            // Mark critical points
            if (a < 0) {
                const xc = Math.sqrt(-a / 3);
                [-xc, xc].forEach(x => {
                    const v = Math.pow(x, 3) + a * x;
                    const px = margin + (x + 1.5) / 3 * plotW;
                    const py = h/2 - v * plotH / 4;
                    ctx.beginPath();
                    ctx.arc(px, py, 2, 0, Math.PI * 2);
                    ctx.fillStyle = color;
                    ctx.fill();
                });
            }
        }

        function drawCuspMultiple(ctx, w, h, b, color) {
            const a = -1; // Fixed
            const margin = 8;
            const plotW = w - 2 * margin;
            const plotH = h - 2 * margin;
            
            ctx.strokeStyle = '#d0d0c8';
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.moveTo(margin, h/2);
            ctx.lineTo(w - margin, h/2);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            
            for (let x = -1.5; x <= 1.5; x += 0.05) {
                const v = Math.pow(x, 4) + a * x * x + b * x;
                const px = margin + (x + 1.5) / 3 * plotW;
                const py = h/2 - v * plotH / 3;
                
                if (py > margin && py < h - margin) {
                    if (x === -1.5) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
            }
            ctx.stroke();
        }

        // === HYSTERESIS DEMO ===
        function drawHysteresis() {
            const c = getContext('hysteresis-demo');
            if (!c) return;
            const { ctx, w, h } = c;
            
            const margin = { left: 50, right: 30, top: 20, bottom: 40 };
            const plotW = w - margin.left - margin.right;
            const plotH = h - margin.top - margin.bottom;
            
            // Axes
            ctx.strokeStyle = colors.gray4;
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.moveTo(margin.left, margin.top);
            ctx.lineTo(margin.left, h - margin.bottom);
            ctx.lineTo(w - margin.right, h - margin.bottom);
            ctx.stroke();
            
            ctx.fillStyle = colors.gray4;
            ctx.font = '11px Palatino';
            ctx.textAlign = 'center';
            ctx.fillText('control parameter b', margin.left + plotW/2, h - 10);
            ctx.save();
            ctx.translate(15, margin.top + plotH/2);
            ctx.rotate(-Math.PI/2);
            ctx.fillText('state x*', 0, 0);
            ctx.restore();
            
            const bRange = [-2, 2];
            const xRange = [-1.8, 1.8];
            const a = -1;
            
            function bToPixel(b) {
                return margin.left + (b - bRange[0]) / (bRange[1] - bRange[0]) * plotW;
            }
            function xToPixel(x) {
                return h - margin.bottom - (x - xRange[0]) / (xRange[1] - xRange[0]) * plotH;
            }
            
            // S-curve: equilibrium manifold for cusp
            // 4x³ + 2ax + b = 0
            // We'll draw all three branches
            
            // Upper stable branch
            ctx.beginPath();
            ctx.strokeStyle = colors.forge;
            ctx.lineWidth = 2;
            for (let b = bRange[0]; b <= 1.2; b += 0.02) {
                // Approximate root finding
                let x = 1;
                for (let iter = 0; iter < 20; iter++) {
                    const f = 4 * Math.pow(x, 3) + 2 * a * x + b;
                    const fp = 12 * x * x + 2 * a;
                    if (Math.abs(fp) > 0.01) x -= f / fp;
                }
                if (x > 0.3) {
                    const px = bToPixel(b);
                    const py = xToPixel(x);
                    if (b === bRange[0]) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
            }
            ctx.stroke();
            
            // Lower stable branch
            ctx.beginPath();
            for (let b = bRange[1]; b >= -1.2; b -= 0.02) {
                let x = -1;
                for (let iter = 0; iter < 20; iter++) {
                    const f = 4 * Math.pow(x, 3) + 2 * a * x + b;
                    const fp = 12 * x * x + 2 * a;
                    if (Math.abs(fp) > 0.01) x -= f / fp;
                }
                if (x < -0.3) {
                    const px = bToPixel(b);
                    const py = xToPixel(x);
                    if (b === bRange[1]) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
            }
            ctx.stroke();
            
            // Unstable middle branch
            ctx.beginPath();
            ctx.setLineDash([4, 4]);
            ctx.strokeStyle = colors.gray4;
            ctx.lineWidth = 1;
            for (let b = -1.1; b <= 1.1; b += 0.02) {
                let x = 0;
                for (let iter = 0; iter < 20; iter++) {
                    const f = 4 * Math.pow(x, 3) + 2 * a * x + b;
                    const fp = 12 * x * x + 2 * a;
                    if (Math.abs(fp) > 0.01) x -= f / fp;
                }
                if (Math.abs(x) < 0.6) {
                    const px = bToPixel(b);
                    const py = xToPixel(x);
                    if (b === -1.1) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
            }
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Hysteresis arrows
            ctx.strokeStyle = colors.spark;
            ctx.lineWidth = 1.5;
            ctx.fillStyle = colors.spark;
            
            // Forward jump
            const b1 = 1.05;
            ctx.beginPath();
            ctx.moveTo(bToPixel(b1), xToPixel(0.85));
            ctx.lineTo(bToPixel(b1), xToPixel(-0.85));
            ctx.stroke();
            // Arrow head
            ctx.beginPath();
            ctx.moveTo(bToPixel(b1), xToPixel(-0.85));
            ctx.lineTo(bToPixel(b1) - 4, xToPixel(-0.75));
            ctx.lineTo(bToPixel(b1) + 4, xToPixel(-0.75));
            ctx.closePath();
            ctx.fill();
            
            // Backward jump
            const b2 = -1.05;
            ctx.beginPath();
            ctx.moveTo(bToPixel(b2), xToPixel(-0.85));
            ctx.lineTo(bToPixel(b2), xToPixel(0.85));
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(bToPixel(b2), xToPixel(0.85));
            ctx.lineTo(bToPixel(b2) - 4, xToPixel(0.75));
            ctx.lineTo(bToPixel(b2) + 4, xToPixel(0.75));
            ctx.closePath();
            ctx.fill();
            
            // Labels
            ctx.fillStyle = colors.gray5;
            ctx.font = 'italic 10px Palatino';
            ctx.fillText('stable', bToPixel(0), xToPixel(1.4));
            ctx.fillText('stable', bToPixel(0), xToPixel(-1.4));
            ctx.fillStyle = colors.gray4;
            ctx.fillText('unstable', bToPixel(0.5), xToPixel(0.2));
        }

        // === INITIALIZE ===
        window.addEventListener('load', () => {
            drawFoldPotential();
            drawFoldBifurcation();
            drawCuspBifurcation();
            drawCuspSurface();
            drawSwallowtail();
            drawButterfly();
            drawHyperbolicUmbilic();
            drawEllipticUmbilic();
            drawParabolicUmbilic();
            drawHysteresis();
            
            createSmallMultiples('fold-multiples', drawFoldMultiple, 
                [-1, -0.5, -0.2, 0, 0.2, 0.5, 1], colors.spark);
            createSmallMultiples('cusp-multiples', drawCuspMultiple,
                [-1.2, -0.8, -0.4, 0, 0.4, 0.8, 1.2], colors.forge);
        });

        window.addEventListener('resize', () => {
            drawFoldPotential();
            drawFoldBifurcation();
            drawCuspBifurcation();
            drawCuspSurface();
            drawSwallowtail();
            drawButterfly();
            drawHyperbolicUmbilic();
            drawEllipticUmbilic();
            drawParabolicUmbilic();
            drawHysteresis();
        });
    </script>
</body>
</html>

