<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#06060a">
    <meta name="description" content="Interactive semantic code visualization â€” explore your codebase in 3D">
    
    <!-- PWA -->
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/svg+xml" href="icon.svg">
    <link rel="apple-touch-icon" href="icon-192.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Code Galaxy">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500&family=IBM+Plex+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
    <title>Code Galaxy</title>
    <style>
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           DESIGN TOKENS
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        :root {
            --void-900: #020204;
            --void-800: #06060a;
            --void-700: #0c0c14;
            --void-600: #12121a;
            --void-500: #1a1a24;
            --void-400: #24242e;
            --void-300: #2b2b36;
            
            --text-100: #f5f2eb;
            --text-200: #e0ddd4;
            --text-300: #c8c4ba;
            --text-400: #9a978e;
            --text-500: #7a7870;
            --text-600: #5a5850;
            
            --gold-400: #f8d878;
            --gold-500: #f0c860;
            --gold-600: #d4a840;
            --gold-glow: rgba(240, 200, 96, 0.4);
            
            --border-1: rgba(255, 255, 255, 0.04);
            --border-2: rgba(255, 255, 255, 0.08);
            --border-3: rgba(255, 255, 255, 0.14);
            
            --glass-1: rgba(10, 10, 16, 0.75);
            --glass-2: rgba(12, 12, 20, 0.9);
            --shadow-1: 0 18px 50px rgba(0, 0, 0, 0.45);
            --shadow-2: 0 8px 22px rgba(0, 0, 0, 0.35);
            
            --font-sans: "IBM Plex Sans", system-ui, sans-serif;
            --font-mono: "IBM Plex Mono", "SF Mono", monospace;
            
            --ease-out: cubic-bezier(0.16, 1, 0.3, 1);
            --ease-spring: cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           RESET & BASE
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        
        html, body {
            width: 100%; height: 100%;
            background: var(--void-800);
            color: var(--text-100);
            font-family: var(--font-sans);
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
        }
        
        body::before {
            content: '';
            position: fixed;
            inset: 0;
            pointer-events: none;
            background:
                radial-gradient(circle at 10% 20%, rgba(240, 200, 96, 0.05), transparent 45%),
                radial-gradient(circle at 80% 10%, rgba(68, 120, 255, 0.04), transparent 50%),
                radial-gradient(circle at 70% 80%, rgba(110, 117, 130, 0.07), transparent 55%);
            mix-blend-mode: screen;
            opacity: 0.9;
        }
        
        button { border: none; background: none; cursor: pointer; font: inherit; color: inherit; }
        canvas { display: block; }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           LAYOUT
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        #app {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        
        .header {
            height: 64px;
            display: flex;
            align-items: center;
            gap: 24px;
            padding: 0 28px;
            background: linear-gradient(180deg, var(--void-700) 0%, rgba(6, 6, 10, 0.95) 100%);
            border-bottom: 1px solid var(--border-1);
            z-index: 100;
            flex-shrink: 0;
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 20px;
            font-weight: 600;
            color: var(--gold-500);
            letter-spacing: -0.02em;
        }
        
        .logo-icon {
            font-size: 28px;
            filter: drop-shadow(0 0 12px var(--gold-glow));
            animation: pulse-glow 3s ease-in-out infinite;
        }
        
        @keyframes pulse-glow {
            0%, 100% { filter: drop-shadow(0 0 12px var(--gold-glow)); }
            50% { filter: drop-shadow(0 0 20px var(--gold-glow)); }
        }
        
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.001ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.001ms !important;
                scroll-behavior: auto !important;
            }
        }
        
        .tabs {
            display: flex;
            gap: 4px;
            padding: 4px;
            background: var(--void-600);
            border-radius: 12px;
            box-shadow: inset 0 0 0 1px var(--border-1);
        }
        
        .tab {
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            color: var(--text-400);
            transition: all 0.15s var(--ease-out);
        }
        
        .tab:hover { color: var(--text-200); background: var(--void-500); }
        .tab.active { background: var(--gold-500); color: var(--void-900); box-shadow: 0 8px 16px rgba(240, 200, 96, 0.18); }
        
        .search {
            flex: 1;
            max-width: 480px;
            position: relative;
        }
        
        .search input {
            width: 100%;
            height: 40px;
            padding: 0 16px 0 44px;
            background: var(--void-600);
            border: 1px solid var(--border-2);
            border-radius: 12px;
            color: var(--text-100);
            font-size: 14px;
            outline: none;
            transition: all 0.15s var(--ease-out);
        }
        
        .search input:focus {
            border-color: var(--gold-500);
            box-shadow: 0 0 0 3px var(--gold-glow);
        }
        
        .search input::placeholder { color: var(--text-500); }
        
        /* Search Results Dropdown */
        .search-results {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            margin-top: 8px;
            max-height: 420px;
            overflow-y: auto;
            background: var(--glass-2);
            backdrop-filter: blur(24px);
            border: 1px solid var(--border-2);
            border-radius: 12px;
            box-shadow: var(--shadow-1);
            z-index: 200;
        }
        
        .search-results.active { display: block; }
        
        .search-result {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-1);
            transition: background 0.1s ease;
        }
        
        .search-result:last-child { border-bottom: none; }
        .search-result:hover, .search-result.selected { background: var(--void-600); }
        
        .search-result-icon {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            display: grid;
            place-items: center;
            font-size: 14px;
            flex-shrink: 0;
        }
        
        .search-result-content {
            flex: 1;
            min-width: 0;
        }
        
        .search-result-name {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-100);
            margin-bottom: 2px;
        }
        
        .search-result-summary {
            font-size: 11px;
            color: var(--text-400);
            margin-top: 4px;
            line-height: 1.4;
        }
        
        .search-result-path {
            font: 11px var(--font-mono);
            color: var(--text-500);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .search-result-meta {
            display: flex;
            gap: 12px;
            margin-top: 6px;
            font-size: 11px;
            color: var(--text-500);
        }
        
        .search-result-meta span {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        /* Token Highlighting */
        .token-match {
            background: linear-gradient(180deg, rgba(240, 200, 96, 0.35) 0%, rgba(240, 200, 96, 0.2) 100%);
            color: var(--gold-400);
            padding: 0 2px;
            border-radius: 3px;
            font-weight: 600;
        }
        
        .search-result-score {
            font: 500 10px var(--font-mono);
            color: var(--text-500);
            opacity: 0.7;
        }
        
        .search-empty {
            padding: 24px;
            text-align: center;
            color: var(--text-500);
            font-size: 13px;
        }
        
        .search-header {
            padding: 8px 16px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-500);
            background: var(--void-700);
            border-bottom: 1px solid var(--border-1);
        }
        
        .search::before {
            content: 'âŒ˜K';
            position: absolute;
            left: 14px;
            top: 50%;
            transform: translateY(-50%);
            font: 500 11px var(--font-mono);
            color: var(--text-500);
            pointer-events: none;
        }
        
        .stats {
            display: flex;
            gap: 10px;
            font-size: 13px;
            color: var(--text-400);
            align-items: center;
            flex-wrap: wrap;
        }
        
        .stat-val {
            color: var(--text-100);
            font-weight: 600;
            font-family: var(--font-mono);
        }
        
        .stat-muted {
            color: var(--text-500);
            margin-left: 4px;
        }
        
        .stat-pill {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            border-radius: 999px;
            background: var(--void-600);
            border: 1px solid var(--border-1);
            color: var(--text-300);
            font-size: 12px;
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.02);
        }
        
        .stat-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--gold-500);
            box-shadow: 0 0 8px var(--gold-glow);
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           MAIN CONTENT
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .main {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        .main::before {
            content: '';
            position: absolute;
            inset: 0;
            pointer-events: none;
            background-image:
                linear-gradient(rgba(255, 255, 255, 0.02) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.02) 1px, transparent 1px);
            background-size: 32px 32px;
            opacity: 0.25;
            z-index: 0;
        }
        
        /* .view styles moved to VIEW TRANSITIONS section */
        
        canvas {
            width: 100%;
            height: 100%;
        }
        
        #treemap { cursor: pointer; }
        #semantic { cursor: grab; }
        #semantic:active { cursor: grabbing; }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           LEGEND
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .legend {
            position: absolute;
            top: 12px;
            left: 12px;
            width: 160px;
            padding: 12px;
            background: var(--glass-1);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border-2);
            border-radius: 12px;
            z-index: 50;
            max-height: calc(100% - 24px);
            overflow-y: auto;
            box-shadow: var(--shadow-2);
        }
        
        .legend-title {
            margin-bottom: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-500);
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 6px 8px;
            border-radius: 8px;
            cursor: pointer;
            opacity: 0.65;
            transition: all 0.15s var(--ease-out);
        }
        
        .legend-item:hover, .legend-item.active { opacity: 1; background: rgba(255,255,255,0.04); }
        
        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            flex-shrink: 0;
            box-shadow: 0 0 8px currentColor;
        }
        
        .legend-name { flex: 1; font-size: 13px; color: var(--text-300); }
        .legend-count { font: 500 11px var(--font-mono); color: var(--text-500); min-width: 36px; text-align: right; }
        .legend-lines { font: 500 10px var(--font-mono); color: var(--text-600); min-width: 44px; text-align: right; }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           SIDE PANEL
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .panel {
            position: absolute;
            top: 0;
            right: 0;
            width: 360px;
            height: 100%;
            background: var(--glass-2);
            backdrop-filter: blur(32px);
            border-left: 1px solid var(--border-2);
            z-index: 60;
            transform: translateX(100%);
            transition: transform 0.35s var(--ease-out);
            display: flex;
            flex-direction: column;
            box-shadow: -24px 0 60px rgba(0, 0, 0, 0.5);
        }
        
        .panel.open { transform: translateX(0); }
        
        .panel-header {
            padding: 24px;
            border-bottom: 1px solid var(--border-1);
            position: relative;
        }
        
        .panel-close {
            position: absolute;
            top: 16px;
            right: 16px;
            width: 32px;
            height: 32px;
            border-radius: 10px;
            background: var(--void-600);
            color: var(--text-400);
            font-size: 18px;
            display: grid;
            place-items: center;
            transition: all 0.15s var(--ease-out);
        }
        
        .panel-close:hover { background: var(--void-500); color: var(--text-100); }
        
        .panel-label {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-500);
            margin-bottom: 8px;
        }
        
        .panel-title {
            font-size: 18px;
            font-weight: 600;
            word-break: break-word;
            line-height: 1.3;
        }
        
        .panel-path {
            font: 12px var(--font-mono);
            color: var(--text-400);
            word-break: break-all;
            margin-top: 6px;
        }
        
        .panel-summary {
            margin-top: 10px;
            padding: 10px 12px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--border-1);
            color: var(--text-200);
            font-size: 13px;
            line-height: 1.5;
        }
        
        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
        }
        
        .panel-content::-webkit-scrollbar { width: 10px; }
        .panel-content::-webkit-scrollbar-thumb {
            background: var(--void-400);
            border-radius: 10px;
            border: 3px solid transparent;
            background-clip: content-box;
        }
        
        .info-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 24px;
        }
        
        .info-box {
            padding: 14px;
            background: var(--void-600);
            border: 1px solid var(--border-1);
            border-radius: 12px;
        }
        
        .info-box-label { font-size: 11px; color: var(--text-500); margin-bottom: 4px; }
        .info-box-value { font-size: 16px; font-weight: 600; }
        
        .section-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-500);
            margin: 24px 0 12px;
        }
        
        .summary {
            font-size: 14px;
            line-height: 1.7;
            color: var(--text-300);
            font-style: italic;
        }
        
        .similar-item {
            display: flex;
            align-items: center;
            gap: 14px;
            padding: 12px 14px;
            background: var(--void-600);
            border: 1px solid var(--border-1);
            border-radius: 12px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s var(--ease-out);
        }
        
        .similar-item:hover {
            background: var(--void-500);
            border-color: var(--border-2);
            transform: translateX(6px);
        }
        
        .similar-score {
            width: 40px;
            height: 40px;
            display: grid;
            place-items: center;
            background: linear-gradient(135deg, var(--gold-400), var(--gold-600));
            border-radius: 10px;
            font: 700 13px var(--font-sans);
            color: var(--void-900);
            flex-shrink: 0;
        }
        
        .similar-info { flex: 1; min-width: 0; }
        .similar-name { font-size: 13px; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .similar-cat { font-size: 11px; margin-top: 2px; }
        
        /* Panel enrichments */
        .section-count {
            font-size: 10px;
            font-weight: 500;
            color: var(--text-500);
            margin-left: 6px;
        }
        
        .panel-doc {
            font-size: 13px;
            line-height: 1.6;
            color: var(--text-300);
            padding: 12px;
            background: var(--void-600);
            border-radius: 8px;
            border-left: 3px solid var(--gold-500);
        }
        
        .panel-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }
        
        .panel-code {
            background: var(--void-600);
            padding: 4px 8px;
            border-radius: 6px;
            font-family: var(--font-mono);
            font-size: 11px;
            color: var(--gold-400);
        }
        
        .panel-code.panel-class {
            color: #61dafb;
            border: 1px solid rgba(97, 218, 251, 0.2);
        }
        
        .panel-more {
            font-size: 11px;
            color: var(--text-500);
            font-style: italic;
            padding: 4px 0;
        }
        
        .panel-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }
        
        .panel-tag {
            background: linear-gradient(135deg, var(--void-500), var(--void-600));
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            color: var(--text-300);
            border: 1px solid var(--border-1);
        }
        
        .panel-badge {
            padding: 3px 8px;
            border-radius: 999px;
            font-size: 10px;
            font-weight: 600;
            border: 1px solid var(--border-1);
            background: rgba(255, 255, 255, 0.04);
            color: var(--text-200);
        }
        
        .panel-deps {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .panel-dep {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            background: var(--void-600);
            border-radius: 8px;
            font-size: 12px;
            transition: all 0.15s var(--ease-out);
        }
        
        .panel-dep.clickable {
            cursor: pointer;
        }
        
        .panel-dep.clickable:hover {
            background: var(--void-500);
            transform: translateX(4px);
        }
        
        .dep-arrow {
            color: var(--text-500);
            font-size: 10px;
        }
        
        .dep-name {
            flex: 1;
            color: var(--text-200);
            font-family: var(--font-mono);
        }
        
        .dep-badge {
            padding: 2px 8px;
            border-radius: 6px;
            font-size: 9px;
            font-weight: 600;
            text-transform: uppercase;
        }
        
        .panel-actions {
            margin-top: 24px;
            padding-top: 16px;
            border-top: 1px solid var(--border-1);
            display: flex;
            gap: 10px;
        }
        
        .panel-btn {
            flex: 1;
            padding: 12px 20px;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s var(--ease-out);
        }
        
        .panel-btn:hover { transform: translateY(-1px); }
        
        .panel-btn-primary {
            background: linear-gradient(135deg, var(--gold-500), var(--gold-600));
            color: var(--void-900);
        }
        
        .panel-btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(240, 200, 96, 0.3);
        }
        
        .panel-btn-secondary {
            background: var(--void-500);
            color: var(--text-200);
            border: 1px solid var(--border-2);
        }
        
        .panel-btn-secondary:hover {
            background: var(--void-400);
        }
        
        .toast {
            position: absolute;
            top: 16px;
            right: 16px;
            padding: 10px 14px;
            border-radius: 10px;
            background: rgba(10, 10, 16, 0.9);
            border: 1px solid var(--border-2);
            color: var(--text-200);
            font-size: 12px;
            display: flex;
            gap: 8px;
            align-items: center;
            opacity: 0;
            transform: translateY(-6px);
            transition: all 0.2s var(--ease-out);
            z-index: 80;
            pointer-events: none;
            box-shadow: var(--shadow-2);
        }
        
        .toast.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           CONTROLS
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .controls {
            position: absolute;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 4px;
            padding: 6px;
            background: rgba(12, 12, 20, 0.95);
            backdrop-filter: blur(24px);
            border: 1px solid var(--border-2);
            border-radius: 20px;
            z-index: 50;
        }
        
        .ctrl-btn {
            width: 44px;
            height: 44px;
            border-radius: 14px;
            font-size: 20px;
            color: var(--text-400);
            display: grid;
            place-items: center;
            transition: all 0.15s var(--ease-out);
        }
        
        .ctrl-btn:hover { background: var(--void-600); color: var(--text-100); }
        .ctrl-btn.active { background: var(--gold-500); color: var(--void-900); }
        
        .ctrl-divider {
            width: 1px;
            margin: 6px 4px;
            background: var(--border-2);
        }
        
        .zoom {
            position: absolute;
            bottom: 24px;
            right: 24px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            z-index: 50;
        }
        
        .zoom-btn {
            width: 40px;
            height: 40px;
            background: rgba(12, 12, 20, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border-2);
            border-radius: 12px;
            font-size: 20px;
            color: var(--text-400);
            display: grid;
            place-items: center;
            transition: all 0.15s var(--ease-out);
        }
        
        .zoom-btn:hover { background: var(--void-500); color: var(--text-100); }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           LAYERS PANEL
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .layers-panel {
            position: absolute;
            top: 12px;
            right: 12px;
            width: 140px;
            padding: 12px;
            background: rgba(12, 12, 20, 0.92);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border-2);
            border-radius: 12px;
            z-index: 50;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .layers-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-500);
            margin-bottom: 4px;
        }
        
        .layer-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.15s var(--ease-out);
            font-size: 12px;
            color: var(--text-400);
        }
        
        .layer-toggle:hover {
            background: var(--void-600);
            color: var(--text-200);
        }
        
        .layer-toggle input[type="checkbox"] {
            display: none;
        }
        
        .layer-toggle input[type="checkbox"]:checked + .layer-icon {
            filter: none;
            opacity: 1;
        }
        
        .layer-toggle input[type="checkbox"]:checked ~ span:last-child {
            color: var(--text-100);
        }
        
        .layer-icon {
            font-size: 14px;
            filter: grayscale(1);
            opacity: 0.5;
            transition: all 0.15s ease;
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           VIEW TRANSITIONS
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .view {
            display: none;
            width: 100%;
            height: 100%;
            position: absolute;
            inset: 0;
            will-change: transform, opacity;
            z-index: 1;
        }
        
        .view.active {
            display: block;
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           BREADCRUMBS
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .breadcrumbs {
            position: absolute;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 20px;
            background: rgba(12, 12, 20, 0.95);
            backdrop-filter: blur(24px);
            border: 1px solid var(--border-2);
            border-radius: 14px;
            font-size: 14px;
            z-index: 50;
        }
        
        .crumb { 
            color: var(--text-400); 
            cursor: pointer; 
            transition: all 0.15s var(--ease-out);
            padding: 2px 6px;
            border-radius: 6px;
        }
        .crumb:hover { color: var(--text-100); background: var(--void-600); }
        .crumb.current { color: var(--gold-500); font-weight: 600; }
        .crumb-sep { color: var(--text-600); }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           TOOLTIP â€” Rich, informative hover cards
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .tooltip {
            position: fixed;
            max-width: 360px;
            padding: 0;
            background: rgba(8, 8, 16, 0.96);
            backdrop-filter: blur(24px);
            border: 1px solid var(--border-3);
            border-radius: 14px;
            box-shadow: 0 16px 48px rgba(0, 0, 0, 0.7), 0 0 0 1px rgba(255, 255, 255, 0.05) inset;
            pointer-events: none;
            opacity: 0;
            transform: translateY(10px) scale(0.95);
            transition: all 0.2s var(--ease-spring);
            z-index: 200;
            overflow: hidden;
        }
        
        .tooltip.visible {
            opacity: 1;
            transform: translateY(0) scale(1);
        }
        
        .tt-header {
            display: flex;
            gap: 12px;
            padding: 14px 16px;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.03) 0%, transparent 100%);
            border-bottom: 1px solid var(--border-1);
        }
        
        .tt-icon {
            width: 36px;
            height: 36px;
            border-radius: 10px;
            display: grid;
            place-items: center;
            font-size: 18px;
            flex-shrink: 0;
        }
        
        .tt-title { flex: 1; min-width: 0; }
        .tt-name { font-size: 14px; font-weight: 600; color: var(--text-100); margin-bottom: 2px; }
        .tt-path { font: 10px var(--font-mono); color: var(--text-500); word-break: break-all; line-height: 1.4; }
        
        .tt-stats {
            display: flex;
            gap: 10px;
            padding: 10px 16px;
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid var(--border-1);
        }
        
        .tt-stat {
            font-size: 11px;
            color: var(--text-400);
        }
        
        .tt-stat strong {
            color: var(--text-100);
            font-weight: 600;
        }
        
        .tt-cat {
            padding: 2px 8px;
            border-radius: 6px;
            font-weight: 500;
        }
        
        .tt-section {
            padding: 8px 16px;
            border-bottom: 1px solid var(--border-1);
        }
        
        .tt-section:last-of-type { border-bottom: none; }
        
        .tt-label {
            display: block;
            font-size: 9px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-500);
            margin-bottom: 6px;
        }
        
        .tt-values {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            font-size: 11px;
        }
        
        .tt-values code {
            background: var(--void-600);
            padding: 2px 6px;
            border-radius: 4px;
            color: var(--gold-400);
            font-family: var(--font-mono);
            font-size: 10px;
        }
        
        .tt-imports span {
            background: var(--void-600);
            padding: 2px 6px;
            border-radius: 4px;
            color: var(--text-300);
            font-size: 10px;
        }
        
        .tt-more {
            color: var(--text-500);
            font-size: 10px;
            font-style: italic;
        }
        
        .tt-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }
        
        .tt-tag {
            background: linear-gradient(135deg, var(--void-500), var(--void-600));
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 10px;
            color: var(--text-300);
            border: 1px solid var(--border-1);
        }
        
        .tt-doc {
            padding: 10px 16px;
            font-size: 11px;
            font-style: italic;
            color: var(--text-400);
            line-height: 1.5;
            background: rgba(0, 0, 0, 0.15);
            border-top: 1px solid var(--border-1);
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           STATE OVERLAY (Loading, Error, Empty, Offline)
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .state-overlay {
            position: fixed;
            inset: 0;
            background: var(--void-800);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 20px;
            z-index: 1000;
            transition: opacity 0.4s var(--ease-out);
        }
        
        .state-overlay.hide { opacity: 0; pointer-events: none; }
        
        .state-icon {
            font-size: 64px;
            line-height: 1;
            margin-bottom: 8px;
        }
        
        .state-title {
            font-size: 20px;
            font-weight: 600;
            color: var(--text-100);
        }
        
        .state-message {
            font-size: 14px;
            color: var(--text-400);
            text-align: center;
            max-width: 360px;
        }
        
        .state-actions {
            display: flex;
            gap: 12px;
            margin-top: 8px;
        }
        
        .state-btn {
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 500;
            font-size: 14px;
            transition: all 0.2s var(--ease-out);
        }
        
        .state-btn-primary {
            background: var(--gold-500);
            color: var(--void-900);
        }
        
        .state-btn-primary:hover {
            background: var(--gold-400);
            transform: translateY(-1px);
        }
        
        .state-btn-secondary {
            background: var(--void-500);
            color: var(--text-200);
        }
        
        .state-btn-secondary:hover {
            background: var(--void-400);
        }
        
        .spinner {
            width: 48px;
            height: 48px;
            border: 3px solid var(--void-600);
            border-top-color: var(--gold-500);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        
        @keyframes spin { to { transform: rotate(360deg); } }
        
        /* Offline banner */
        .offline-banner {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 8px 16px;
            background: var(--void-600);
            color: var(--text-300);
            text-align: center;
            font-size: 13px;
            z-index: 1001;
            display: none;
            animation: slideDown 0.3s var(--ease-out);
        }
        
        .offline-banner.active {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
        }
        
        .offline-banner .banner-icon { font-size: 16px; }
        
        /* Update banner */
        .update-banner {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            background: linear-gradient(135deg, var(--gold-600), var(--gold-500));
            color: var(--void-900);
            font-weight: 500;
            font-size: 14px;
            border-radius: 24px;
            z-index: 1001;
            display: none;
            box-shadow: 0 4px 24px rgba(240, 200, 96, 0.3);
            animation: slideUp 0.4s var(--ease-spring);
            cursor: pointer;
        }
        
        .update-banner.active { display: flex; align-items: center; gap: 10px; }
        .update-banner:hover { transform: translateX(-50%) translateY(-2px); }
        
        @keyframes slideDown {
            from { transform: translateY(-100%); }
            to { transform: translateY(0); }
        }
        
        @keyframes slideUp {
            from { transform: translateX(-50%) translateY(100%); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           RESPONSIVE
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        @media (max-width: 1024px) {
            .header { gap: 16px; padding: 0 16px; }
            .stats { display: none; }
            .panel { width: 320px; }
        }
        
        @media (max-width: 768px) {
            .header { height: 48px; }
            .logo span:not(.logo-icon) { display: none; }
            .tabs { display: none; }
            .panel { width: 100%; }
            .legend { width: 150px; padding: 12px; }
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           ACCESSIBILITY
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                transition-duration: 0.01ms !important;
            }
        }
        
        :focus-visible {
            outline: 2px solid var(--gold-500);
            outline-offset: 2px;
        }
    </style>
</head>
<body>
    <!-- State Overlay -->
    <div class="state-overlay" id="state-overlay">
        <div class="spinner"></div>
        <div class="state-title" id="state-title">Loading...</div>
        <div class="state-message" id="state-message"></div>
        <div class="state-actions" id="state-actions"></div>
    </div>
    
    <!-- Offline Banner -->
    <div class="offline-banner" id="offline-banner">
        <span class="banner-icon">âš¡</span>
        <span>You're offline â€” viewing cached data</span>
    </div>
    
    <!-- Update Banner -->
    <div class="update-banner" id="update-banner">
        <span>ğŸ”„</span>
        <span>New data available â€” click to refresh</span>
    </div>
    
    <div id="app">
        <header class="header">
            <div class="logo">
                <span class="logo-icon">â—ˆ</span>
                <span>Code Galaxy</span>
            </div>
            
            <div class="tabs">
                <button class="tab active" data-view="treemap">Treemap</button>
                <button class="tab" data-view="semantic">3D Explorer</button>
            </div>
            
            <div class="search">
                <input type="text" id="search" placeholder="Search files, classes, functions..." autocomplete="off">
                <div class="search-results" id="search-results"></div>
            </div>
            
            <div class="stats">
                <span class="stat-pill"><span class="stat-dot"></span><span><span class="stat-val" id="file-count">â€”</span><span class="stat-muted" id="file-total"></span> files</span></span>
                <span class="stat-pill"><span><span class="stat-val" id="line-count">â€”</span><span class="stat-muted" id="line-total"></span> lines</span></span>
                <span class="stat-pill"><span>Clusters</span><span class="stat-val" id="cluster-count">â€”</span></span>
                <span class="stat-pill"><span>Updated</span><span class="stat-val" id="generated-at">â€”</span></span>
            </div>
        </header>
        
        <main class="main">
            <div class="view active" id="treemap-view">
                <canvas id="treemap"></canvas>
                <div class="breadcrumbs" id="breadcrumbs">
                    <span class="crumb current" data-idx="0">root</span>
                </div>
            </div>
            
            <div class="view" id="semantic-view">
                <canvas id="semantic"></canvas>
            </div>
            
            <aside class="legend" id="legend"></aside>
            
            <aside class="panel" id="panel">
                <div class="panel-header">
                    <button class="panel-close" id="panel-close">Ã—</button>
                    <div class="panel-label">File Details</div>
                    <div class="panel-title" id="panel-title">â€”</div>
                    <div class="panel-path" id="panel-path">â€”</div>
                </div>
                <div class="panel-content" id="panel-content"></div>
            </aside>
            
            <nav class="controls" id="controls" style="display: none;">
                <button class="ctrl-btn active" data-preset="orbit" title="Orbit">ğŸŒ</button>
                <button class="ctrl-btn" data-preset="top" title="Top View">â¬‡</button>
                <button class="ctrl-btn" data-preset="front" title="Front View">â¡</button>
                <div class="ctrl-divider"></div>
                <button class="ctrl-btn" data-action="reset" title="Reset">â†º</button>
                <button class="ctrl-btn" data-action="auto" title="Auto Rotate">â–¶</button>
                <div class="ctrl-divider"></div>
                <button class="ctrl-btn" data-action="back" title="Back to Treemap">ğŸ—ºï¸</button>
            </nav>
            
            <!-- Layers Panel for 3D View -->
            <div class="layers-panel" id="layers-panel" style="display: none;">
                <div class="layers-title">Layers</div>
                <label class="layer-toggle">
                    <input type="checkbox" data-layer="imports" checked>
                    <span class="layer-icon">ğŸ”—</span>
                    <span>Imports</span>
                </label>
                <label class="layer-toggle">
                    <input type="checkbox" data-layer="clusters">
                    <span class="layer-icon">â—</span>
                    <span>Clusters</span>
                </label>
                <label class="layer-toggle">
                    <input type="checkbox" data-layer="heat">
                    <span class="layer-icon">ğŸ”¥</span>
                    <span>Heat</span>
                </label>
                <label class="layer-toggle">
                    <input type="checkbox" data-layer="labels" checked>
                    <span class="layer-icon">ğŸ·ï¸</span>
                    <span>Labels</span>
                </label>
                <label class="layer-toggle">
                    <input type="checkbox" data-layer="focus">
                    <span class="layer-icon">ğŸ¯</span>
                    <span>Focus Cluster</span>
                </label>
            </div>
            
            <div class="zoom" id="zoom" style="display: none;">
                <button class="zoom-btn" data-dir="in">+</button>
                <button class="zoom-btn" data-dir="out">âˆ’</button>
            </div>
        </main>
        
        <div class="tooltip" id="tooltip"></div>
        <div class="toast" id="toast">âœ“ Copied</div>
    </div>
    
    <script>
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CONFIGURATION â€” All tunable values in one place
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        const CONFIG = {
            // 3D Rendering
            render: {
                initialRotX: 0.4,
                initialRotY: 0,
                rotationSensitivity: 0.006,
                rotationClamp: Math.PI * 0.48,
                zoomMin: 0.3,
                zoomMax: 4,
                zoomStep: 1.25,
                autoRotateSpeed: 0.003,
                nodeBaseSize: 3,
                nodeSizeScale: 0.15,
                importanceScale: 8,
                depthScaleMin: 0.5,
                depthScaleMax: 0.8,
                hitRadiusMin: 12,
                hitRadiusScale: 1.5,
                fov: 1.2,
                cameraZ: 2.0,
                scaleMultiplier: 0.85,
                dprCap: 1.75,
                maxNodesHigh: 2200,
                maxNodesMed: 1400,
                maxNodesLow: 800,
                maxLabelsHigh: 24,
                maxLabelsMed: 16,
                maxLabelsLow: 10,
                starCount: 220,
                fogStrength: 0.28,
            },
            
            // UI Timing
            ui: {
                maxLegendItems: 12,
                tooltipDelay: 800,
                searchDebounce: 100,
                searchMinLength: 2,
                searchMaxResults: 50,
                maxSimilarFiles: 8,
                panelSimilarFiles: 6,
                durationFast: 150,
                durationNormal: 233,
                durationSlow: 377,
            },
            
            // Treemap
            treemap: {
                padding: 4,
                cellGap: 2,
                minCellSize: 2,
                cornerRadius: 8,
                folderAlphaBase: 0.55,
                folderAlphaEnd: 0.45,
                fileAlphaBase: 0.85,
                fileAlphaEnd: 0.75,
            },
            
            // Similarity scoring
            similarity: {
                distanceScale: 1.2,
                clusterBoost: 0.2,
                categoryBoost: 0.1,
                minScore: 0.15,
            },
            
            // PWA
            pwa: {
                cacheVersion: 'v7.1.0',
                storageKey: 'code-galaxy-state',
            },
        };
        
        // UI State Machine
        const UI_STATE = {
            LOADING: 'loading',
            ERROR: 'error',
            EMPTY: 'empty',
            OFFLINE: 'offline',
            READY: 'ready',
        };
        
        // State configuration
        const STATE_CONFIG = {
            [UI_STATE.LOADING]: {
                icon: '',
                title: 'Loading...',
                message: 'Analyzing codebase structure',
                showSpinner: true,
                actions: [],
            },
            [UI_STATE.ERROR]: {
                icon: 'âš ï¸',
                title: 'Unable to Load',
                message: 'Failed to load codebase data',
                showSpinner: false,
                actions: [
                    { label: 'Try Again', action: 'retry', primary: true },
                    { label: 'Use Cached', action: 'cache', primary: false },
                ],
            },
            [UI_STATE.EMPTY]: {
                icon: 'ğŸ“­',
                title: 'No Data Found',
                message: 'Run the analyzer to generate codebase data',
                showSpinner: false,
                actions: [
                    { label: 'Refresh', action: 'retry', primary: true },
                ],
            },
            [UI_STATE.OFFLINE]: {
                icon: 'ğŸ“¡',
                title: 'You\'re Offline',
                message: 'Viewing cached data. Some features may be limited.',
                showSpinner: false,
                actions: [
                    { label: 'Continue Offline', action: 'continue', primary: true },
                ],
            },
            [UI_STATE.READY]: {
                hide: true,
            },
        };
        
        let retryCount = 0;
        const MAX_RETRIES = 3;
        
        function setUIState(newState, context = {}) {
            state.uiState = newState;
            renderUIState(newState, context);
        }
        
        function renderUIState(uiState, context = {}) {
            const overlay = document.getElementById('state-overlay');
            const config = STATE_CONFIG[uiState];
            
            if (!config || config.hide) {
                overlay.classList.add('hide');
                return;
            }
            
            overlay.classList.remove('hide');
            
            // Update content
            const spinner = overlay.querySelector('.spinner');
            const title = document.getElementById('state-title');
            const message = document.getElementById('state-message');
            const actions = document.getElementById('state-actions');
            
            if (spinner) spinner.style.display = config.showSpinner ? 'block' : 'none';
            if (title) title.textContent = context.title || config.title;
            if (message) message.textContent = context.message || config.message;
            
            // Render actions
            if (actions && config.actions) {
                actions.innerHTML = config.actions.map(a => `
                    <button class="state-btn ${a.primary ? 'state-btn-primary' : 'state-btn-secondary'}" 
                            data-action="${a.action}">${a.label}</button>
                `).join('');
                
                actions.querySelectorAll('button').forEach(btn => {
                    btn.addEventListener('click', () => handleStateAction(btn.dataset.action));
                });
            }
        }
        
        function handleStateAction(action) {
            switch (action) {
                case 'retry':
                    retryCount++;
                    if (retryCount <= MAX_RETRIES) {
                        init();
                    } else {
                        setUIState(UI_STATE.ERROR, { 
                            title: 'Multiple Failures',
                            message: 'Please check your connection and try again later.'
                        });
                    }
                    break;
                case 'cache':
                    loadFromCache();
                    break;
                case 'continue':
                    setUIState(UI_STATE.READY);
                    break;
            }
        }
        
        async function loadFromCache() {
            try {
                const cache = await caches.open(CONFIG.pwa.cacheVersion + '-data');
                const cached = await cache.match('./codebase-analysis.json');
                if (cached) {
                    const data = await cached.json();
                    processData(data);
                } else {
                    setUIState(UI_STATE.ERROR, { message: 'No cached data available' });
                }
            } catch (err) {
                setUIState(UI_STATE.ERROR, { message: 'Cache read failed: ' + err.message });
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CATEGORY COLORS â€” Professional palette with official language colors & gradients
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        const COLORS = {
            // Official language colors with gradient pairs (light â†’ dark)
            Python:     { h: 207, s: 51, l: 52, hex: '#4B8BBE', light: '#6AA7D4', dark: '#306998', glow: 'rgba(75, 139, 190, 0.5)' },
            JavaScript: { h: 53,  s: 93, l: 54, hex: '#F7DF1E', light: '#FFEB3B', dark: '#C7B200', glow: 'rgba(247, 223, 30, 0.5)' },
            TypeScript: { h: 211, s: 60, l: 48, hex: '#3178C6', light: '#519AE8', dark: '#235A9A', glow: 'rgba(49, 120, 198, 0.5)' },
            React:      { h: 193, s: 95, l: 68, hex: '#61DAFB', light: '#8EE7FC', dark: '#21B6D5', glow: 'rgba(97, 218, 251, 0.5)' },
            Rust:       { h: 25,  s: 55, l: 70, hex: '#DEA584', light: '#ECBFA0', dark: '#B87333', glow: 'rgba(222, 165, 132, 0.5)' },
            Swift:      { h: 8,   s: 87, l: 58, hex: '#F05138', light: '#FF7A5C', dark: '#C93D25', glow: 'rgba(240, 81, 56, 0.5)' },
            Kotlin:     { h: 256, s: 100, l: 66, hex: '#7F52FF', light: '#A580FF', dark: '#5C2ED9', glow: 'rgba(127, 82, 255, 0.5)' },
            Go:         { h: 192, s: 100, l: 42, hex: '#00ADD8', light: '#29C4ED', dark: '#007D9C', glow: 'rgba(0, 173, 216, 0.5)' },
            Java:       { h: 20,  s: 94, l: 55, hex: '#F89820', light: '#FFB347', dark: '#E07800', glow: 'rgba(248, 152, 32, 0.5)' },
            C:          { h: 210, s: 34, l: 54, hex: '#5C8DBC', light: '#7BA8D1', dark: '#3D6A96', glow: 'rgba(92, 141, 188, 0.5)' },
            Config:     { h: 220, s: 14, l: 46, hex: '#5F6B7A', light: '#8694A5', dark: '#3E4854', glow: 'rgba(95, 107, 122, 0.4)' },
            Docs:       { h: 145, s: 63, l: 42, hex: '#2A9D5C', light: '#48C77A', dark: '#1E7A45', glow: 'rgba(42, 157, 92, 0.5)' },
            Test:       { h: 328, s: 78, l: 65, hex: '#EC5FA8', light: '#F48EC4', dark: '#D42885', glow: 'rgba(236, 95, 168, 0.5)' },
            API:        { h: 262, s: 83, l: 65, hex: '#9D6EE8', light: '#B794F0', dark: '#7B3ED1', glow: 'rgba(157, 110, 232, 0.5)' },
            Core:       { h: 199, s: 89, l: 48, hex: '#0D99E8', light: '#41B5F5', dark: '#0770B3', glow: 'rgba(13, 153, 232, 0.5)' },
            Security:   { h: 0,   s: 72, l: 51, hex: '#DC3545', light: '#E8606D', dark: '#B91C2D', glow: 'rgba(220, 53, 69, 0.5)' },
            Shell:      { h: 86,  s: 60, l: 45, hex: '#6CB33F', light: '#8FD460', dark: '#4A8C28', glow: 'rgba(108, 179, 63, 0.5)' },
            Web:        { h: 286, s: 75, l: 60, hex: '#C840E9', light: '#D870F0', dark: '#9C1FC4', glow: 'rgba(200, 64, 233, 0.5)' },
            Style:      { h: 332, s: 84, l: 52, hex: '#E91E8C', light: '#F04EAB', dark: '#B8136E', glow: 'rgba(233, 30, 140, 0.5)' },
            Database:   { h: 38,  s: 92, l: 50, hex: '#F5A623', light: '#FFc04D', dark: '#D18700', glow: 'rgba(245, 166, 35, 0.5)' },
            Model:      { h: 171, s: 77, l: 40, hex: '#17A589', light: '#3CC9AD', dark: '#0D7A65', glow: 'rgba(23, 165, 137, 0.5)' },
            Service:    { h: 235, s: 66, l: 64, hex: '#6C7AE8', light: '#95A0F0', dark: '#4554D1', glow: 'rgba(108, 122, 232, 0.5)' },
            Utility:    { h: 187, s: 79, l: 48, hex: '#1AB8C4', light: '#45D0DA', dark: '#0D8A94', glow: 'rgba(26, 184, 196, 0.5)' },
            Other:      { h: 220, s: 10, l: 48, hex: '#6E7582', light: '#9099A8', dark: '#4D535E', glow: 'rgba(110, 117, 130, 0.4)' },
            Folder:     { h: 32,  s: 38, l: 38, hex: '#8B7355', light: '#B09878', dark: '#5E4D39', glow: 'rgba(139, 115, 85, 0.4)' },
        };
        
        function getColor(cat, alpha = 1) {
            const c = COLORS[cat] || COLORS.Other;
            if (alpha === 1) return c.hex;
            // Extract RGB from hex for alpha support
            const r = parseInt(c.hex.slice(1, 3), 16);
            const g = parseInt(c.hex.slice(3, 5), 16);
            const b = parseInt(c.hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        
        function getHSL(cat) {
            return COLORS[cat] || COLORS.Other;
        }
        
        function getGradient(ctx, cat, x, y, w, h, isFolder = false) {
            const c = COLORS[cat] || COLORS.Other;
            const grad = ctx.createLinearGradient(x, y, x + w * 0.7, y + h);
            if (isFolder) {
                grad.addColorStop(0, c.light + 'CC');
                grad.addColorStop(0.5, c.hex + 'AA');
                grad.addColorStop(1, c.dark + '99');
            } else {
                grad.addColorStop(0, c.light + 'E8');
                grad.addColorStop(0.4, c.hex + 'DD');
                grad.addColorStop(1, c.dark + 'CC');
            }
            return grad;
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // STATE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        const state = {
            uiState: UI_STATE.LOADING,
            view: 'treemap',
            data: null,
            files: [],
            tree: null,
            isOnline: navigator.onLine,
            
            treemap: {
                path: [],
                hovered: null,
                selected: null,
                cells: [],
            },
            
            semantic: {
                rotX: CONFIG.render.initialRotX,
                rotY: CONFIG.render.initialRotY,
                targetRotX: CONFIG.render.initialRotX,
                targetRotY: CONFIG.render.initialRotY,
                zoom: 1.0,
                dragging: false,
                lastX: 0,
                lastY: 0,
                hovered: null,
                selected: null,
                autoRotate: false,
                related: [],
                projected: [],
                quality: 'high',
                frameMsAvg: 0,
                focusClusterId: null,
                layers: {
                    imports: true,
                    clusters: false,
                    heat: false,
                    labels: true,
                    focus: false,
                },
            },
            
            filter: null,
            query: '',
            tooltipTimer: null,
            
            // View transition state
            transition: {
                active: false,
                progress: 0,
                fromView: null,
                toView: null,
                targetFile: null,
                startTime: 0,
                duration: 600,
            },
            
            // Import graph (built from data)
            importGraph: {
                imports: {},      // path -> [imported paths]
                importedBy: {},   // path -> [files that import this]
            },
            
            // Derived stats (live-updating)
            stats: {
                totalFiles: 0,
                visibleFiles: 0,
                totalLines: 0,
                visibleLines: 0,
                categories: {},
            },
        };
        
        // Global debug access
        window.DEBUG_STATE = state;
        
        let treemapCanvas, treemapCtx;
        let semanticCanvas, semanticCtx;
        let dpr = 1;
        let rafId = null;
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // LOCAL STORAGE PERSISTENCE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        const saveStateDebounced = debounce(saveState, 500);
        
        function saveState() {
            try {
                const persist = {
                    version: 1,
                    savedAt: Date.now(),
                    repoId: state.data?.meta?.name || state.data?.meta?.root || 'unknown',
                    view: state.view,
                    filter: state.filter,
                    treemapPath: state.treemap.path,
                    semantic: {
                        rotX: state.semantic.rotX,
                        rotY: state.semantic.rotY,
                        zoom: state.semantic.zoom,
                        autoRotate: state.semantic.autoRotate,
                    },
                };
                localStorage.setItem(CONFIG.pwa.storageKey, JSON.stringify(persist));
            } catch (err) {
                console.warn('Failed to save state:', err);
            }
        }
        
        function loadState() {
            try {
                const saved = localStorage.getItem(CONFIG.pwa.storageKey);
                if (!saved) return false;
                
                const persist = JSON.parse(saved);
                
                // Check if same repo
                const currentRepoId = state.data?.meta?.name || state.data?.meta?.root || 'unknown';
                if (persist.repoId !== currentRepoId) {
                    console.log('Different repo, skipping state restore');
                    return false;
                }
                
                // Restore state
                if (persist.view) state.view = persist.view;
                if (persist.filter !== undefined) state.filter = persist.filter;
                if (Array.isArray(persist.treemapPath)) state.treemap.path = persist.treemapPath;
                if (persist.semantic) {
                    if (typeof persist.semantic.rotX === 'number') state.semantic.rotX = persist.semantic.rotX;
                    if (typeof persist.semantic.rotY === 'number') state.semantic.rotY = persist.semantic.rotY;
                    if (typeof persist.semantic.zoom === 'number') state.semantic.zoom = persist.semantic.zoom;
                    if (typeof persist.semantic.autoRotate === 'boolean') state.semantic.autoRotate = persist.semantic.autoRotate;
                }
                
                return true;
            } catch (err) {
                console.warn('Failed to load state:', err);
                return false;
            }
        }
        
        function clearSavedState() {
            localStorage.removeItem(CONFIG.pwa.storageKey);
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // INITIALIZATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        async function init() {
            setUIState(UI_STATE.LOADING);
            
            try {
                // Check online status first
                if (!navigator.onLine) {
                    state.isOnline = false;
                    document.getElementById('offline-banner').classList.add('active');
                    // Try to load from cache
                    await loadFromCache();
                    return;
                }
                
                const res = await fetch('codebase-analysis.json?v=' + Date.now());
                if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                
                const data = await res.json();
                processData(data);
                
            } catch (err) {
                console.error('Init error:', err);
                setUIState(UI_STATE.ERROR, { 
                    title: 'Failed to Load',
                    message: err.message || 'Network error. Check your connection.'
                });
            }
        }
        
        function processData(data) {
            if (!data || !data.files || data.files.length === 0) {
                setUIState(UI_STATE.EMPTY, {
                    message: 'No files found. Run the analyzer to generate data.'
                });
                return;
            }
            
            state.data = data;
            state.files = data.files || [];
            
            // Build import graph (imports -> importedBy reverse index)
            buildImportGraph();
            
            // Use pre-built tree if available, otherwise build it
            if (data.tree) {
                state.tree = data.tree;
            } else {
                buildTree();
            }
            
            // Restore saved state (after data is set so repoId comparison works)
            const restored = loadState();
            
            // Update page metadata from data
            updateMetadata();
            
            // Initialize canvas elements
            treemapCanvas = document.getElementById('treemap');
            semanticCanvas = document.getElementById('semantic');
            treemapCtx = treemapCanvas.getContext('2d');
            semanticCtx = semanticCanvas.getContext('2d');
            
            resize();
            setupEvents();
            updateStats();
            buildLegend();
            
            // Apply restored state to UI
            if (restored) {
                // Update view tabs
                document.querySelectorAll('.tab').forEach(t => {
                    t.classList.toggle('active', t.dataset.view === state.view);
                });
                
                // Show/hide correct view
                document.getElementById('treemap-view').classList.toggle('active', state.view === 'treemap');
                document.getElementById('semantic-view').classList.toggle('active', state.view === 'semantic');
                document.getElementById('controls').style.display = state.view === 'semantic' ? 'flex' : 'none';
                document.getElementById('zoom').style.display = state.view === 'semantic' ? 'flex' : 'none';
                document.getElementById('breadcrumbs').style.display = state.view === 'treemap' ? 'flex' : 'none';
                
                // Update breadcrumbs
                updateBreadcrumbs();
            }
            setupOnlineListeners();
            
            // Success!
            setUIState(UI_STATE.READY);
            retryCount = 0;
            render();
        }
        
        function updateMetadata() {
            const meta = state.data?.meta || {};
            const title = meta.title || meta.name || 'Code Galaxy';
            
            document.title = title;
            const logoText = document.querySelector('.logo span:last-child');
            if (logoText) logoText.textContent = title;
            
            // Update theme color if specified
            const themeColor = document.querySelector('meta[name="theme-color"]');
            if (themeColor && meta.themeColor) {
                themeColor.setAttribute('content', meta.themeColor);
            }
            
            const generatedAt = document.getElementById('generated-at');
            if (generatedAt && meta.generated) {
                generatedAt.textContent = formatRelativeTime(meta.generated);
            }
        }
        
        function setupOnlineListeners() {
            window.addEventListener('online', () => {
                state.isOnline = true;
                document.getElementById('offline-banner').classList.remove('active');
                // Optionally refresh data
            });
            
            window.addEventListener('offline', () => {
                state.isOnline = false;
                document.getElementById('offline-banner').classList.add('active');
            });
            
            // Listen for SW updates
            if (navigator.serviceWorker) {
                navigator.serviceWorker.addEventListener('message', e => {
                    if (e.data?.type === 'DATA_UPDATED') {
                        document.getElementById('update-banner').classList.add('active');
                    }
                });
                
                document.getElementById('update-banner').addEventListener('click', () => {
                    location.reload();
                });
            }
        }
        
        function buildImportGraph() {
            // Build forward and reverse import relationships
            state.importGraph = { imports: {}, importedBy: {} };
            
            // Create a lookup for resolving imports
            const filesByName = new Map();
            const filesByPath = new Map();
            
            for (const f of state.files) {
                if (f.path) filesByPath.set(f.path, f);
                if (f.name) {
                    const name = f.name.replace(/\.(py|js|ts|tsx|jsx|rs|swift|kt)$/, '');
                    if (!filesByName.has(name)) filesByName.set(name, []);
                    filesByName.get(name).push(f);
                }
            }
            
            // Build import graph
            for (const f of state.files) {
                const imports = f.imports || [];
                state.importGraph.imports[f.path] = imports;
                
                for (const imp of imports) {
                    // Try to resolve the import to an actual file
                    let targetPath = null;
                    
                    // Direct path match
                    if (filesByPath.has(imp)) {
                        targetPath = imp;
                    } else {
                        // Try by module name
                        const moduleName = imp.split('/').pop().replace(/\.(py|js|ts|tsx|jsx|rs|swift|kt)$/, '');
                        const candidates = filesByName.get(moduleName) || [];
                        
                        // Find best match (same directory or closest ancestor)
                        if (candidates.length === 1) {
                            targetPath = candidates[0].path;
                        } else if (candidates.length > 1) {
                            // Prefer files in same directory tree
                            const fDir = f.path.split('/').slice(0, -1).join('/');
                            const match = candidates.find(c => c.path.startsWith(fDir + '/')) || candidates[0];
                            targetPath = match.path;
                        }
                    }
                    
                    if (targetPath) {
                        if (!state.importGraph.importedBy[targetPath]) {
                            state.importGraph.importedBy[targetPath] = [];
                        }
                        if (!state.importGraph.importedBy[targetPath].includes(f.path)) {
                            state.importGraph.importedBy[targetPath].push(f.path);
                        }
                    }
                }
            }
        }
        
        function buildTree() {
            const root = { name: 'root', path: '', lines: 0, isFile: false, children: {} };
            
            for (const f of state.files) {
                if (!f.path) continue;
                const parts = f.path.split('/');
                let node = root;
                
                for (let i = 0; i < parts.length - 1; i++) {
                    const part = parts[i];
                    if (!node.children[part]) {
                        node.children[part] = { 
                            name: part, 
                            path: parts.slice(0, i + 1).join('/'),
                            lines: 0, 
                            isFile: false, 
                            children: {} 
                        };
                    }
                    node = node.children[part];
                }
                
                const fileName = parts[parts.length - 1];
                node.children[fileName] = {
                    name: f.name || fileName,
                    path: f.path,
                    lines: f.lines || 0,
                    isFile: true,
                    file: f,
                    category: f.category || 'Other',
                };
            }
            
            // Calculate folder sizes
            function sumLines(n) {
                if (n.isFile) return n.lines;
                let sum = 0;
                for (const c of Object.values(n.children || {})) {
                    sum += sumLines(c);
                }
                n.lines = sum;
                return sum;
            }
            
            sumLines(root);
            state.tree = root;
        }
        
        function resize() {
            dpr = Math.min(window.devicePixelRatio || 1, CONFIG.render.dprCap);
            
            [treemapCanvas, semanticCanvas].forEach(c => {
                if (!c) return;
                const rect = c.parentElement.getBoundingClientRect();
                c.width = rect.width * dpr;
                c.height = rect.height * dpr;
                c.style.width = rect.width + 'px';
                c.style.height = rect.height + 'px';
                c.getContext('2d').setTransform(dpr, 0, 0, dpr, 0, 0);
            });
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // RENDER LOOP
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function render() {
            if (state.view === 'treemap') {
                renderTreemap();
            } else {
                renderSemantic();
            }
            rafId = requestAnimationFrame(render);
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // TREEMAP â€” Proper Squarify Algorithm
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function renderTreemap() {
            if (!treemapCtx || !state.tree) return;
            
            const w = treemapCanvas.width / dpr;
            const h = treemapCanvas.height / dpr;
            const ctx = treemapCtx;
            
            // Background
            ctx.fillStyle = '#04040a';
            ctx.fillRect(0, 0, w, h);
            
            // Navigate to current path
            let node = state.tree;
            for (const seg of state.treemap.path) {
                if (node.children && node.children[seg]) {
                    node = node.children[seg];
                } else {
                    // Invalid path, reset
                    state.treemap.path = [];
                    node = state.tree;
                    break;
                }
            }
            
            // Get children as array
            const children = Object.values(node.children || {}).filter(c => c.lines > 0);
            if (!children.length) return;
            
            // Fill entire screen - legend floats on top
            const pad = 4;
            state.treemap.cells = squarify(children, pad, pad, w - pad * 2, h - pad * 2);
            
            // Draw cells
            for (const cell of state.treemap.cells) {
                drawTreemapCell(ctx, cell);
            }
        }
        
        // Proper squarify implementation
        // Simple slice-and-dice treemap - reliable and predictable
        function squarify(items, x, y, w, h) {
            if (!items.length || w < 4 || h < 4) return [];
            
            // Sort by lines descending
            const sorted = [...items].sort((a, b) => b.lines - a.lines);
            const total = sorted.reduce((s, c) => s + c.lines, 0);
            if (total === 0) return [];
            
            const cells = [];
            sliceAndDice(sorted, x, y, w, h, total, cells, 0);
            return cells;
        }
        
        function sliceAndDice(items, x, y, w, h, total, cells, depth) {
            if (!items.length || w < 2 || h < 2 || total === 0) return;
            
            // Alternate between horizontal and vertical slicing
            const horizontal = (depth % 2 === 0) ? (w >= h) : (w < h);
            
            if (items.length === 1) {
                // Single item takes full space
                const gap = 2;
                if (w - gap > 2 && h - gap > 2) {
                    cells.push({ node: items[0], x: x, y: y, w: w - gap, h: h - gap });
                }
                return;
            }
            
            // Split items into two groups for more balanced layout
            let sum1 = 0;
            let split = 0;
            const halfTotal = total / 2;
            
            for (let i = 0; i < items.length; i++) {
                sum1 += items[i].lines;
                split = i + 1;
                if (sum1 >= halfTotal) break;
            }
            
            // Ensure at least one item in each group
            if (split === 0) split = 1;
            if (split === items.length) split = items.length - 1;
            
            const group1 = items.slice(0, split);
            const group2 = items.slice(split);
            const sum2 = total - sum1;
            
            const frac1 = sum1 / total;
            const gap = 2;
            
            if (horizontal) {
                // Split horizontally (side by side)
                const w1 = w * frac1;
                sliceAndDice(group1, x, y, w1 - gap, h, sum1, cells, depth + 1);
                sliceAndDice(group2, x + w1, y, w - w1 - gap, h, sum2, cells, depth + 1);
            } else {
                // Split vertically (top and bottom)
                const h1 = h * frac1;
                sliceAndDice(group1, x, y, w, h1 - gap, sum1, cells, depth + 1);
                sliceAndDice(group2, x, y + h1, w, h - h1 - gap, sum2, cells, depth + 1);
            }
        }
        
        function drawTreemapCell(ctx, { node, x, y, w, h }) {
            if (w < 2 || h < 2 || !isFinite(w) || !isFinite(h) || !isFinite(x) || !isFinite(y)) return;
            
            const hov = state.treemap.hovered === node;
            const sel = state.treemap.selected === node;
            const cat = node.category || node.file?.category || (node.isFile ? 'Other' : 'Folder');
            const c = COLORS[cat] || COLORS.Other;
            const isFolder = !node.isFile;
            
            // Calculate corner radius - larger for bigger cells
            const r = Math.max(4, Math.min(16, Math.min(w, h) / 6));
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // GLASSMORPHISM BASE
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            // Outer glow for depth (subtle)
            if (w > 40 && h > 40) {
                ctx.shadowColor = c.glow;
                ctx.shadowBlur = hov ? 20 : sel ? 28 : 8;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 4;
            }
            
            // Main fill with beautiful gradient
            ctx.beginPath();
            ctx.roundRect(x, y, w, h, r);
            ctx.fillStyle = getGradient(ctx, cat, x, y, w, h, isFolder);
            ctx.fill();
            
            // Reset shadow
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;
            
            // Inner highlight (top edge glow for glass effect)
            if (w > 30 && h > 30) {
                const highlightGrad = ctx.createLinearGradient(x, y, x, y + h * 0.3);
                highlightGrad.addColorStop(0, 'rgba(255, 255, 255, 0.25)');
                highlightGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = highlightGrad;
                ctx.beginPath();
                ctx.roundRect(x + 1, y + 1, w - 2, h * 0.4, [r - 1, r - 1, 0, 0]);
                ctx.fill();
            }
            
            // Border with gradient
            const borderGrad = ctx.createLinearGradient(x, y, x + w, y + h);
            borderGrad.addColorStop(0, c.light + '60');
            borderGrad.addColorStop(0.5, c.hex + '40');
            borderGrad.addColorStop(1, c.dark + '30');
            ctx.strokeStyle = borderGrad;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.roundRect(x, y, w, h, r);
            ctx.stroke();
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // HOVER / SELECTION EFFECTS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            if (hov || sel) {
                // Bright border
                ctx.strokeStyle = sel ? '#FFD700' : 'rgba(255, 255, 255, 0.85)';
                ctx.lineWidth = sel ? 3 : 2;
                ctx.stroke();
                
                // Selection ring glow
                if (sel) {
                    ctx.shadowColor = '#FFD700';
                    ctx.shadowBlur = 16;
                    ctx.strokeStyle = '#FFD700';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
                
                // Hover overlay
                if (hov && !sel) {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.08)';
                    ctx.fill();
                }
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // TYPOGRAPHY - Better hierarchy
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            
            if (w > 60 && h > 28) {
                const isLarge = w > 200 && h > 150;
                const isMedium = w > 120 && h > 80;
                const fontSize = isLarge ? 18 : isMedium ? 14 : 12;
                const fontWeight = isFolder ? 700 : 600;
                
                ctx.font = `${fontWeight} ${fontSize}px "IBM Plex Sans", sans-serif`;
                
                const maxChars = Math.floor((w - 20) / (fontSize * 0.55));
                const icon = isFolder ? 'ğŸ“ ' : getCategoryIcon(cat) + ' ';
                let label = icon + node.name;
                if (label.length > maxChars) {
                    label = label.slice(0, maxChars - 1) + 'â€¦';
                }
                
                const textY = y + (isLarge ? 28 : isMedium ? 22 : 18);
                
                // Text shadow for readability
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillText(label, x + 11, textY + 1);
                
                // Main text
                ctx.fillStyle = '#FFFFFF';
                ctx.fillText(label, x + 10, textY);
                
                // Metadata line (lines count + category badge)
                if (h > 50 && w > 80) {
                    const metaY = textY + (isLarge ? 24 : 18);
                    ctx.font = `500 ${isLarge ? 13 : 11}px "IBM Plex Mono", monospace`;
                    
                    const meta = formatNum(node.lines) + ' lines';
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.fillText(meta, x + 11, metaY + 1);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.75)';
                    ctx.fillText(meta, x + 10, metaY);
                    
                    // Category badge for files
                    if (!isFolder && w > 120 && h > 70) {
                        const badgeText = cat;
                        const badgeX = x + 10;
                        const badgeY = metaY + (isLarge ? 20 : 16);
                        ctx.font = `600 ${isLarge ? 11 : 9}px "IBM Plex Sans", sans-serif`;
                        const badgeW = ctx.measureText(badgeText).width + 10;
                        
                        // Badge background
                        ctx.fillStyle = c.dark + '80';
                        ctx.beginPath();
                        ctx.roundRect(badgeX, badgeY - 10, badgeW, 14, 4);
                        ctx.fill();
                        
                        // Badge text
                        ctx.fillStyle = '#FFFFFF';
                        ctx.fillText(badgeText, badgeX + 5, badgeY);
                    }
                }
            } else if (w > 35 && h > 20) {
                // Compact label
                ctx.font = '600 10px "IBM Plex Sans", sans-serif';
                const maxChars = Math.floor((w - 8) / 6);
                let short = node.name.slice(0, maxChars);
                if (node.name.length > maxChars) short += 'â€¦';
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                ctx.fillText(short, x + 5, y + 14);
                ctx.fillStyle = '#FFFFFF';
                ctx.fillText(short, x + 4, y + 13);
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // 3D SEMANTIC EXPLORER â€” Immersive Perspective
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function renderSemantic() {
            if (!semanticCtx || !state.files.length) return;
            
            // Auto-resize if canvas has no dimensions
            if (semanticCanvas.width === 0 || semanticCanvas.height === 0) {
                resize();
                if (semanticCanvas.width === 0) return;
            }
            const t0 = performance.now();
            const w = semanticCanvas.width / dpr;
            const h = semanticCanvas.height / dpr;
            const ctx = semanticCtx;
            const cx = w / 2;
            const cy = h / 2;
            const layers = state.semantic.layers;
            const quality = state.semantic.quality;
            const focusCluster = layers.focus && state.semantic.focusClusterId !== null;
            
            if (state.semantic.dragging) {
                state.semantic.rotX = state.semantic.targetRotX;
                state.semantic.rotY = state.semantic.targetRotY;
            } else {
                const smooth = quality === 'low' ? 0.25 : 0.14;
                state.semantic.rotX += (state.semantic.targetRotX - state.semantic.rotX) * smooth;
                state.semantic.rotY += (state.semantic.targetRotY - state.semantic.rotY) * smooth;
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // BACKGROUND â€” Deep space with nebula effect
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const bgGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, Math.hypot(w, h) * 0.7);
            bgGrad.addColorStop(0, '#0c0c1a');
            bgGrad.addColorStop(0.2, '#080814');
            bgGrad.addColorStop(0.5, '#050510');
            bgGrad.addColorStop(1, '#020206');
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, w, h);
            
            // Subtle nebula glow
            const nebulaGrad = ctx.createRadialGradient(cx * 0.7, cy * 0.6, 0, cx * 0.7, cy * 0.6, Math.min(w, h) * 0.5);
            nebulaGrad.addColorStop(0, 'rgba(100, 60, 180, 0.03)');
            nebulaGrad.addColorStop(0.5, 'rgba(60, 100, 180, 0.02)');
            nebulaGrad.addColorStop(1, 'transparent');
            ctx.fillStyle = nebulaGrad;
            ctx.fillRect(0, 0, w, h);
            
            // Star field
            ctx.fillStyle = 'rgba(255,255,255,0.06)';
            for (let i = 0; i < CONFIG.render.starCount; i++) {
                const sx = seededRandom(i * 7) * w;
                const sy = seededRandom(i * 13 + 1000) * h;
                const size = 0.2 + seededRandom(i * 17 + 2000) * 0.6;
                ctx.beginPath();
                ctx.arc(sx, sy, size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // FILTER & PROJECT FILES
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            let files = state.files.filter(f => 
                f.x !== undefined && f.y !== undefined && f.z !== undefined &&
                isFinite(f.x) && isFinite(f.y) && isFinite(f.z)
            );
            
            if (state.filter) {
                files = files.filter(f => f.category === state.filter);
            }
            if (state.query) {
                const q = state.query.toLowerCase();
                files = files.filter(f => 
                    (f.path && f.path.toLowerCase().includes(q)) || 
                    (f.name && f.name.toLowerCase().includes(q))
                );
            }
            
            const fov = CONFIG.render.fov;
            const cameraZ = CONFIG.render.cameraZ;
            const scale = Math.min(w, h) * CONFIG.render.scaleMultiplier * state.semantic.zoom;
            const cosY = Math.cos(state.semantic.rotY);
            const sinY = Math.sin(state.semantic.rotY);
            const cosX = Math.cos(state.semantic.rotX);
            const sinX = Math.sin(state.semantic.rotX);
            
            // Project all files to 2D
            let projected = [];
            
            for (const f of files) {
                let px = (f.x - 0.5) * 2;
                let py = (f.y - 0.5) * 2;
                let pz = (f.z - 0.5) * 2;
                
                const x1 = px * cosY - pz * sinY;
                const z1 = px * sinY + pz * cosY;
                const y1 = py * cosX - z1 * sinX;
                const z2 = py * sinX + z1 * cosX;
                
                const depth = fov / (fov + z2 + cameraZ);
                if (depth <= 0 || !isFinite(depth)) continue;
                
                projected.push({
                    file: f,
                    sx: cx + x1 * scale * depth,
                    sy: cy + y1 * scale * depth,
                    sz: z2,
                    depth: depth,
                });
            }
            
            // LOD: keep most important nodes for performance
            const maxNodes = quality === 'high' ? CONFIG.render.maxNodesHigh :
                quality === 'med' ? CONFIG.render.maxNodesMed : CONFIG.render.maxNodesLow;
            if (projected.length > maxNodes) {
                projected.sort((a, b) => (b.file.importance || 0) - (a.file.importance || 0));
                projected = projected.slice(0, maxNodes);
            }
            
            projected.sort((a, b) => a.sz - b.sz);
            state.semantic.projected = projected;
            
            // Build projection lookup
            const projByPath = new Map();
            projected.forEach(p => projByPath.set(p.file.path, p));
            const projByName = new Map();
            projected.forEach(p => {
                if (!p.file.name) return;
                const name = p.file.name.replace(/\.(py|js|ts|tsx|jsx|rs|swift|kt)$/, '');
                if (!projByName.has(name)) projByName.set(name, []);
                projByName.get(name).push(p);
            });
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // LAYER: CLUSTERS â€” Translucent boundary hulls
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (layers.clusters && quality === 'high') {
                const clusterGroups = new Map();
                projected.forEach(p => {
                    const cluster = p.file.cluster ?? -1;
                    if (cluster >= 0) {
                        if (!clusterGroups.has(cluster)) clusterGroups.set(cluster, []);
                        clusterGroups.get(cluster).push(p);
                    }
                });
                
                clusterGroups.forEach((points, clusterId) => {
                    if (points.length < 3) return;
                    
                    // Simple convex hull approximation (bounding circle)
                    const avgX = points.reduce((s, p) => s + p.sx, 0) / points.length;
                    const avgY = points.reduce((s, p) => s + p.sy, 0) / points.length;
                    const maxR = Math.max(...points.map(p => Math.hypot(p.sx - avgX, p.sy - avgY))) + 30;
                    
                    const hue = (clusterId * 137) % 360;
                    ctx.beginPath();
                    ctx.arc(avgX, avgY, maxR, 0, Math.PI * 2);
                    ctx.fillStyle = `hsla(${hue}, 50%, 50%, 0.05)`;
                    ctx.fill();
                    ctx.strokeStyle = `hsla(${hue}, 60%, 60%, 0.15)`;
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    const label = getClusterLabel(clusterId);
                    if (label) {
                        ctx.font = '600 10px "IBM Plex Sans", sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillStyle = `hsla(${hue}, 70%, 72%, 0.85)`;
                        ctx.fillText(label, avgX, avgY - maxR - 6);
                        ctx.textAlign = 'left';
                    }
                });
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // LAYER: IMPORTS â€” Connection lines
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (layers.imports && quality !== 'low') {
                ctx.globalAlpha = 0.4;
                
                // Draw all import connections (subtle)
                for (const p of projected) {
                    const imports = p.file.imports || [];
                    for (const imp of imports) {
                        // Try to find the imported file
                        let targetP = projByPath.get(imp);
                        if (!targetP) {
                            const moduleName = imp.split('/').pop().replace(/\.(py|js|ts|tsx|jsx|rs|swift|kt)$/, '');
                            const candidates = projByName.get(moduleName) || [];
                            targetP = candidates[0];
                        }
                        
                        if (targetP && targetP !== p) {
                            const cat = p.file.category || 'Other';
                            const c = COLORS[cat] || COLORS.Other;
                            
                            ctx.beginPath();
                            ctx.moveTo(p.sx, p.sy);
                            ctx.lineTo(targetP.sx, targetP.sy);
                            ctx.strokeStyle = c.hex + '30';
                            ctx.lineWidth = 0.5;
                            ctx.stroke();
                        }
                    }
                }
                
                ctx.globalAlpha = 1;
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // SELECTED FILE CONNECTIONS (bright, on top of faint import lines)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (state.semantic.selected && state.semantic.related.length) {
                const selP = projByPath.get(state.semantic.selected.path);
                if (selP) {
                    for (const relFile of state.semantic.related) {
                        const relP = projByPath.get(relFile.path);
                        if (relP) {
                            // Gradient line with glow
                            ctx.shadowColor = 'rgba(255, 215, 0, 0.5)';
                            ctx.shadowBlur = 8;
                            
                            const grad = ctx.createLinearGradient(selP.sx, selP.sy, relP.sx, relP.sy);
                            grad.addColorStop(0, 'rgba(255, 215, 0, 0.9)');
                            grad.addColorStop(0.3, 'rgba(255, 180, 0, 0.6)');
                            grad.addColorStop(0.7, 'rgba(255, 140, 0, 0.4)');
                            grad.addColorStop(1, 'rgba(255, 100, 0, 0.2)');
                            
                            ctx.beginPath();
                            ctx.moveTo(selP.sx, selP.sy);
                            ctx.lineTo(relP.sx, relP.sy);
                            ctx.strokeStyle = grad;
                            ctx.lineWidth = 2;
                            ctx.stroke();
                            
                            ctx.shadowBlur = 0;
                        }
                    }
                }
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // DRAW NODES
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            for (const p of projected) {
                drawNode(ctx, p, layers);
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // LAYER: LABELS â€” Floating labels for important nodes
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (layers.labels) {
                ctx.font = '500 10px "IBM Plex Sans", sans-serif';
                ctx.textAlign = 'center';
                
                // Only label large/important files that are visible
                const labelCandidates = projected
                    .filter(p => (p.file.importance || 0) > 0.3 || (p.file.lines || 0) > 500)
                    .sort((a, b) => b.depth - a.depth)
                    .slice(0, quality === 'high' ? CONFIG.render.maxLabelsHigh :
                        quality === 'med' ? CONFIG.render.maxLabelsMed : CONFIG.render.maxLabelsLow);
                
                for (const p of labelCandidates) {
                    const hov = state.semantic.hovered === p.file;
                    const sel = state.semantic.selected === p.file;
                    if (hov || sel) continue; // These already have labels from drawNode
                    
                    const label = p.file.name || p.file.path.split('/').pop();
                    const alpha = Math.min(1, p.depth * 0.8);
                    
                    const baseSize = CONFIG.render.nodeBaseSize + Math.sqrt(p.file.lines || 1) * CONFIG.render.nodeSizeScale;
                    const size = baseSize * (CONFIG.render.depthScaleMin + p.depth * CONFIG.render.depthScaleMax);
                    
                    ctx.fillStyle = `rgba(200, 200, 200, ${alpha * 0.7})`;
                    ctx.fillText(label, p.sx, p.sy - size - 8);
                }
                
                ctx.textAlign = 'left';
            }
            
            // Auto rotate
            if (state.semantic.autoRotate && !state.semantic.dragging) {
                state.semantic.targetRotY += CONFIG.render.autoRotateSpeed;
            }
            
            // Fog overlay for depth cohesion
            const fog = ctx.createRadialGradient(cx, cy, Math.min(w, h) * 0.2, cx, cy, Math.max(w, h) * 0.75);
            fog.addColorStop(0, `rgba(6, 6, 10, ${CONFIG.render.fogStrength * 0.15})`);
            fog.addColorStop(1, `rgba(6, 6, 10, ${CONFIG.render.fogStrength})`);
            ctx.fillStyle = fog;
            ctx.fillRect(0, 0, w, h);
            
            updateQuality(performance.now() - t0);
        }
        
        function drawNode(ctx, { file, sx, sy, sz, depth }, layers = {}) {
            const hov = state.semantic.hovered === file;
            const sel = state.semantic.selected === file;
            const rel = state.semantic.related.includes(file);
            const quality = state.semantic.quality;
            const focusOn = state.semantic.layers.focus && state.semantic.focusClusterId !== null;
            const isFocused = focusOn && file.cluster === state.semantic.focusClusterId;
            
            // Size based on importance and depth
            const baseSize = CONFIG.render.nodeBaseSize + Math.sqrt(file.lines || 1) * CONFIG.render.nodeSizeScale + (file.importance || 0) * CONFIG.render.importanceScale;
            const depthScale = CONFIG.render.depthScaleMin + depth * CONFIG.render.depthScaleMax;
            let size = baseSize * depthScale;
            
            // Interactive states
            if (hov) size *= 1.4;
            if (sel) size *= 1.6;
            if (rel) size *= 1.2;
            
            // Alpha based on depth
            let alpha = Math.max(0.3, Math.min(1, 0.35 + depth * 0.75));
            if (focusOn && !isFocused) {
                alpha *= 0.15;
                size *= 0.8;
            }
            
            const cat = file.category || 'Other';
            const c = COLORS[cat] || COLORS.Other;
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // HEAT LAYER â€” Color intensity by importance
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            let heatColor = c.hex;
            if (layers.heat) {
                const importance = file.importance || 0;
                const lines = Math.log10(Math.max(1, file.lines || 1)) / 5;
                const heat = Math.min(1, importance + lines * 0.3);
                
                // Interpolate from cool (blue) to hot (red/yellow)
                const hue = 240 - heat * 240; // Blue â†’ Red
                const sat = 70 + heat * 30;
                const light = 40 + heat * 20;
                heatColor = `hsl(${hue}, ${sat}%, ${light}%)`;
                alpha = Math.max(0.5, alpha);
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // GLOW FOR INTERACTIVE STATES
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (sel || hov || (rel && quality !== 'low')) {
                const glowSize = size * (sel ? 5 : hov ? 4 : 3);
                const glow = ctx.createRadialGradient(sx, sy, 0, sx, sy, glowSize);
                
                if (sel) {
                    glow.addColorStop(0, 'rgba(255, 215, 0, 0.7)');
                    glow.addColorStop(0.3, 'rgba(255, 180, 0, 0.35)');
                    glow.addColorStop(0.6, 'rgba(255, 140, 0, 0.15)');
                    glow.addColorStop(1, 'transparent');
                } else if (hov) {
                    glow.addColorStop(0, c.glow.replace('0.5', '0.6'));
                    glow.addColorStop(0.4, c.glow.replace('0.5', '0.25'));
                    glow.addColorStop(1, 'transparent');
                } else {
                    glow.addColorStop(0, 'rgba(255, 200, 100, 0.4)');
                    glow.addColorStop(0.5, 'rgba(255, 180, 80, 0.15)');
                    glow.addColorStop(1, 'transparent');
                }
                
                ctx.fillStyle = glow;
                ctx.beginPath();
                ctx.arc(sx, sy, glowSize, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // MAIN NODE WITH GRADIENT
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (!layers.heat && !sel && !hov && !rel && quality !== 'low') {
                const sprite = getNodeSprite(cat, size);
                ctx.globalAlpha = alpha;
                ctx.drawImage(sprite, sx - sprite.width / 2, sy - sprite.height / 2);
                ctx.globalAlpha = 1;
            } else {
                const nodeGrad = ctx.createRadialGradient(sx - size * 0.3, sy - size * 0.3, 0, sx, sy, size);
                if (layers.heat) {
                    nodeGrad.addColorStop(0, heatColor);
                    nodeGrad.addColorStop(1, heatColor.replace('hsl', 'hsla').replace(')', ', 0.7)'));
                } else {
                    nodeGrad.addColorStop(0, c.light + alphaHex(alpha));
                    nodeGrad.addColorStop(0.5, c.hex + alphaHex(alpha * 0.9));
                    nodeGrad.addColorStop(1, c.dark + alphaHex(alpha * 0.8));
                }
                
                ctx.beginPath();
                ctx.arc(sx, sy, size, 0, Math.PI * 2);
                ctx.fillStyle = nodeGrad;
                ctx.fill();
            }
            
            // Outer ring for definition
            ctx.strokeStyle = (sel ? '#FFD700' : c.light) + alphaHex(alpha * 0.5);
            ctx.lineWidth = sel ? 2 : 1;
            if (quality !== 'low') ctx.stroke();
            
            if (isFocused && quality === 'high') {
                ctx.strokeStyle = c.light + '66';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(sx, sy, size * 1.8, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Bright core highlight
            if (size > 3 && quality !== 'low') {
                const coreSize = size * 0.3;
                const coreGrad = ctx.createRadialGradient(sx - size * 0.15, sy - size * 0.15, 0, sx, sy, coreSize);
                coreGrad.addColorStop(0, `rgba(255, 255, 255, ${alpha * 0.9})`);
                coreGrad.addColorStop(0.5, `rgba(255, 255, 255, ${alpha * 0.4})`);
                coreGrad.addColorStop(1, 'transparent');
                
                ctx.beginPath();
                ctx.arc(sx - size * 0.15, sy - size * 0.15, coreSize, 0, Math.PI * 2);
                ctx.fillStyle = coreGrad;
                ctx.fill();
            }
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // LABEL FOR SELECTED/HOVERED
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if ((sel || hov) && size > 3) {
                const label = file.name || file.path.split('/').pop();
                ctx.font = `${sel ? 700 : 600} ${sel ? 14 : 12}px "IBM Plex Sans", sans-serif`;
                ctx.textAlign = 'center';
                
                // Background pill
                const textWidth = ctx.measureText(label).width;
                const pillX = sx - textWidth / 2 - 8;
                const pillY = sy - size - 24;
                const pillW = textWidth + 16;
                const pillH = 20;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
                ctx.beginPath();
                ctx.roundRect(pillX, pillY, pillW, pillH, 6);
                ctx.fill();
                
                // Border
                ctx.strokeStyle = sel ? '#FFD700' : c.hex;
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Text
                ctx.fillStyle = sel ? '#FFD700' : '#FFFFFF';
                ctx.fillText(label, sx, pillY + 14);
                ctx.textAlign = 'left';
            }
        }
        
        // Helper: convert alpha (0-1) to hex (00-FF)
        function alphaHex(alpha) {
            return Math.round(Math.max(0, Math.min(1, alpha)) * 255).toString(16).padStart(2, '0');
        }
        
        const spriteCache = new Map();
        
        function getNodeSprite(cat, size) {
            const c = COLORS[cat] || COLORS.Other;
            const bucket = Math.max(6, Math.min(40, Math.round(size * 1.4)));
            const key = `${cat}-${bucket}`;
            if (spriteCache.has(key)) return spriteCache.get(key);
            
            const canvas = document.createElement('canvas');
            const s = bucket * 2.4;
            canvas.width = s;
            canvas.height = s;
            const ctx = canvas.getContext('2d');
            const cx = s / 2;
            const cy = s / 2;
            
            const grad = ctx.createRadialGradient(cx - bucket * 0.35, cy - bucket * 0.35, 0, cx, cy, bucket);
            grad.addColorStop(0, c.light + 'FF');
            grad.addColorStop(0.5, c.hex + 'E6');
            grad.addColorStop(1, c.dark + 'CC');
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(cx, cy, bucket, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = c.light + '88';
            ctx.lineWidth = 1;
            ctx.stroke();
            
            spriteCache.set(key, canvas);
            return canvas;
        }
        
        // Seeded random for consistent star field
        function seededRandom(seed) {
            const x = Math.sin(seed) * 10000;
            return x - Math.floor(x);
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // EVENT HANDLERS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function setupEvents() {
            window.addEventListener('resize', debounce(resize, 100));
            
            // View tabs
            document.querySelectorAll('.tab').forEach(t => {
                t.addEventListener('click', () => switchView(t.dataset.view));
            });
            
            // Treemap events
            treemapCanvas.addEventListener('mousemove', onTreemapMove);
            treemapCanvas.addEventListener('click', onTreemapClick);
            treemapCanvas.addEventListener('mouseleave', () => {
                state.treemap.hovered = null;
                hideTooltip();
            });
            
            // Semantic 3D events
            semanticCanvas.addEventListener('mousedown', onSemanticDown);
            semanticCanvas.addEventListener('mousemove', onSemanticMove);
            semanticCanvas.addEventListener('mouseup', () => {
                if (state.semantic.dragging) {
                    state.semantic.dragging = false;
                    semanticCanvas.style.cursor = 'grab';
                    saveStateDebounced(); // Save camera state after drag
                }
            });
            semanticCanvas.addEventListener('mouseleave', () => {
                if (state.semantic.dragging) {
                    state.semantic.dragging = false;
                    saveStateDebounced();
                }
                state.semantic.hovered = null;
                hideTooltip();
            });
            semanticCanvas.addEventListener('wheel', e => {
                onSemanticWheel(e);
                saveStateDebounced(); // Save zoom after wheel
            }, { passive: false });
            semanticCanvas.addEventListener('click', onSemanticClick);
            
            // Controls
            document.querySelectorAll('.ctrl-btn').forEach(b => {
                b.addEventListener('click', () => onControl(b));
            });
            
            document.querySelectorAll('.zoom-btn').forEach(b => {
                b.addEventListener('click', () => {
                    const delta = b.dataset.dir === 'in' ? CONFIG.render.zoomStep : 1 / CONFIG.render.zoomStep;
                    state.semantic.zoom = Math.max(CONFIG.render.zoomMin, Math.min(CONFIG.render.zoomMax, state.semantic.zoom * delta));
                });
            });
            
            // Layer toggles
            document.querySelectorAll('.layer-toggle input').forEach(input => {
                input.addEventListener('change', () => {
                    const layer = input.dataset.layer;
                    state.semantic.layers[layer] = input.checked;
                    if (layer === 'focus' && input.checked && !state.semantic.selected) {
                        showToast('Select a file to focus its cluster');
                    }
                    saveStateDebounced();
                });
            });
            
            // Deep Semantic Search
            const searchInput = document.getElementById('search');
            const searchResults = document.getElementById('search-results');
            let searchSelectedIdx = -1;
            
            searchInput.addEventListener('input', debounce(e => {
                const query = e.target.value.trim();
                state.query = query;
                performSearch(query);
            }, CONFIG.ui.searchDebounce));
            
            searchInput.addEventListener('focus', () => {
                if (searchInput.value.trim()) performSearch(searchInput.value.trim());
            });
            
            searchInput.addEventListener('blur', () => {
                setTimeout(() => searchResults.classList.remove('active'), 200);
            });
            
            searchInput.addEventListener('keydown', e => {
                const results = searchResults.querySelectorAll('.search-result');
                if (!results.length) return;
                
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    searchSelectedIdx = Math.min(searchSelectedIdx + 1, results.length - 1);
                    updateSearchSelection(results);
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    searchSelectedIdx = Math.max(searchSelectedIdx - 1, 0);
                    updateSearchSelection(results);
                } else if (e.key === 'Enter' && searchSelectedIdx >= 0) {
                    e.preventDefault();
                    results[searchSelectedIdx].click();
                }
            });
            
            function updateSearchSelection(results) {
                results.forEach((r, i) => r.classList.toggle('selected', i === searchSelectedIdx));
                if (searchSelectedIdx >= 0) results[searchSelectedIdx].scrollIntoView({ block: 'nearest' });
            }
            
            function performSearch(query) {
                if (!query || query.length < CONFIG.ui.searchMinLength) {
                    searchResults.classList.remove('active');
                    return;
                }
                
                const tokens = tokenize(query);
                const scored = state.files.map(f => ({
                    file: f,
                    score: scoreFile(f, tokens),
                    matches: findMatches(f, tokens)
                })).filter(r => r.score > 0)
                  .sort((a, b) => b.score - a.score)
                  .slice(0, CONFIG.ui.searchMaxResults);
                
                if (!scored.length) {
                    searchResults.innerHTML = '<div class="search-empty">No results for "' + escapeHtml(query) + '"</div>';
                } else {
                    const grouped = groupResults(scored);
                    searchResults.innerHTML = renderSearchResults(grouped, tokens);
                    
                    searchResults.querySelectorAll('.search-result').forEach((el, i) => {
                        el.addEventListener('click', () => {
                            const file = scored[i].file;
                            selectFile(file);
                            searchResults.classList.remove('active');
                            searchInput.blur();
                        });
                    });
                }
                
                searchSelectedIdx = -1;
                searchResults.classList.add('active');
            }
            
            function tokenize(query) {
                return query.toLowerCase()
                    .split(/[\s\-_./\\]+/)
                    .filter(t => t.length >= 2)
                    .map(t => ({ text: t, regex: new RegExp('(' + escapeRegex(t) + ')', 'gi') }));
            }
            
            function scoreFile(file, tokens) {
                let score = 0;
                const name = (file.name || '').toLowerCase();
                const path = (file.path || '').toLowerCase();
                const funcs = (file.functions || []).join(' ').toLowerCase();
                const classes = (file.classes || []).join(' ').toLowerCase();
                const keywords = (file.keywords || []).join(' ').toLowerCase();
                const summary = (file.summary || '').toLowerCase();
                const concepts = (file.concepts || []).join(' ').toLowerCase();
                const exportsList = (file.exports || []).join(' ').toLowerCase();
                
                for (const { text } of tokens) {
                    // Exact name match (highest)
                    if (name === text) score += 100;
                    // Name starts with token
                    else if (name.startsWith(text)) score += 50;
                    // Name contains token
                    else if (name.includes(text)) score += 30;
                    
                    // Path match
                    if (path.includes(text)) score += 15;
                    
                    // Function/class/keyword matches (semantic)
                    if (funcs.includes(text)) score += 25;
                    if (classes.includes(text)) score += 25;
                    if (keywords.includes(text)) score += 20;
                    if (summary.includes(text)) score += 10;
                    if (concepts.includes(text)) score += 12;
                    if (exportsList.includes(text)) score += 10;
                    
                    // Category match
                    if ((file.category || '').toLowerCase().includes(text)) score += 15;
                }
                
                // Boost important files
                score *= (1 + (file.importance || 0) * 0.5);
                
                // Boost by line count (more code = more relevant)
                score *= (1 + Math.log10(Math.max(1, file.lines || 1)) * 0.1);
                
                return score;
            }
            
            function findMatches(file, tokens) {
                const matches = { name: [], path: [], funcs: [], classes: [], keywords: [], concepts: [], exports: [] };
                
                for (const { text } of tokens) {
                    if ((file.name || '').toLowerCase().includes(text)) matches.name.push(text);
                    if ((file.path || '').toLowerCase().includes(text)) matches.path.push(text);
                    
                    (file.functions || []).forEach(f => {
                        if (f.toLowerCase().includes(text)) matches.funcs.push(f);
                    });
                    (file.classes || []).forEach(c => {
                        if (c.toLowerCase().includes(text)) matches.classes.push(c);
                    });
                    (file.keywords || []).forEach(k => {
                        if (k.toLowerCase().includes(text)) matches.keywords.push(k);
                    });
                    (file.concepts || []).forEach(c => {
                        if (c.toLowerCase().includes(text)) matches.concepts.push(c);
                    });
                    (file.exports || []).forEach(e => {
                        if (String(e).toLowerCase().includes(text)) matches.exports.push(e);
                    });
                }
                
                return matches;
            }
            
            function groupResults(scored) {
                // Group by category for better UX
                const groups = {};
                for (const r of scored) {
                    const cat = r.file.category || 'Other';
                    if (!groups[cat]) groups[cat] = [];
                    groups[cat].push(r);
                }
                return groups;
            }
            
            function renderSearchResults(groups, tokens) {
                let html = '';
                let flatIdx = 0;
                
                for (const [cat, results] of Object.entries(groups)) {
                    if (!results.length) continue;
                    
                    html += '<div class="search-header">' + escapeHtml(cat) + ' (' + results.length + ')</div>';
                    
                    for (const { file, score, matches } of results.slice(0, 10)) {
                        const color = getHSL(cat);
                        const icon = getCategoryIcon(cat);
                        const highlighted = highlightTokens(file.name || '', tokens);
                        const pathHighlighted = highlightTokens(file.path || '', tokens);
                        
                        html += '<div class="search-result" data-idx="' + flatIdx + '">';
                        html += '<div class="search-result-icon" style="background: hsla(' + color.h + ', ' + color.s + '%, ' + color.l + '%, 0.2); color: hsl(' + color.h + ', ' + color.s + '%, ' + color.l + '%)">' + icon + '</div>';
                        html += '<div class="search-result-content">';
                        html += '<div class="search-result-name">' + highlighted + '</div>';
                        html += '<div class="search-result-path">' + pathHighlighted + '</div>';
                        
                        if (file.summary) {
                            html += '<div class="search-result-summary">' + escapeHtml(truncate(file.summary, 90)) + '</div>';
                        }
                        
                        // Show matched functions/classes/keywords
                        const metaParts = [];
                        if (matches.funcs.length) metaParts.push('<span>Æ’ ' + matches.funcs.slice(0, 3).map(f => highlightTokens(f, tokens)).join(', ') + '</span>');
                        if (matches.classes.length) metaParts.push('<span>â—‡ ' + matches.classes.slice(0, 2).map(c => highlightTokens(c, tokens)).join(', ') + '</span>');
                        if (matches.keywords.length) metaParts.push('<span># ' + matches.keywords.slice(0, 3).map(k => highlightTokens(k, tokens)).join(', ') + '</span>');
                        if (matches.concepts.length) metaParts.push('<span>âœ¦ ' + matches.concepts.slice(0, 2).map(k => highlightTokens(k, tokens)).join(', ') + '</span>');
                        if (file.lines) metaParts.push('<span>' + formatNum(file.lines) + ' lines</span>');
                        
                        if (metaParts.length) {
                            html += '<div class="search-result-meta">' + metaParts.join('') + '</div>';
                        }
                        
                        html += '</div>';
                        html += '<span class="search-result-score">' + Math.round(score) + '</span>';
                        html += '</div>';
                        flatIdx++;
                    }
                }
                
                return html;
            }
            
            function highlightTokens(text, tokens) {
                let result = escapeHtml(text);
                for (const { regex } of tokens) {
                    result = result.replace(regex, '<span class="token-match">$1</span>');
                }
                return result;
            }
            
            // Panel close
            document.getElementById('panel-close').addEventListener('click', closePanel);
            
            // Keyboard
            document.addEventListener('keydown', e => {
                if (e.key === 'Escape') closePanel();
                if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
                    e.preventDefault();
                    searchInput.focus();
                }
                if (e.key === 'Backspace' && state.view === 'treemap' && state.treemap.path.length && document.activeElement !== searchInput) {
                    e.preventDefault();
                    state.treemap.path.pop();
                    updateBreadcrumbs();
                }
            });
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // VIEW TRANSITIONS â€” Street View-style smooth morphing
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function switchView(view, targetFile = null) {
            if (state.transition.active) return;
            if (state.view === view && !targetFile) return;
            
            const fromView = state.view;
            const toView = view;
            
            // Start transition
            state.transition = {
                active: true,
                progress: 0,
                fromView,
                toView,
                targetFile,
                startTime: performance.now(),
                duration: 600,
            };
            
            // Update UI immediately
            document.querySelectorAll('.tab').forEach(t => t.classList.toggle('active', t.dataset.view === view));
            
            // Show both views during transition
            const treemapView = document.getElementById('treemap-view');
            const semanticView = document.getElementById('semantic-view');
            
            treemapView.style.transition = 'opacity 0.5s ease-out, transform 0.5s ease-out';
            semanticView.style.transition = 'opacity 0.5s ease-out, transform 0.5s ease-out';
            
            if (toView === 'semantic') {
                // Treemap â†’ 3D: Zoom in effect
                treemapView.style.opacity = '1';
                treemapView.style.transform = 'scale(1)';
                semanticView.classList.add('active');
                semanticView.style.opacity = '0';
                semanticView.style.transform = 'scale(0.8)';
                
                // If we have a target file, center the 3D view on it
                if (targetFile && targetFile.x !== undefined) {
                    // Calculate rotation to face the target file
                    const px = (targetFile.x - 0.5) * 2;
                    const pz = (targetFile.z - 0.5) * 2;
                    state.semantic.rotY = Math.atan2(px, pz);
                }
                
                requestAnimationFrame(() => {
                    resize(); // Ensure semantic canvas has dimensions
                    treemapView.style.opacity = '0';
                    treemapView.style.transform = 'scale(1.2)';
                    semanticView.style.opacity = '1';
                    semanticView.style.transform = 'scale(1)';
                });
                
                setTimeout(() => {
                    treemapView.classList.remove('active');
                    treemapView.style.transform = '';
                    treemapView.style.opacity = '';
                    semanticView.style.transform = '';
                    semanticView.style.opacity = '';
                    completeTransition(toView);
                }, 550);
                
            } else {
                // 3D â†’ Treemap: Zoom out effect
                semanticView.style.opacity = '1';
                semanticView.style.transform = 'scale(1)';
                treemapView.classList.add('active');
                treemapView.style.opacity = '0';
                treemapView.style.transform = 'scale(1.2)';
                
                requestAnimationFrame(() => {
                    resize();
                    semanticView.style.opacity = '0';
                    semanticView.style.transform = 'scale(0.8)';
                    treemapView.style.opacity = '1';
                    treemapView.style.transform = 'scale(1)';
                });
                
                setTimeout(() => {
                    semanticView.classList.remove('active');
                    semanticView.style.transform = '';
                    semanticView.style.opacity = '';
                    treemapView.style.transform = '';
                    treemapView.style.opacity = '';
                    completeTransition(toView);
                }, 550);
            }
        }
        
        function completeTransition(view) {
            state.view = view;
            state.transition.active = false;
            
            const is3D = view === 'semantic';
            document.getElementById('controls').style.display = is3D ? 'flex' : 'none';
            document.getElementById('zoom').style.display = is3D ? 'flex' : 'none';
            document.getElementById('layers-panel').style.display = is3D ? 'flex' : 'none';
            document.getElementById('breadcrumbs').style.display = is3D ? 'none' : 'flex';
            
            // Persist state
            saveState();
        }
        
        function transitionToFile(file) {
            // Navigate to file's location in treemap, then transition to 3D centered on it
            if (file) {
                state.semantic.selected = file;
                state.semantic.related = findRelatedByImports(file);
                switchView('semantic', file);
            }
        }
        
        function onTreemapMove(e) {
            const rect = treemapCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            state.treemap.hovered = null;
            
            // Find hovered cell (reverse order for front-to-back)
            for (let i = state.treemap.cells.length - 1; i >= 0; i--) {
                const cell = state.treemap.cells[i];
                if (x >= cell.x && x <= cell.x + cell.w && y >= cell.y && y <= cell.y + cell.h) {
                    state.treemap.hovered = cell.node;
                    break;
                }
            }
            
            if (state.treemap.hovered) {
                showTooltip(state.treemap.hovered, e.clientX, e.clientY);
                treemapCanvas.style.cursor = 'pointer';
            } else {
                hideTooltip();
                treemapCanvas.style.cursor = 'default';
            }
        }
        
        function onTreemapClick() {
            const node = state.treemap.hovered;
            if (!node) return;
            
            if (node.isFile && node.file) {
                selectFile(node.file);
            } else if (!node.isFile && node.children) {
                state.treemap.path.push(node.name);
                updateBreadcrumbs();
                saveState();
            }
        }
        
        function onSemanticDown(e) {
            state.semantic.dragging = true;
            state.semantic.lastX = e.clientX;
            state.semantic.lastY = e.clientY;
            semanticCanvas.style.cursor = 'grabbing';
        }
        
        function onSemanticMove(e) {
            if (state.semantic.dragging) {
                const dx = e.clientX - state.semantic.lastX;
                const dy = e.clientY - state.semantic.lastY;
                state.semantic.targetRotY += dx * CONFIG.render.rotationSensitivity;
                state.semantic.targetRotX += dy * CONFIG.render.rotationSensitivity;
                state.semantic.targetRotX = Math.max(-CONFIG.render.rotationClamp, Math.min(CONFIG.render.rotationClamp, state.semantic.targetRotX));
                state.semantic.lastX = e.clientX;
                state.semantic.lastY = e.clientY;
            } else {
                const rect = semanticCanvas.getBoundingClientRect();
                const mx = e.clientX - rect.left;
                const my = e.clientY - rect.top;
                
                state.semantic.hovered = findNodeAt(mx, my);
                
                if (state.semantic.hovered) {
                    showTooltip(state.semantic.hovered, e.clientX, e.clientY);
                    semanticCanvas.style.cursor = 'pointer';
                } else {
                    hideTooltip();
                    semanticCanvas.style.cursor = 'grab';
                }
            }
        }
        
        function onSemanticWheel(e) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 1 / CONFIG.render.zoomStep : CONFIG.render.zoomStep;
            state.semantic.zoom = Math.max(CONFIG.render.zoomMin, Math.min(CONFIG.render.zoomMax, state.semantic.zoom * delta));
        }
        
        function onSemanticClick(e) {
            if (state.semantic.dragging) return;
            
            if (state.semantic.hovered) {
                selectFile(state.semantic.hovered);
            } else {
                // Click on empty space - deselect
                closePanel();
            }
        }
        
        function onControl(btn) {
            const preset = btn.dataset.preset;
            const action = btn.dataset.action;
            
            if (preset) {
                document.querySelectorAll('.ctrl-btn[data-preset]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                if (preset === 'orbit') { state.semantic.targetRotX = CONFIG.render.initialRotX; state.semantic.targetRotY = CONFIG.render.initialRotY; }
                else if (preset === 'top') { state.semantic.targetRotX = Math.PI / 2 - 0.1; state.semantic.targetRotY = CONFIG.render.initialRotY; }
                else if (preset === 'front') { state.semantic.targetRotX = 0; state.semantic.targetRotY = CONFIG.render.initialRotY; }
                
                saveState();
            }
            
            if (action === 'reset') {
                state.semantic.targetRotX = CONFIG.render.initialRotX;
                state.semantic.targetRotY = CONFIG.render.initialRotY;
                state.semantic.zoom = 1.0;
                saveState();
            }
            
            if (action === 'auto') {
                state.semantic.autoRotate = !state.semantic.autoRotate;
                btn.classList.toggle('active', state.semantic.autoRotate);
                saveState();
            }
            
            if (action === 'back') {
                // Smooth transition back to treemap
                switchView('treemap');
            }
        }
        
        // Find related files by actual import relationships
        function findRelatedByImports(file) {
            if (!file || !file.path) return [];
            
            const related = new Set();
            const imports = file.imports || [];
            const importedBy = state.importGraph.importedBy[file.path] || [];
            
            // Files this file imports
            for (const imp of imports) {
                const target = state.files.find(f => 
                    f.path === imp || 
                    f.path.endsWith('/' + imp) ||
                    f.name === imp ||
                    f.path.includes(imp.replace(/\./g, '/'))
                );
                if (target) related.add(target);
            }
            
            // Files that import this file
            for (const imp of importedBy) {
                const source = state.files.find(f => f.path === imp);
                if (source) related.add(source);
            }
            
            // Also add proximity-based similarity as fallback
            const proximityRelated = findSimilar(file, 5);
            proximityRelated.forEach(f => related.add(f));
            
            return Array.from(related).slice(0, CONFIG.ui.maxSimilarFiles);
        }
        
        function findNodeAt(mx, my) {
            // Search from front to back (reverse of draw order)
            const projected = state.semantic.projected;
            for (let i = projected.length - 1; i >= 0; i--) {
                const p = projected[i];
                const baseSize = CONFIG.render.nodeBaseSize + Math.sqrt(p.file.lines || 1) * CONFIG.render.nodeSizeScale + (p.file.importance || 0) * CONFIG.render.importanceScale;
                const depthScale = CONFIG.render.depthScaleMin + p.depth * CONFIG.render.depthScaleMax;
                const size = baseSize * depthScale;
                const hitRadius = Math.max(CONFIG.render.hitRadiusMin, size * CONFIG.render.hitRadiusScale);
                
                const dist = Math.hypot(p.sx - mx, p.sy - my);
                if (dist < hitRadius) {
                    return p.file;
                }
            }
            return null;
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // UI HELPERS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function getVisibleFiles() {
            let files = state.files;
            
            // Apply filter
            if (state.filter) {
                files = files.filter(f => f.category === state.filter);
            }
            
            // Apply search query
            if (state.query && state.query.length >= CONFIG.ui.searchMinLength) {
                const q = state.query.toLowerCase();
                files = files.filter(f => 
                    (f.path && f.path.toLowerCase().includes(q)) ||
                    (f.name && f.name.toLowerCase().includes(q)) ||
                    (f.functions && f.functions.some(fn => fn.toLowerCase().includes(q))) ||
                    (f.classes && f.classes.some(c => c.toLowerCase().includes(q)))
                );
            }
            
            return files;
        }
        
        function updateStats() {
            const visibleFiles = getVisibleFiles();
            const totalFiles = state.files.length;
            const visibleLines = visibleFiles.reduce((s, f) => s + (f.lines || 0), 0);
            const totalLines = state.files.reduce((s, f) => s + (f.lines || 0), 0);
            const totalClusters = state.data?.stats?.clusters || 0;
            
            // Update state for derived stats
            state.stats.totalFiles = totalFiles;
            state.stats.visibleFiles = visibleFiles.length;
            state.stats.totalLines = totalLines;
            state.stats.visibleLines = visibleLines;
            
            const fileCountEl = document.getElementById('file-count');
            const lineCountEl = document.getElementById('line-count');
            const clusterCountEl = document.getElementById('cluster-count');
            const fileTotalEl = document.getElementById('file-total');
            const lineTotalEl = document.getElementById('line-total');
            
            // Show filtered count if different from total
            const isFiltered = state.filter || (state.query && state.query.length >= CONFIG.ui.searchMinLength);
            
            if (isFiltered) {
                animateNumber(fileCountEl, visibleFiles.length);
                animateNumber(lineCountEl, visibleLines);
                if (fileTotalEl) fileTotalEl.textContent = `/${formatNum(totalFiles)}`;
                if (lineTotalEl) lineTotalEl.textContent = `/${formatNum(totalLines)}`;
            } else {
                animateNumber(fileCountEl, totalFiles);
                animateNumber(lineCountEl, totalLines);
                if (fileTotalEl) fileTotalEl.textContent = '';
                if (lineTotalEl) lineTotalEl.textContent = '';
            }
            
            if (clusterCountEl) clusterCountEl.textContent = formatNum(totalClusters);
        }
        
        function animateNumber(el, targetValue) {
            if (!el) return;
            
            const currentText = el.textContent.replace(/,/g, '');
            const currentValue = parseInt(currentText) || 0;
            
            if (currentValue === targetValue) return;
            
            // Quick animation
            const duration = CONFIG.ui.durationNormal;
            const steps = 12;
            const stepTime = duration / steps;
            const diff = targetValue - currentValue;
            let step = 0;
            
            const animate = () => {
                step++;
                const progress = step / steps;
                const eased = 1 - Math.pow(1 - progress, 3); // Ease out cubic
                const value = Math.round(currentValue + diff * eased);
                el.textContent = formatNum(value);
                
                if (step < steps) {
                    setTimeout(animate, stepTime);
                }
            };
            
            animate();
        }
        
        function buildLegend() {
            const counts = {};
            const lines = {};
            for (const f of state.files) {
                const cat = f.category || 'Other';
                counts[cat] = (counts[cat] || 0) + 1;
                lines[cat] = (lines[cat] || 0) + (f.lines || 0);
            }
            
            const sorted = Object.entries(counts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, CONFIG.ui.maxLegendItems);
            
            const legend = document.getElementById('legend');
            legend.innerHTML = `
                <div class="legend-title">Categories</div>
                ${sorted.map(([name, count]) => `
                    <div class="legend-item ${state.filter === name ? 'active' : ''}" data-cat="${name}">
                        <div class="legend-dot" style="background:${getColor(name)};color:${getColor(name)}"></div>
                        <span class="legend-name">${name}</span>
                        <span class="legend-count">${count}</span>
                        <span class="legend-lines">${formatNum(lines[name] || 0)}</span>
                    </div>
                `).join('')}
            `;
            
            legend.querySelectorAll('.legend-item').forEach(el => {
                el.addEventListener('click', () => {
                    state.filter = state.filter === el.dataset.cat ? null : el.dataset.cat;
                    buildLegend();
                    updateStats(); // Update stats when filter changes
                    saveState();
                });
            });
        }
        
        function updateBreadcrumbs() {
            const parts = ['root', ...state.treemap.path];
            const bc = document.getElementById('breadcrumbs');
            bc.innerHTML = parts.map((p, i) => `
                <span class="crumb ${i === parts.length - 1 ? 'current' : ''}" data-idx="${i}">${p}</span>
                ${i < parts.length - 1 ? '<span class="crumb-sep">/</span>' : ''}
            `).join('');
            
            bc.querySelectorAll('.crumb').forEach(el => {
                el.addEventListener('click', () => {
                    const idx = parseInt(el.dataset.idx);
                    state.treemap.path = state.treemap.path.slice(0, idx);
                    updateBreadcrumbs();
                    saveState();
                });
            });
        }
        
        function showTooltip(item, x, y) {
            clearTimeout(state.tooltipTimer);
            
            const t = document.getElementById('tooltip');
            const file = item.file || item;
            const cat = file.category || item.category || 'Other';
            const c = COLORS[cat] || COLORS.Other;
            const clusterLabel = getClusterLabel(file.cluster);
            
            // Build rich tooltip content
            let html = `
                <div class="tt-header">
                    <span class="tt-icon" style="background: ${c.hex}20; color: ${c.hex}">${getCategoryIcon(cat)}</span>
                    <div class="tt-title">
                        <div class="tt-name">${escapeHtml(file.name || item.name)}</div>
                        <div class="tt-path">${escapeHtml(file.path || item.path)}</div>
                    </div>
                </div>
                <div class="tt-stats">
                    <span class="tt-stat"><strong>${formatNum(file.lines || item.lines)}</strong> lines</span>
                    <span class="tt-stat tt-cat" style="background: ${c.hex}30; color: ${c.light}">${cat}</span>
                    ${file.cluster !== undefined ? `<span class="tt-stat">Cluster #${file.cluster}${clusterLabel ? ` Â· ${escapeHtml(clusterLabel)}` : ''}</span>` : ''}
                </div>
            `;
            
            // Functions (up to 5)
            const funcs = file.functions || [];
            if (funcs.length > 0) {
                const display = funcs.slice(0, 5);
                const more = funcs.length > 5 ? ` <span class="tt-more">+${funcs.length - 5}</span>` : '';
                html += `
                    <div class="tt-section">
                        <span class="tt-label">Functions</span>
                        <span class="tt-values">${display.map(f => `<code>${escapeHtml(f)}</code>`).join(' ')}${more}</span>
                    </div>
                `;
            }
            
            // Classes (up to 3)
            const classes = file.classes || [];
            if (classes.length > 0) {
                const display = classes.slice(0, 3);
                const more = classes.length > 3 ? ` <span class="tt-more">+${classes.length - 3}</span>` : '';
                html += `
                    <div class="tt-section">
                        <span class="tt-label">Classes</span>
                        <span class="tt-values">${display.map(c => `<code>${escapeHtml(c)}</code>`).join(' ')}${more}</span>
                    </div>
                `;
            }
            
            // Imports (up to 4)
            const imports = file.imports || [];
            if (imports.length > 0) {
                const display = imports.slice(0, 4);
                const more = imports.length > 4 ? ` <span class="tt-more">+${imports.length - 4}</span>` : '';
                html += `
                    <div class="tt-section">
                        <span class="tt-label">Imports</span>
                        <span class="tt-values tt-imports">${display.map(i => `<span>${escapeHtml(i.split('/').pop())}</span>`).join('')}${more}</span>
                    </div>
                `;
            }
            
            // Keywords (up to 6)
            const keywords = file.keywords || [];
            if (keywords.length > 0) {
                const display = keywords.slice(0, 6);
                html += `
                    <div class="tt-section">
                        <span class="tt-label">Keywords</span>
                        <span class="tt-tags">${display.map(k => `<span class="tt-tag">${escapeHtml(k)}</span>`).join('')}</span>
                    </div>
                `;
            }
            
            // Concepts (up to 4)
            const concepts = file.concepts || [];
            if (concepts.length > 0) {
                const display = concepts.slice(0, 4);
                html += `
                    <div class="tt-section">
                        <span class="tt-label">Concepts</span>
                        <span class="tt-tags">${display.map(k => `<span class="tt-tag">${escapeHtml(k)}</span>`).join('')}</span>
                    </div>
                `;
            }
            
            // Docstring preview
            if (file.docstring) {
                const preview = file.docstring.length > 100 ? file.docstring.slice(0, 100) + 'â€¦' : file.docstring;
                html += `<div class="tt-doc">${escapeHtml(preview)}</div>`;
            }
            
            // Summary preview
            if (file.summary) {
                html += `<div class="tt-doc">${escapeHtml(file.summary)}</div>`;
            }
            
            t.innerHTML = html;
            
            // Position with smart edge detection
            const pad = 16;
            const maxWidth = 360;
            const estimatedHeight = 200 + (funcs.length > 0 ? 30 : 0) + (classes.length > 0 ? 30 : 0) + (imports.length > 0 ? 30 : 0);
            
            let left = x + pad;
            let top = y + pad;
            
            if (left + maxWidth > window.innerWidth - 20) {
                left = x - maxWidth - pad;
            }
            if (top + estimatedHeight > window.innerHeight - 20) {
                top = Math.max(20, window.innerHeight - estimatedHeight - 20);
            }
            
            t.style.left = left + 'px';
            t.style.top = top + 'px';
            t.classList.add('visible');
        }
        
        function hideTooltip() {
            clearTimeout(state.tooltipTimer);
            document.getElementById('tooltip').classList.remove('visible');
        }
        
        function selectFile(file) {
            if (!file || typeof file !== 'object') return;
            if (!file.path) return;
            
            state.treemap.selected = file;
            state.semantic.selected = file;
            state.semantic.related = findSimilar(file, CONFIG.ui.maxSimilarFiles);
            if (state.semantic.layers.focus) {
                state.semantic.focusClusterId = file.cluster ?? null;
            }
            
            showPanel(file);
        }
        
        function findSimilar(file, limit = 5) {
            if (!file || file.x === undefined || file.y === undefined || file.z === undefined) return [];
            
            const results = [];
            
            for (const f of state.files) {
                if (f === file) continue;
                if (f.x === undefined || f.y === undefined || f.z === undefined) continue;
                
                const dist = Math.sqrt(
                    (f.x - file.x) ** 2 +
                    (f.y - file.y) ** 2 +
                    (f.z - file.z) ** 2
                );
                
                let score = Math.max(0, 1 - dist * CONFIG.similarity.distanceScale);
                
                // Boost for same cluster
                if (f.cluster !== undefined && f.cluster === file.cluster) {
                    score += CONFIG.similarity.clusterBoost;
                }
                
                // Boost for same category
                if (f.category === file.category) {
                    score += CONFIG.similarity.categoryBoost;
                }
                
                if (score > CONFIG.similarity.minScore) {
                    results.push({ file: f, score, dist });
                }
            }
            
            return results
                .sort((a, b) => b.score - a.score)
                .slice(0, limit)
                .map(r => r.file);
        }
        
        function showPanel(file) {
            const cat = file.category || 'Other';
            const c = COLORS[cat] || COLORS.Other;
            const clusterLabel = getClusterLabel(file.cluster);
            
            document.getElementById('panel-title').textContent = file.name || file.path.split('/').pop();
            document.getElementById('panel-path').textContent = file.path;
            
            // Get related files by imports
            const importRelated = findRelatedByImports(file);
            const similar = findSimilar(file, CONFIG.ui.panelSimilarFiles);
            
            // Build imports/importedBy lists
            const imports = file.imports || [];
            const importedBy = state.importGraph.importedBy[file.path] || [];
            const funcs = file.functions || [];
            const classes = file.classes || [];
            const keywords = file.keywords || [];
            
            let html = `
                <!-- Stats Grid -->
                <div class="info-grid">
                    <div class="info-box">
                        <div class="info-box-label">Lines</div>
                        <div class="info-box-value">${formatNum(file.lines || 0)}</div>
                    </div>
                    <div class="info-box">
                        <div class="info-box-label">Category</div>
                        <div class="info-box-value" style="color:${c.hex}">${cat}</div>
                    </div>
                    <div class="info-box">
                        <div class="info-box-label">Cluster</div>
                        <div class="info-box-value">#${file.cluster ?? 'â€”'}</div>
                    </div>
                    <div class="info-box">
                        <div class="info-box-label">Importance</div>
                        <div class="info-box-value">${file.importance ? (file.importance * 100).toFixed(0) + '%' : 'â€”'}</div>
                    </div>
                    <div class="info-box">
                        <div class="info-box-label">Cluster Label</div>
                        <div class="info-box-value">${clusterLabel || 'â€”'}</div>
                    </div>
                </div>
            `;
            
            const clusterMeta = state.data?.clusterMeta?.[String(file.cluster ?? '')];
            if (clusterMeta) {
                const clusterCats = (clusterMeta.topCategories || []).slice(0, 4);
                const clusterKeywords = (clusterMeta.topKeywords || []).slice(0, 10);
                html += `
                    <div class="section-title">Cluster Context</div>
                    ${clusterCats.length ? `
                        <div class="panel-tags">
                            ${clusterCats.map(([catName]) => `<span class="panel-badge" style="border-color:${getColor(catName)}55;color:${getColor(catName)}">${escapeHtml(catName)}</span>`).join('')}
                        </div>
                    ` : ''}
                    ${clusterKeywords.length ? `
                        <div class="panel-tags" style="margin-top: 8px;">
                            ${clusterKeywords.map(k => `<span class="panel-tag">${escapeHtml(k)}</span>`).join('')}
                        </div>
                    ` : ''}
                `;
            }
            
            if (file.summary) {
                html += `
                    <div class="section-title">Summary</div>
                    <div class="panel-summary">${escapeHtml(file.summary)}</div>
                `;
            }
            
            // Docstring
            if (file.docstring) {
                html += `
                    <div class="section-title">Documentation</div>
                    <div class="panel-doc">${escapeHtml(file.docstring)}</div>
                `;
            }
            
            // Functions
            if (funcs.length > 0) {
                html += `
                    <div class="section-title">Functions <span class="section-count">${funcs.length}</span></div>
                    <div class="panel-list">
                        ${funcs.slice(0, 15).map(f => `<code class="panel-code">${escapeHtml(f)}()</code>`).join('')}
                        ${funcs.length > 15 ? `<span class="panel-more">+${funcs.length - 15} more</span>` : ''}
                    </div>
                `;
            }
            
            // Classes
            if (classes.length > 0) {
                html += `
                    <div class="section-title">Classes <span class="section-count">${classes.length}</span></div>
                    <div class="panel-list">
                        ${classes.map(c => `<code class="panel-code panel-class">${escapeHtml(c)}</code>`).join('')}
                    </div>
                `;
            }
            
            // Keywords
            if (keywords.length > 0) {
                html += `
                    <div class="section-title">Keywords</div>
                    <div class="panel-tags">
                        ${keywords.slice(0, 12).map(k => `<span class="panel-tag">${escapeHtml(k)}</span>`).join('')}
                    </div>
                `;
            }
            
            const concepts = file.concepts || [];
            if (concepts.length > 0) {
                html += `
                    <div class="section-title">Concepts</div>
                    <div class="panel-tags">
                        ${concepts.slice(0, 10).map(k => `<span class="panel-tag">${escapeHtml(k)}</span>`).join('')}
                    </div>
                `;
            }
            
            const exportsList = file.exports || [];
            if (exportsList.length > 0) {
                html += `
                    <div class="section-title">Exports <span class="section-count">${exportsList.length}</span></div>
                    <div class="panel-list">
                        ${exportsList.slice(0, 12).map(e => `<code class="panel-code">${escapeHtml(e)}</code>`).join('')}
                        ${exportsList.length > 12 ? `<span class="panel-more">+${exportsList.length - 12} more</span>` : ''}
                    </div>
                `;
            }
            
            // Imports (Dependency Graph)
            if (imports.length > 0) {
                html += `
                    <div class="section-title">Imports <span class="section-count">${imports.length}</span></div>
                    <div class="panel-deps">
                        ${imports.slice(0, 10).map(imp => {
                            const short = imp.split('/').pop();
                            const targetFile = state.files.find(f => 
                                f.path === imp || 
                                f.path.endsWith('/' + imp) ||
                                f.name === short
                            );
                            const exists = !!targetFile;
                            return `
                                <div class="panel-dep ${exists ? 'clickable' : ''}" ${exists ? `data-path="${targetFile.path}"` : ''}>
                                    <span class="dep-arrow">â†’</span>
                                    <span class="dep-name">${escapeHtml(short)}</span>
                                    ${exists ? `<span class="dep-badge" style="background:${getColor(targetFile.category)}40;color:${getColor(targetFile.category)}">${targetFile.category}</span>` : ''}
                                </div>
                            `;
                        }).join('')}
                        ${imports.length > 10 ? `<div class="panel-more">+${imports.length - 10} more imports</div>` : ''}
                    </div>
                `;
            }
            
            // Imported By (Reverse Dependencies)
            if (importedBy.length > 0) {
                html += `
                    <div class="section-title">Imported By <span class="section-count">${importedBy.length}</span></div>
                    <div class="panel-deps">
                        ${importedBy.slice(0, 8).map(imp => {
                            const sourceFile = state.files.find(f => f.path === imp);
                            const short = imp.split('/').pop();
                            return sourceFile ? `
                                <div class="panel-dep clickable" data-path="${sourceFile.path}">
                                    <span class="dep-arrow">â†</span>
                                    <span class="dep-name">${escapeHtml(short)}</span>
                                    <span class="dep-badge" style="background:${getColor(sourceFile.category)}40;color:${getColor(sourceFile.category)}">${sourceFile.category}</span>
                                </div>
                            ` : '';
                        }).join('')}
                        ${importedBy.length > 8 ? `<div class="panel-more">+${importedBy.length - 8} more dependents</div>` : ''}
                    </div>
                `;
            }
            
            // Similar Files (by semantic proximity)
            if (similar.length > 0) {
                html += `
                    <div class="section-title">Semantically Similar</div>
                    ${similar.map(s => {
                        const dist = Math.sqrt(
                            (s.x - file.x) ** 2 + (s.y - file.y) ** 2 + (s.z - file.z) ** 2
                        );
                        const score = Math.max(0, Math.round((1 - dist) * 100));
                        const sc = COLORS[s.category] || COLORS.Other;
                        return `
                            <div class="similar-item" data-path="${s.path}">
                                <div class="similar-score">${score}</div>
                                <div class="similar-info">
                                    <div class="similar-name">${escapeHtml(s.name || s.path.split('/').pop())}</div>
                                    <div class="similar-cat" style="color:${sc.hex}">${s.category || 'Other'}</div>
                                </div>
                            </div>
                        `;
                    }).join('')}
                `;
            }
            
            // Action buttons
            html += `
                <div class="panel-actions">
                    <button class="panel-btn panel-btn-secondary" data-action="copy">
                        Copy Path
                    </button>
                    <button class="panel-btn panel-btn-primary" data-action="explore">
                        ğŸš€ Explore in 3D
                    </button>
                </div>
            `;
            
            document.getElementById('panel-content').innerHTML = html;
            
            // Event listeners for clickable elements
            document.querySelectorAll('.similar-item, .panel-dep.clickable').forEach(el => {
                el.addEventListener('click', () => {
                    const f = state.files.find(f => f.path === el.dataset.path);
                    if (f) selectFile(f);
                });
            });
            
            // Explore in 3D button
            document.querySelector('.panel-btn[data-action="explore"]')?.addEventListener('click', () => {
                transitionToFile(file);
            });
            
            document.querySelector('.panel-btn[data-action="copy"]')?.addEventListener('click', () => {
                copyToClipboard(file.path || '');
            });
            
            document.getElementById('panel').classList.add('open');
        }
        
        function closePanel() {
            document.getElementById('panel').classList.remove('open');
            state.treemap.selected = null;
            state.semantic.selected = null;
            state.semantic.related = [];
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // UTILITIES
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function formatNum(n) {
            if (n >= 1000000) return (n / 1000000).toFixed(1) + 'M';
            if (n >= 1000) return (n / 1000).toFixed(1) + 'K';
            return new Intl.NumberFormat().format(n);
        }
        
        function formatRelativeTime(iso) {
            const t = new Date(iso);
            if (Number.isNaN(t.getTime())) return 'â€”';
            const diff = Date.now() - t.getTime();
            const mins = Math.floor(diff / 60000);
            if (mins < 1) return 'just now';
            if (mins < 60) return `${mins}m ago`;
            const hours = Math.floor(mins / 60);
            if (hours < 24) return `${hours}h ago`;
            const days = Math.floor(hours / 24);
            return `${days}d ago`;
        }
        
        function truncate(text, maxLen) {
            if (!text) return '';
            const clean = String(text).trim();
            return clean.length > maxLen ? clean.slice(0, maxLen).trim() + 'â€¦' : clean;
        }
        
        function showToast(message) {
            const toast = document.getElementById('toast');
            if (!toast) return;
            toast.textContent = message;
            toast.classList.add('show');
            clearTimeout(showToast._t);
            showToast._t = setTimeout(() => toast.classList.remove('show'), 1400);
        }
        
        async function copyToClipboard(text) {
            if (!text) return;
            try {
                if (navigator.clipboard?.writeText) {
                    await navigator.clipboard.writeText(text);
                } else {
                    const input = document.createElement('textarea');
                    input.value = text;
                    input.style.position = 'fixed';
                    input.style.left = '-9999px';
                    document.body.appendChild(input);
                    input.select();
                    document.execCommand('copy');
                    document.body.removeChild(input);
                }
                showToast('âœ“ Path copied');
            } catch (err) {
                showToast('Copy failed');
            }
        }
        
        function updateQuality(frameMs) {
            const prev = state.semantic.frameMsAvg || frameMs;
            const avg = prev * 0.85 + frameMs * 0.15;
            state.semantic.frameMsAvg = avg;
            
            if (avg > 28) state.semantic.quality = 'low';
            else if (avg > 18) state.semantic.quality = 'med';
            else state.semantic.quality = 'high';
        }
        
        function debounce(fn, ms) {
            let t;
            return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); };
        }
        
        function escapeHtml(str) {
            return String(str).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
        }
        
        function escapeRegex(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }
        
        function getCategoryIcon(cat) {
            const icons = {
                Python: 'ğŸ', JavaScript: 'ğŸ“œ', TypeScript: 'ğŸ’ ', Rust: 'ğŸ¦€',
                Swift: 'ğŸ', Kotlin: 'ğŸ¯', React: 'âš›ï¸', Web: 'ğŸŒ', Go: 'ğŸ”·',
                Test: 'ğŸ§ª', Config: 'âš™ï¸', Docs: 'ğŸ“š', Service: 'ğŸ”§', Java: 'â˜•',
                API: 'ğŸ”Œ', Model: 'ğŸ“Š', Utility: 'ğŸ› ï¸', Style: 'ğŸ¨', C: 'âš¡',
                Shell: 'ğŸ’»', Security: 'ğŸ”', Database: 'ğŸ—ƒï¸', Core: 'ğŸ’',
                Folder: 'ğŸ“', Other: 'ğŸ“„'
            };
            return icons[cat] || 'ğŸ“„';
        }
        
        function getClusterLabel(clusterId) {
            if (clusterId === undefined || clusterId === null) return '';
            const meta = state.data?.clusterMeta?.[String(clusterId)];
            if (!meta || !meta.topKeywords) return '';
            return meta.topKeywords.slice(0, 2).join(' Â· ');
        }
        
        // Service worker registration for PWA
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js').catch(() => {});
        }
        
        // Start
        init();
    </script>
</body>
</html>
