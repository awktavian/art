<!DOCTYPE html>
<html lang="en" data-lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#06060a">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="description" content="Interactive semantic code visualization â€” explore your codebase in 3D">
    
    <!-- PWA -->
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/svg+xml" href="icon.svg">
    <link rel="apple-touch-icon" href="icon-192.png">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600&family=IBM+Plex+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <title>Code Galaxy â€” Semantic Explorer</title>
    <link rel="stylesheet" href="css/main.css">
    
    <style>
        /* Critical CSS - inline for fast first paint */
        body.loading::before {
            content: '';
            position: fixed;
            inset: 0;
            background: #06060a;
            z-index: 9999;
        }
        
        body.loading::after {
            content: 'Loading...';
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #8a8880;
            font-family: system-ui, sans-serif;
            font-size: 14px;
            z-index: 10000;
        }
        
        /* View tabs */
        .view-tabs {
            display: flex;
            gap: 4px;
            padding: 4px;
            background: var(--surface);
            border-radius: 10px;
        }
        
        .view-tab {
            padding: 8px 16px;
            background: transparent;
            border: none;
            border-radius: 8px;
            color: var(--text-tertiary);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        
        .view-tab:hover {
            color: var(--text-secondary);
        }
        
        .view-tab.active {
            background: var(--gold);
            color: var(--void);
        }
        
        /* View containers */
        .view-container {
            display: none;
            width: 100%;
            height: 100%;
        }
        
        .view-container.active {
            display: block;
        }
        
        /* Breadcrumbs */
        .breadcrumbs {
            position: absolute;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: rgba(12,12,20,0.9);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border-subtle);
            border-radius: 10px;
            font-size: 13px;
            z-index: 50;
        }
        
        .breadcrumb {
            color: var(--text-tertiary);
            cursor: pointer;
            transition: color 0.15s ease;
        }
        
        .breadcrumb:hover {
            color: var(--text-primary);
        }
        
        .breadcrumb.current {
            color: var(--gold);
            font-weight: 500;
        }
        
        .breadcrumb-sep {
            color: var(--text-quaternary);
        }
        
        /* Install prompt */
        .install-prompt {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            align-items: center;
            gap: 12px;
            padding: 12px 20px;
            background: rgba(12,12,20,0.95);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border-medium);
            border-radius: 12px;
            z-index: 100;
        }
        
        .install-prompt.visible {
            display: flex;
        }
        
        .install-btn {
            padding: 8px 16px;
            background: var(--gold);
            border: none;
            border-radius: 8px;
            color: var(--void);
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
        }
        
        .install-dismiss {
            background: none;
            border: none;
            color: var(--text-tertiary);
            font-size: 18px;
            cursor: pointer;
        }
    </style>
</head>
<body class="loading">
    <!-- Skip link for accessibility -->
    <a href="#main" class="skip-link" data-i18n="skipToMain">Skip to main content</a>
    
    <!-- ARIA live region -->
    <div id="announcer" class="sr-only" aria-live="polite" aria-atomic="true"></div>
    
    <div id="app">
        <!-- Top Bar -->
        <header class="top-bar">
            <div class="logo">
                <span class="logo-icon">â¬¡</span>
                <span data-i18n="appTitle">Code Galaxy</span>
            </div>
            
            <div class="view-tabs">
                <button class="view-tab active" data-view="treemap" data-i18n="treemapView">Treemap</button>
                <button class="view-tab" data-view="semantic" data-i18n="semanticExplorer">3D Explorer</button>
            </div>
            
            <div class="search-box">
                <span class="search-icon">âŒ˜K</span>
                <input type="text" id="search" data-i18n-placeholder="searchPlaceholder" placeholder="Search files, classes, functions..." autocomplete="off" />
            </div>
            
            <div class="stats">
                <span><span class="stat-value" id="file-count">â€”</span> <span data-i18n="files">files</span></span>
                <span><span class="stat-value" id="line-count">â€”</span> <span data-i18n="lines">lines</span></span>
                <span><span class="stat-value" id="cluster-count">â€”</span> <span data-i18n="clusters">clusters</span></span>
            </div>
            
            <div class="lang-switcher">
                <button class="lang-btn active" data-lang="en">EN</button>
                <button class="lang-btn" data-lang="ja">æ—¥æœ¬èª</button>
            </div>
        </header>
        
        <!-- Main Content -->
        <main id="main" class="main-content">
            <!-- Treemap View -->
            <div id="treemap-view" class="view-container active">
                <canvas id="treemap-canvas"></canvas>
                <div class="breadcrumbs" id="breadcrumbs">
                    <span class="breadcrumb current" data-path="">root</span>
                </div>
            </div>
            
            <!-- 3D Semantic View -->
            <div id="semantic-view" class="view-container">
                <canvas id="semantic-canvas" tabindex="0" role="application" aria-label="3D semantic code explorer"></canvas>
            </div>
            
            <!-- Legend -->
            <aside class="legend" id="legend"></aside>
            
            <!-- Side Panel -->
            <aside class="side-panel" id="side-panel"></aside>
            
            <!-- Controls (for 3D view) -->
            <nav class="controls" id="controls" style="display: none;">
                <button class="control-btn active" data-view="orbit" title="Orbit View">ğŸŒ</button>
                <button class="control-btn" data-view="top" title="Top View">â¬‡</button>
                <button class="control-btn" data-view="front" title="Front View">â¡</button>
                <div class="control-divider"></div>
                <button class="control-btn" data-action="reset" title="Reset">â†º</button>
                <button class="control-btn" data-action="auto" title="Auto Rotate">â–¶</button>
            </nav>
            
            <!-- Zoom Controls -->
            <div class="zoom-controls" id="zoom-controls" style="display: none;">
                <button class="zoom-btn" data-zoom="in">+</button>
                <button class="zoom-btn" data-zoom="out">âˆ’</button>
            </div>
        </main>
        
        <!-- Tooltip -->
        <div class="tooltip" id="tooltip"></div>
        
        <!-- PWA Install Prompt -->
        <div class="install-prompt" id="install-prompt">
            <span>Install Code Galaxy for offline access</span>
            <button class="install-btn" id="install-btn">Install</button>
            <button class="install-dismiss" id="install-dismiss">Ã—</button>
        </div>
    </div>
    
    <!-- Application Script -->
    <script type="module">
        import { CONFIG, THEME, applyTheme, getCategoryColor, getCategoryHSL } from './js/config.js';
        import { initI18n, t, setLang, getLang, formatNumber, onLangChange, updateI18nElements } from './js/i18n.js';
        import { loadData, store, findSimilarFiles, searchFiles, getFileRelationships, getCategoryStats } from './js/data.js';
        import { SpatialGrid2D, ProjectionCache } from './js/spatial.js';
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // STATE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        const state = {
            view: 'treemap',
            treemap: {
                path: [],
                selected: null,
                hovered: null,
                spatialGrid: null,
            },
            semantic: {
                camera: { rotX: 0.4, rotY: 0, zoom: 1 },
                dragging: false,
                lastMouse: { x: 0, y: 0 },
                hovered: null,
                selected: null,
                autoRotate: false,
            },
            searchQuery: '',
            categoryFilter: null,
            highlightedRelated: [],
        };
        
        let treemapCanvas, treemapCtx;
        let semanticCanvas, semanticCtx;
        let animationId = null;
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // INITIALIZATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        async function init() {
            console.log(`Code Galaxy v${CONFIG.version}`);
            
            applyTheme();
            initI18n();
            
            // Canvas setup
            treemapCanvas = document.getElementById('treemap-canvas');
            semanticCanvas = document.getElementById('semantic-canvas');
            treemapCtx = treemapCanvas?.getContext('2d');
            semanticCtx = semanticCanvas?.getContext('2d');
            
            resizeCanvases();
            
            try {
                await loadData();
                console.log(`Loaded ${store.files.length} files with 3D coordinates`);
                
                updateStats();
                buildLegend();
                setupEventListeners();
                startRenderLoop();
                
                document.body.classList.remove('loading');
                document.body.classList.add('loaded');
                
                // Check for PWA install
                setupPWA();
                
            } catch (error) {
                console.error('Init failed:', error);
                document.body.innerHTML = `<div class="error-message">Failed to load: ${error.message}</div>`;
            }
        }
        
        function resizeCanvases() {
            const dpr = window.devicePixelRatio || 1;
            
            [treemapCanvas, semanticCanvas].forEach(canvas => {
                if (!canvas) return;
                const rect = canvas.parentElement.getBoundingClientRect();
                canvas.width = rect.width * dpr;
                canvas.height = rect.height * dpr;
                canvas.style.width = rect.width + 'px';
                canvas.style.height = rect.height + 'px';
                const ctx = canvas.getContext('2d');
                ctx.scale(dpr, dpr);
            });
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // RENDERING
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function startRenderLoop() {
            if (animationId) cancelAnimationFrame(animationId);
            render();
        }
        
        function render() {
            if (state.view === 'treemap') {
                renderTreemap();
            } else {
                renderSemantic();
            }
            animationId = requestAnimationFrame(render);
        }
        
        function renderTreemap() {
            if (!treemapCtx || !store.tree) return;
            
            const dpr = window.devicePixelRatio || 1;
            const w = treemapCanvas.width / dpr;
            const h = treemapCanvas.height / dpr;
            
            // Clear
            treemapCtx.fillStyle = THEME.colors.void;
            treemapCtx.fillRect(0, 0, w, h);
            
            // Navigate to current path
            let node = store.tree;
            for (const seg of state.treemap.path) {
                node = node.children?.[seg];
                if (!node) return;
            }
            
            // Build spatial index
            state.treemap.spatialGrid = new SpatialGrid2D(w, h);
            
            // Layout
            const cells = squarify(node, 4, 4, w - 8, h - 8);
            
            // Render cells
            for (const cell of cells) {
                renderCell(cell);
                state.treemap.spatialGrid.insert(cell.node, cell.x, cell.y, cell.w, cell.h);
            }
        }
        
        function squarify(node, x, y, w, h) {
            const children = Object.values(node.children || {}).filter(c => c.lines > 0);
            if (!children.length || w < 8 || h < 8) return [];
            
            children.sort((a, b) => b.lines - a.lines);
            const total = children.reduce((s, c) => s + c.lines, 0);
            
            const cells = [];
            let cx = x, cy = y, cw = w, ch = h;
            
            for (const child of children) {
                const ratio = child.lines / total;
                let cellW, cellH;
                
                if (cw > ch) {
                    cellW = Math.min(cw * ratio * children.length, cw);
                    cellH = ch;
                    cells.push({ node: child, x: cx, y: cy, w: cellW - 2, h: cellH - 2 });
                    cx += cellW;
                    cw -= cellW;
                } else {
                    cellW = cw;
                    cellH = Math.min(ch * ratio * children.length, ch);
                    cells.push({ node: child, x: cx, y: cy, w: cellW - 2, h: cellH - 2 });
                    cy += cellH;
                    ch -= cellH;
                }
            }
            
            return cells;
        }
        
        function renderCell({ node, x, y, w, h }) {
            const ctx = treemapCtx;
            const isHovered = state.treemap.hovered === node;
            const isSelected = state.treemap.selected === node;
            const cat = node.file?.category || (node.isFile ? 'Other' : 'Folder');
            const color = getCategoryHSL(cat);
            
            // Background
            ctx.fillStyle = `hsla(${color.h}, ${color.s}%, ${color.l}%, ${node.isFile ? 0.7 : 0.3})`;
            
            // Rounded rect
            const r = Math.min(6, w / 4, h / 4);
            ctx.beginPath();
            ctx.roundRect(x, y, w, h, r);
            ctx.fill();
            
            // Border
            if (isHovered || isSelected) {
                ctx.strokeStyle = isSelected ? THEME.colors.gold : THEME.colors.textPrimary;
                ctx.lineWidth = isSelected ? 2 : 1;
                ctx.stroke();
            }
            
            // Label
            if (w > 50 && h > 24) {
                ctx.fillStyle = THEME.colors.textPrimary;
                ctx.font = `500 12px ${THEME.fonts.sans}`;
                const label = node.name.length > Math.floor(w / 8) 
                    ? node.name.slice(0, Math.floor(w / 8) - 2) + 'â€¦' 
                    : node.name;
                ctx.fillText(label, x + 8, y + 16);
                
                if (h > 40) {
                    ctx.fillStyle = THEME.colors.textTertiary;
                    ctx.font = `400 10px ${THEME.fonts.mono}`;
                    ctx.fillText(formatNumber(node.lines) + ' lines', x + 8, y + 30);
                }
            }
        }
        
        function renderSemantic() {
            if (!semanticCtx || !store.files.length) return;
            
            const dpr = window.devicePixelRatio || 1;
            const w = semanticCanvas.width / dpr;
            const h = semanticCanvas.height / dpr;
            const ctx = semanticCtx;
            
            // Background gradient
            const grad = ctx.createRadialGradient(w/2, h/2, 0, w/2, h/2, Math.max(w, h) * 0.7);
            grad.addColorStop(0, '#0c0c18');
            grad.addColorStop(1, '#020206');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, w, h);
            
            // Filter files
            let files = store.files.filter(f => f.x != null && f.y != null && f.z != null);
            if (state.categoryFilter) {
                files = files.filter(f => f.category === state.categoryFilter);
            }
            if (state.searchQuery) {
                const q = state.searchQuery.toLowerCase();
                files = files.filter(f => f.path.toLowerCase().includes(q));
            }
            
            // Project
            const cx = w / 2, cy = h / 2;
            const scale = Math.min(w, h) * 0.38 * state.semantic.camera.zoom;
            
            const projected = files.map(f => ({
                file: f,
                ...project3D(f.x, f.y, f.z, cx, cy, scale)
            })).sort((a, b) => a.z - b.z);
            
            // Connections
            if (state.semantic.selected) {
                const selP = projected.find(p => p.file === state.semantic.selected);
                if (selP) {
                    for (const rel of state.highlightedRelated) {
                        const relP = projected.find(p => p.file === rel);
                        if (relP) {
                            ctx.beginPath();
                            ctx.moveTo(selP.x, selP.y);
                            ctx.lineTo(relP.x, relP.y);
                            ctx.strokeStyle = 'rgba(240,200,96,0.3)';
                            ctx.lineWidth = 2;
                            ctx.stroke();
                        }
                    }
                }
            }
            
            // Nodes
            for (const p of projected) {
                renderNode(ctx, p);
            }
            
            // Auto rotate
            if (state.semantic.autoRotate && !state.semantic.dragging) {
                state.semantic.camera.rotY += 0.002;
            }
        }
        
        function project3D(x, y, z, cx, cy, scale) {
            const cam = state.semantic.camera;
            const px = (x - 0.5) * 2, py = (y - 0.5) * 2, pz = (z - 0.5) * 2;
            
            const cosY = Math.cos(cam.rotY), sinY = Math.sin(cam.rotY);
            const x1 = px * cosY - pz * sinY;
            const z1 = px * sinY + pz * cosY;
            
            const cosX = Math.cos(cam.rotX), sinX = Math.sin(cam.rotX);
            const y1 = py * cosX - z1 * sinX;
            const z2 = py * sinX + z1 * cosX;
            
            const fov = 500, dist = 2;
            const perspective = fov / (fov + (z2 + dist) * scale * 0.6);
            
            return {
                x: cx + x1 * scale * perspective,
                y: cy + y1 * scale * perspective,
                z: z2,
                scale: perspective
            };
        }
        
        function renderNode(ctx, { file, x, y, z, scale }) {
            const isHovered = state.semantic.hovered === file;
            const isSelected = state.semantic.selected === file;
            const isRelated = state.highlightedRelated.includes(file);
            
            const baseSize = 2 + Math.sqrt(file.lines) * 0.15;
            const size = baseSize * scale * (isHovered ? 1.4 : 1) * (isSelected ? 1.6 : 1);
            const alpha = 0.4 + scale * 0.6;
            
            // Glow
            if (isSelected || isHovered || isRelated) {
                const glow = ctx.createRadialGradient(x, y, 0, x, y, size * 4);
                glow.addColorStop(0, getCategoryColor(file.category, 0.5));
                glow.addColorStop(1, 'transparent');
                ctx.fillStyle = glow;
                ctx.beginPath();
                ctx.arc(x, y, size * 4, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Node
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fillStyle = getCategoryColor(file.category, alpha);
            ctx.fill();
            
            // Core
            if (size > 4) {
                ctx.beginPath();
                ctx.arc(x, y, size * 0.35, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255,255,255,${alpha * 0.7})`;
                ctx.fill();
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // EVENT HANDLERS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function setupEventListeners() {
            window.addEventListener('resize', debounce(() => resizeCanvases(), 100));
            
            // View switching
            document.querySelectorAll('.view-tab').forEach(tab => {
                tab.addEventListener('click', () => switchView(tab.dataset.view));
            });
            
            // Treemap events
            if (treemapCanvas) {
                treemapCanvas.addEventListener('mousemove', onTreemapMove);
                treemapCanvas.addEventListener('click', onTreemapClick);
                treemapCanvas.addEventListener('mouseleave', () => {
                    state.treemap.hovered = null;
                    hideTooltip();
                });
            }
            
            // Semantic events
            if (semanticCanvas) {
                semanticCanvas.addEventListener('mousedown', onSemanticDown);
                semanticCanvas.addEventListener('mousemove', onSemanticMove);
                semanticCanvas.addEventListener('mouseup', () => state.semantic.dragging = false);
                semanticCanvas.addEventListener('mouseleave', () => {
                    state.semantic.dragging = false;
                    state.semantic.hovered = null;
                    hideTooltip();
                });
                semanticCanvas.addEventListener('wheel', onSemanticWheel, { passive: false });
                semanticCanvas.addEventListener('click', onSemanticClick);
            }
            
            // Search
            document.getElementById('search')?.addEventListener('input', debounce(e => {
                state.searchQuery = e.target.value;
            }, 150));
            
            // Controls
            document.querySelectorAll('.control-btn').forEach(btn => {
                btn.addEventListener('click', () => onControlClick(btn));
            });
            
            document.querySelectorAll('.zoom-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    state.semantic.camera.zoom *= btn.dataset.zoom === 'in' ? 1.2 : 0.8;
                    state.semantic.camera.zoom = Math.max(0.3, Math.min(5, state.semantic.camera.zoom));
                });
            });
            
            // Language
            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.lang-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    setLang(btn.dataset.lang);
                });
            });
            
            // Keyboard
            document.addEventListener('keydown', onKeyDown);
            
            // Language change callback
            onLangChange(() => {
                updateI18nElements();
                buildLegend();
            });
        }
        
        function switchView(view) {
            state.view = view;
            document.querySelectorAll('.view-tab').forEach(t => t.classList.toggle('active', t.dataset.view === view));
            document.querySelectorAll('.view-container').forEach(v => v.classList.toggle('active', v.id === view + '-view'));
            
            const show3DControls = view === 'semantic';
            document.getElementById('controls').style.display = show3DControls ? 'flex' : 'none';
            document.getElementById('zoom-controls').style.display = show3DControls ? 'flex' : 'none';
            document.getElementById('breadcrumbs').style.display = view === 'treemap' ? 'flex' : 'none';
        }
        
        function onTreemapMove(e) {
            const rect = treemapCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left, y = e.clientY - rect.top;
            
            const hits = state.treemap.spatialGrid?.queryPoint(x, y) || [];
            state.treemap.hovered = hits[hits.length - 1] || null;
            
            if (state.treemap.hovered) {
                showTooltip(state.treemap.hovered, e.clientX, e.clientY);
                treemapCanvas.style.cursor = 'pointer';
            } else {
                hideTooltip();
                treemapCanvas.style.cursor = 'default';
            }
        }
        
        function onTreemapClick() {
            const node = state.treemap.hovered;
            if (!node) return;
            
            if (node.isFile) {
                selectFile(node.file);
            } else {
                state.treemap.path.push(node.name);
                updateBreadcrumbs();
            }
        }
        
        function onSemanticDown(e) {
            state.semantic.dragging = true;
            state.semantic.lastMouse = { x: e.clientX, y: e.clientY };
            semanticCanvas.style.cursor = 'grabbing';
        }
        
        function onSemanticMove(e) {
            if (state.semantic.dragging) {
                const dx = e.clientX - state.semantic.lastMouse.x;
                const dy = e.clientY - state.semantic.lastMouse.y;
                state.semantic.camera.rotY += dx * 0.005;
                state.semantic.camera.rotX += dy * 0.005;
                state.semantic.camera.rotX = Math.max(-Math.PI/2, Math.min(Math.PI/2, state.semantic.camera.rotX));
                state.semantic.lastMouse = { x: e.clientX, y: e.clientY };
            } else {
                const rect = semanticCanvas.getBoundingClientRect();
                state.semantic.hovered = findNodeAt(e.clientX - rect.left, e.clientY - rect.top);
                
                if (state.semantic.hovered) {
                    showTooltip(state.semantic.hovered, e.clientX, e.clientY);
                    semanticCanvas.style.cursor = 'pointer';
                } else {
                    hideTooltip();
                    semanticCanvas.style.cursor = 'grab';
                }
            }
        }
        
        function onSemanticWheel(e) {
            e.preventDefault();
            state.semantic.camera.zoom *= e.deltaY > 0 ? 0.9 : 1.1;
            state.semantic.camera.zoom = Math.max(0.3, Math.min(5, state.semantic.camera.zoom));
        }
        
        function onSemanticClick() {
            if (state.semantic.hovered) {
                selectFile(state.semantic.hovered);
            }
        }
        
        function onControlClick(btn) {
            const view = btn.dataset.view;
            const action = btn.dataset.action;
            
            if (view) {
                document.querySelectorAll('.control-btn[data-view]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                if (view === 'orbit') { state.semantic.camera.rotX = 0.4; state.semantic.camera.rotY = 0; }
                else if (view === 'top') { state.semantic.camera.rotX = Math.PI/2; state.semantic.camera.rotY = 0; }
                else if (view === 'front') { state.semantic.camera.rotX = 0; state.semantic.camera.rotY = 0; }
            }
            
            if (action === 'reset') {
                state.semantic.camera = { rotX: 0.4, rotY: 0, zoom: 1 };
            }
            if (action === 'auto') {
                state.semantic.autoRotate = !state.semantic.autoRotate;
                btn.classList.toggle('active', state.semantic.autoRotate);
            }
        }
        
        function onKeyDown(e) {
            if (e.key === 'Escape') {
                state.treemap.selected = null;
                state.semantic.selected = null;
                state.highlightedRelated = [];
                hideSidePanel();
            }
            if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
                e.preventDefault();
                document.getElementById('search')?.focus();
            }
            if (e.key === 'Backspace' && state.view === 'treemap' && state.treemap.path.length > 0) {
                e.preventDefault();
                state.treemap.path.pop();
                updateBreadcrumbs();
            }
        }
        
        function findNodeAt(mx, my) {
            const dpr = window.devicePixelRatio || 1;
            const w = semanticCanvas.width / dpr, h = semanticCanvas.height / dpr;
            const cx = w / 2, cy = h / 2;
            const scale = Math.min(w, h) * 0.38 * state.semantic.camera.zoom;
            
            let closest = null, closestDist = 25;
            
            for (const f of store.files) {
                if (f.x == null) continue;
                const p = project3D(f.x, f.y, f.z, cx, cy, scale);
                const d = Math.hypot(p.x - mx, p.y - my);
                if (d < closestDist) { closestDist = d; closest = f; }
            }
            
            return closest;
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // UI HELPERS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function updateStats() {
            document.getElementById('file-count').textContent = formatNumber(store.stats?.totalFiles || 0);
            document.getElementById('line-count').textContent = formatNumber(store.stats?.totalLines || 0);
            document.getElementById('cluster-count').textContent = store.stats?.clusters || 0;
        }
        
        function buildLegend() {
            const legend = document.getElementById('legend');
            const stats = getCategoryStats().slice(0, 10);
            
            legend.innerHTML = `
                <div class="legend-title">${t('categories')}</div>
                ${stats.map(({ name, count }) => `
                    <div class="legend-item ${state.categoryFilter === name ? 'active' : ''}" data-cat="${name}">
                        <div class="legend-dot" style="background:${getCategoryColor(name)}"></div>
                        <span class="legend-name">${name}</span>
                        <span class="legend-count">${count}</span>
                    </div>
                `).join('')}
            `;
            
            legend.querySelectorAll('.legend-item').forEach(item => {
                item.addEventListener('click', () => {
                    state.categoryFilter = state.categoryFilter === item.dataset.cat ? null : item.dataset.cat;
                    buildLegend();
                });
            });
        }
        
        function updateBreadcrumbs() {
            const bc = document.getElementById('breadcrumbs');
            const parts = ['root', ...state.treemap.path];
            
            bc.innerHTML = parts.map((p, i) => `
                <span class="breadcrumb ${i === parts.length - 1 ? 'current' : ''}" data-idx="${i}">${p}</span>
                ${i < parts.length - 1 ? '<span class="breadcrumb-sep">/</span>' : ''}
            `).join('');
            
            bc.querySelectorAll('.breadcrumb').forEach(b => {
                b.addEventListener('click', () => {
                    const idx = parseInt(b.dataset.idx);
                    state.treemap.path = state.treemap.path.slice(0, idx);
                    updateBreadcrumbs();
                });
            });
        }
        
        function showTooltip(item, x, y) {
            const tooltip = document.getElementById('tooltip');
            const file = item.file || item;
            
            tooltip.innerHTML = `
                <div class="tooltip-name">${file.name || item.name}</div>
                <div class="tooltip-path">${file.path || item.path}</div>
                <div class="tooltip-meta">
                    <span><strong>${formatNumber(file.lines || item.lines)}</strong> ${t('lines')}</span>
                    <span class="tooltip-category" style="color:${getCategoryColor(file.category || 'Other')}">${file.category || 'Folder'}</span>
                </div>
            `;
            
            tooltip.style.left = (x + 15) + 'px';
            tooltip.style.top = (y + 15) + 'px';
            tooltip.classList.add('visible');
        }
        
        function hideTooltip() {
            document.getElementById('tooltip')?.classList.remove('visible');
        }
        
        function selectFile(file) {
            state.treemap.selected = file;
            state.semantic.selected = file;
            state.highlightedRelated = findSimilarFiles(file, 8).map(s => s.file);
            showSidePanel(file);
        }
        
        function showSidePanel(file) {
            const panel = document.getElementById('side-panel');
            const similar = findSimilarFiles(file, 6);
            
            panel.innerHTML = `
                <div class="panel-header">
                    <div class="panel-title">${t('fileDetails')}</div>
                    <div class="file-name">${file.name}</div>
                    <div class="file-path">${file.path}</div>
                </div>
                <div class="panel-content">
                    <div class="info-section">
                        <div class="info-grid">
                            <div class="info-item">
                                <div class="info-label">${t('lines')}</div>
                                <div class="info-value">${formatNumber(file.lines)}</div>
                            </div>
                            <div class="info-item">
                                <div class="info-label">${t('cluster')}</div>
                                <div class="info-value">#${file.cluster}</div>
                            </div>
                        </div>
                    </div>
                    ${file.summary ? `
                    <div class="info-section">
                        <div class="info-section-title">${t('summary')}</div>
                        <p class="file-summary">${file.summary}</p>
                    </div>
                    ` : ''}
                    ${similar.length ? `
                    <div class="info-section">
                        <div class="info-section-title">${t('similarFiles')}</div>
                        ${similar.map(s => `
                            <div class="similar-file" data-path="${s.file.path}">
                                <div class="similar-score">${Math.round(s.score * 100)}</div>
                                <div class="similar-info">
                                    <div class="similar-name">${s.file.name}</div>
                                    <div class="similar-reason">${s.primaryReason}</div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                    ` : ''}
                </div>
            `;
            
            panel.classList.add('open');
            
            panel.querySelectorAll('.similar-file').forEach(el => {
                el.addEventListener('click', () => {
                    const f = store.files.find(f => f.path === el.dataset.path);
                    if (f) selectFile(f);
                });
            });
        }
        
        function hideSidePanel() {
            document.getElementById('side-panel')?.classList.remove('open');
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PWA
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        let deferredPrompt = null;
        
        function setupPWA() {
            // Register service worker
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('sw.js')
                    .then(reg => console.log('SW registered:', reg.scope))
                    .catch(err => console.log('SW registration failed:', err));
            }
            
            // Install prompt
            window.addEventListener('beforeinstallprompt', e => {
                e.preventDefault();
                deferredPrompt = e;
                document.getElementById('install-prompt')?.classList.add('visible');
            });
            
            document.getElementById('install-btn')?.addEventListener('click', async () => {
                if (!deferredPrompt) return;
                deferredPrompt.prompt();
                const { outcome } = await deferredPrompt.userChoice;
                console.log('Install outcome:', outcome);
                deferredPrompt = null;
                document.getElementById('install-prompt')?.classList.remove('visible');
            });
            
            document.getElementById('install-dismiss')?.addEventListener('click', () => {
                document.getElementById('install-prompt')?.classList.remove('visible');
            });
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // UTILS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function debounce(fn, ms) {
            let timer;
            return (...args) => {
                clearTimeout(timer);
                timer = setTimeout(() => fn(...args), ms);
            };
        }
        
        // Start
        init();
    </script>
</body>
</html>
