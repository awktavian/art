<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="theme-color" content="#06060a">
    <meta name="description" content="Interactive semantic code visualization">
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/svg+xml" href="icon.svg">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500&family=IBM+Plex+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
    <title>Code Galaxy</title>
    <style>
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           DESIGN TOKENS
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        :root {
            --void-900: #020204;
            --void-800: #06060a;
            --void-700: #0c0c14;
            --void-600: #12121a;
            --void-500: #1a1a24;
            --void-400: #24242e;
            
            --text-100: #f5f2eb;
            --text-200: #e0ddd4;
            --text-300: #c8c4ba;
            --text-400: #9a978e;
            --text-500: #7a7870;
            --text-600: #5a5850;
            
            --gold-400: #f8d878;
            --gold-500: #f0c860;
            --gold-600: #d4a840;
            --gold-glow: rgba(240, 200, 96, 0.4);
            
            --border-1: rgba(255, 255, 255, 0.04);
            --border-2: rgba(255, 255, 255, 0.08);
            --border-3: rgba(255, 255, 255, 0.14);
            
            --font-sans: "IBM Plex Sans", system-ui, sans-serif;
            --font-mono: "IBM Plex Mono", "SF Mono", monospace;
            
            --ease-out: cubic-bezier(0.16, 1, 0.3, 1);
            --ease-spring: cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           RESET & BASE
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        
        html, body {
            width: 100%; height: 100%;
            background: var(--void-800);
            color: var(--text-100);
            font-family: var(--font-sans);
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
        }
        
        button { border: none; background: none; cursor: pointer; font: inherit; color: inherit; }
        canvas { display: block; }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           LAYOUT
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        #app {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        
        .header {
            height: 56px;
            display: flex;
            align-items: center;
            gap: 24px;
            padding: 0 24px;
            background: linear-gradient(180deg, var(--void-700) 0%, rgba(6, 6, 10, 0.95) 100%);
            border-bottom: 1px solid var(--border-1);
            z-index: 100;
            flex-shrink: 0;
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 20px;
            font-weight: 600;
            color: var(--gold-500);
            letter-spacing: -0.02em;
        }
        
        .logo-icon {
            font-size: 28px;
            filter: drop-shadow(0 0 12px var(--gold-glow));
            animation: pulse-glow 3s ease-in-out infinite;
        }
        
        @keyframes pulse-glow {
            0%, 100% { filter: drop-shadow(0 0 12px var(--gold-glow)); }
            50% { filter: drop-shadow(0 0 20px var(--gold-glow)); }
        }
        
        .tabs {
            display: flex;
            gap: 4px;
            padding: 4px;
            background: var(--void-600);
            border-radius: 12px;
        }
        
        .tab {
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 500;
            color: var(--text-400);
            transition: all 0.15s var(--ease-out);
        }
        
        .tab:hover { color: var(--text-200); background: var(--void-500); }
        .tab.active { background: var(--gold-500); color: var(--void-900); }
        
        .search {
            flex: 1;
            max-width: 480px;
            position: relative;
        }
        
        .search input {
            width: 100%;
            height: 40px;
            padding: 0 16px 0 44px;
            background: var(--void-600);
            border: 1px solid var(--border-2);
            border-radius: 12px;
            color: var(--text-100);
            font-size: 14px;
            outline: none;
            transition: all 0.15s var(--ease-out);
        }
        
        .search input:focus {
            border-color: var(--gold-500);
            box-shadow: 0 0 0 3px var(--gold-glow);
        }
        
        .search input::placeholder { color: var(--text-500); }
        
        .search::before {
            content: 'âŒ˜K';
            position: absolute;
            left: 14px;
            top: 50%;
            transform: translateY(-50%);
            font: 500 11px var(--font-mono);
            color: var(--text-500);
            pointer-events: none;
        }
        
        .stats {
            display: flex;
            gap: 20px;
            font-size: 13px;
            color: var(--text-400);
        }
        
        .stat-val {
            color: var(--text-100);
            font-weight: 600;
            font-family: var(--font-mono);
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           MAIN CONTENT
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .main {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        .view { 
            display: none; 
            width: 100%; 
            height: 100%; 
            position: absolute;
            inset: 0;
        }
        .view.active { display: block; }
        
        canvas {
            width: 100%;
            height: 100%;
        }
        
        #treemap { cursor: pointer; }
        #semantic { cursor: grab; }
        #semantic:active { cursor: grabbing; }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           LEGEND
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .legend {
            position: absolute;
            top: 16px;
            left: 16px;
            width: 180px;
            padding: 16px;
            background: rgba(12, 12, 20, 0.95);
            backdrop-filter: blur(24px);
            border: 1px solid var(--border-2);
            border-radius: 16px;
            z-index: 50;
        }
        
        .legend-title {
            margin-bottom: 12px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-500);
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 6px 0;
            cursor: pointer;
            opacity: 0.65;
            transition: all 0.15s var(--ease-out);
        }
        
        .legend-item:hover, .legend-item.active { opacity: 1; }
        
        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            flex-shrink: 0;
            box-shadow: 0 0 8px currentColor;
        }
        
        .legend-name { flex: 1; font-size: 13px; color: var(--text-300); }
        .legend-count { font: 500 11px var(--font-mono); color: var(--text-500); }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           SIDE PANEL
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .panel {
            position: absolute;
            top: 0;
            right: 0;
            width: 360px;
            height: 100%;
            background: rgba(12, 12, 20, 0.98);
            backdrop-filter: blur(32px);
            border-left: 1px solid var(--border-2);
            z-index: 60;
            transform: translateX(100%);
            transition: transform 0.35s var(--ease-out);
            display: flex;
            flex-direction: column;
        }
        
        .panel.open { transform: translateX(0); }
        
        .panel-header {
            padding: 24px;
            border-bottom: 1px solid var(--border-1);
            position: relative;
        }
        
        .panel-close {
            position: absolute;
            top: 16px;
            right: 16px;
            width: 32px;
            height: 32px;
            border-radius: 10px;
            background: var(--void-600);
            color: var(--text-400);
            font-size: 18px;
            display: grid;
            place-items: center;
            transition: all 0.15s var(--ease-out);
        }
        
        .panel-close:hover { background: var(--void-500); color: var(--text-100); }
        
        .panel-label {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-500);
            margin-bottom: 8px;
        }
        
        .panel-title {
            font-size: 18px;
            font-weight: 600;
            word-break: break-word;
            line-height: 1.3;
        }
        
        .panel-path {
            font: 12px var(--font-mono);
            color: var(--text-400);
            word-break: break-all;
            margin-top: 6px;
        }
        
        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 24px;
        }
        
        .info-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 24px;
        }
        
        .info-box {
            padding: 14px;
            background: var(--void-600);
            border: 1px solid var(--border-1);
            border-radius: 12px;
        }
        
        .info-box-label { font-size: 11px; color: var(--text-500); margin-bottom: 4px; }
        .info-box-value { font-size: 16px; font-weight: 600; }
        
        .section-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-500);
            margin: 24px 0 12px;
        }
        
        .summary {
            font-size: 14px;
            line-height: 1.7;
            color: var(--text-300);
            font-style: italic;
        }
        
        .similar-item {
            display: flex;
            align-items: center;
            gap: 14px;
            padding: 12px 14px;
            background: var(--void-600);
            border: 1px solid var(--border-1);
            border-radius: 12px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.2s var(--ease-out);
        }
        
        .similar-item:hover {
            background: var(--void-500);
            border-color: var(--border-2);
            transform: translateX(6px);
        }
        
        .similar-score {
            width: 40px;
            height: 40px;
            display: grid;
            place-items: center;
            background: linear-gradient(135deg, var(--gold-400), var(--gold-600));
            border-radius: 10px;
            font: 700 13px var(--font-sans);
            color: var(--void-900);
            flex-shrink: 0;
        }
        
        .similar-info { flex: 1; min-width: 0; }
        .similar-name { font-size: 13px; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .similar-cat { font-size: 11px; margin-top: 2px; }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           CONTROLS
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .controls {
            position: absolute;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 4px;
            padding: 6px;
            background: rgba(12, 12, 20, 0.95);
            backdrop-filter: blur(24px);
            border: 1px solid var(--border-2);
            border-radius: 20px;
            z-index: 50;
        }
        
        .ctrl-btn {
            width: 44px;
            height: 44px;
            border-radius: 14px;
            font-size: 20px;
            color: var(--text-400);
            display: grid;
            place-items: center;
            transition: all 0.15s var(--ease-out);
        }
        
        .ctrl-btn:hover { background: var(--void-600); color: var(--text-100); }
        .ctrl-btn.active { background: var(--gold-500); color: var(--void-900); }
        
        .ctrl-divider {
            width: 1px;
            margin: 6px 4px;
            background: var(--border-2);
        }
        
        .zoom {
            position: absolute;
            bottom: 24px;
            right: 24px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            z-index: 50;
        }
        
        .zoom-btn {
            width: 40px;
            height: 40px;
            background: rgba(12, 12, 20, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid var(--border-2);
            border-radius: 12px;
            font-size: 20px;
            color: var(--text-400);
            display: grid;
            place-items: center;
            transition: all 0.15s var(--ease-out);
        }
        
        .zoom-btn:hover { background: var(--void-500); color: var(--text-100); }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           BREADCRUMBS
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .breadcrumbs {
            position: absolute;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 20px;
            background: rgba(12, 12, 20, 0.95);
            backdrop-filter: blur(24px);
            border: 1px solid var(--border-2);
            border-radius: 14px;
            font-size: 14px;
            z-index: 50;
        }
        
        .crumb { 
            color: var(--text-400); 
            cursor: pointer; 
            transition: all 0.15s var(--ease-out);
            padding: 2px 6px;
            border-radius: 6px;
        }
        .crumb:hover { color: var(--text-100); background: var(--void-600); }
        .crumb.current { color: var(--gold-500); font-weight: 600; }
        .crumb-sep { color: var(--text-600); }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           TOOLTIP
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .tooltip {
            position: fixed;
            max-width: 320px;
            padding: 14px 18px;
            background: rgba(12, 12, 20, 0.98);
            backdrop-filter: blur(24px);
            border: 1px solid var(--border-3);
            border-radius: 14px;
            box-shadow: 0 12px 40px rgba(0,0,0,0.6);
            pointer-events: none;
            opacity: 0;
            transform: translateY(10px) scale(0.95);
            transition: all 0.2s var(--ease-spring);
            z-index: 200;
        }
        
        .tooltip.visible {
            opacity: 1;
            transform: translateY(0) scale(1);
        }
        
        .tt-name { font-size: 15px; font-weight: 600; margin-bottom: 4px; }
        .tt-path { font: 11px var(--font-mono); color: var(--text-500); word-break: break-all; }
        .tt-meta { 
            display: flex; 
            gap: 20px; 
            margin-top: 12px; 
            padding-top: 12px; 
            border-top: 1px solid var(--border-2); 
            font-size: 13px; 
            color: var(--text-400);
        }
        .tt-summary {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border-2);
            font-size: 12px;
            font-style: italic;
            color: var(--text-300);
            line-height: 1.5;
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           LOADING
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        .loading {
            position: fixed;
            inset: 0;
            background: var(--void-800);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.4s var(--ease-out);
        }
        
        .loading.hide { opacity: 0; pointer-events: none; }
        
        .spinner {
            width: 48px;
            height: 48px;
            border: 3px solid var(--void-600);
            border-top-color: var(--gold-500);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }
        
        @keyframes spin { to { transform: rotate(360deg); } }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           RESPONSIVE
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        @media (max-width: 1024px) {
            .header { gap: 16px; padding: 0 16px; }
            .stats { display: none; }
            .panel { width: 320px; }
        }
        
        @media (max-width: 768px) {
            .header { height: 48px; }
            .logo span:not(.logo-icon) { display: none; }
            .tabs { display: none; }
            .panel { width: 100%; }
            .legend { width: 150px; padding: 12px; }
        }
        
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           ACCESSIBILITY
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                transition-duration: 0.01ms !important;
            }
        }
        
        :focus-visible {
            outline: 2px solid var(--gold-500);
            outline-offset: 2px;
        }
    </style>
</head>
<body>
    <div class="loading" id="loading"><div class="spinner"></div></div>
    
    <div id="app">
        <header class="header">
            <div class="logo">
                <span class="logo-icon">â—ˆ</span>
                <span>Code Galaxy</span>
            </div>
            
            <div class="tabs">
                <button class="tab active" data-view="treemap">Treemap</button>
                <button class="tab" data-view="semantic">3D Explorer</button>
            </div>
            
            <div class="search">
                <input type="text" id="search" placeholder="Search files, classes, functions..." autocomplete="off">
            </div>
            
            <div class="stats">
                <span><span class="stat-val" id="file-count">â€”</span> files</span>
                <span><span class="stat-val" id="line-count">â€”</span> lines</span>
            </div>
        </header>
        
        <main class="main">
            <div class="view active" id="treemap-view">
                <canvas id="treemap"></canvas>
                <div class="breadcrumbs" id="breadcrumbs">
                    <span class="crumb current" data-idx="0">root</span>
                </div>
            </div>
            
            <div class="view" id="semantic-view">
                <canvas id="semantic"></canvas>
            </div>
            
            <aside class="legend" id="legend"></aside>
            
            <aside class="panel" id="panel">
                <div class="panel-header">
                    <button class="panel-close" id="panel-close">Ã—</button>
                    <div class="panel-label">File Details</div>
                    <div class="panel-title" id="panel-title">â€”</div>
                    <div class="panel-path" id="panel-path">â€”</div>
                </div>
                <div class="panel-content" id="panel-content"></div>
            </aside>
            
            <nav class="controls" id="controls" style="display: none;">
                <button class="ctrl-btn active" data-preset="orbit" title="Orbit">ğŸŒ</button>
                <button class="ctrl-btn" data-preset="top" title="Top View">â¬‡</button>
                <button class="ctrl-btn" data-preset="front" title="Front View">â¡</button>
                <div class="ctrl-divider"></div>
                <button class="ctrl-btn" data-action="reset" title="Reset">â†º</button>
                <button class="ctrl-btn" data-action="auto" title="Auto Rotate">â–¶</button>
            </nav>
            
            <div class="zoom" id="zoom" style="display: none;">
                <button class="zoom-btn" data-dir="in">+</button>
                <button class="zoom-btn" data-dir="out">âˆ’</button>
            </div>
        </main>
        
        <div class="tooltip" id="tooltip"></div>
    </div>
    
    <script>
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CATEGORY COLORS â€” Vibrant, accessible palette
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        const COLORS = {
            Python:     { h: 220, s: 85, l: 60, hex: '#3b82f6' },
            JavaScript: { h: 48,  s: 95, l: 55, hex: '#facc15' },
            TypeScript: { h: 211, s: 70, l: 52, hex: '#3178c6' },
            React:      { h: 193, s: 95, l: 68, hex: '#61dafb' },
            Rust:       { h: 24,  s: 95, l: 55, hex: '#f97316' },
            Swift:      { h: 8,   s: 85, l: 58, hex: '#f05138' },
            Kotlin:     { h: 256, s: 100,l: 66, hex: '#7f52ff' },
            Go:         { h: 192, s: 75, l: 55, hex: '#00add8' },
            Java:       { h: 20,  s: 85, l: 52, hex: '#f89820' },
            C:          { h: 210, s: 45, l: 55, hex: '#5c8dbc' },
            Config:     { h: 215, s: 20, l: 55, hex: '#64748b' },
            Docs:       { h: 142, s: 70, l: 48, hex: '#22c55e' },
            Test:       { h: 330, s: 80, l: 68, hex: '#f472b6' },
            API:        { h: 260, s: 70, l: 65, hex: '#a78bfa' },
            Core:       { h: 200, s: 80, l: 55, hex: '#0ea5e9' },
            Security:   { h: 0,   s: 75, l: 60, hex: '#ef4444' },
            Shell:      { h: 80,  s: 60, l: 48, hex: '#84cc16' },
            Web:        { h: 290, s: 75, l: 68, hex: '#e879f9' },
            Style:      { h: 330, s: 85, l: 60, hex: '#ec4899' },
            Database:   { h: 35,  s: 90, l: 55, hex: '#f59e0b' },
            Model:      { h: 170, s: 65, l: 48, hex: '#14b8a6' },
            Service:    { h: 240, s: 65, l: 62, hex: '#818cf8' },
            Utility:    { h: 190, s: 55, l: 52, hex: '#22d3ee' },
            Other:      { h: 220, s: 12, l: 50, hex: '#6b7280' },
            Folder:     { h: 35,  s: 35, l: 40, hex: '#8b7355' },
        };
        
        function getColor(cat, alpha = 1) {
            const c = COLORS[cat] || COLORS.Other;
            return alpha === 1 ? c.hex : `hsla(${c.h}, ${c.s}%, ${c.l}%, ${alpha})`;
        }
        
        function getHSL(cat) {
            return COLORS[cat] || COLORS.Other;
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // STATE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        const state = {
            view: 'treemap',
            data: null,
            files: [],
            tree: null,
            
            treemap: {
                path: [],
                hovered: null,
                selected: null,
                cells: [],
            },
            
            semantic: {
                rotX: 0.4,
                rotY: 0,
                zoom: 1.0,
                dragging: false,
                lastX: 0,
                lastY: 0,
                hovered: null,
                selected: null,
                autoRotate: false,
                related: [],
                projected: [],
            },
            
            filter: null,
            query: '',
            tooltipTimer: null,
        };
        
        let treemapCanvas, treemapCtx;
        let semanticCanvas, semanticCtx;
        let dpr = 1;
        let rafId = null;
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // INITIALIZATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        async function init() {
            try {
                const res = await fetch('codebase-analysis.json?v=' + Date.now());
                if (!res.ok) throw new Error('Failed to load data');
                state.data = await res.json();
                state.files = state.data.files || [];
                
                // Use pre-built tree if available, otherwise build it
                if (state.data.tree) {
                    state.tree = state.data.tree;
                } else {
                    buildTree();
                }
                
                treemapCanvas = document.getElementById('treemap');
                semanticCanvas = document.getElementById('semantic');
                treemapCtx = treemapCanvas.getContext('2d');
                semanticCtx = semanticCanvas.getContext('2d');
                
                resize();
                setupEvents();
                updateStats();
                buildLegend();
                
                document.getElementById('loading').classList.add('hide');
                render();
                
            } catch (err) {
                console.error('Init error:', err);
                document.getElementById('loading').innerHTML = 
                    `<div style="color:#ef4444;font-size:14px;text-align:center;">
                        <div style="margin-bottom:8px;">Failed to load</div>
                        <div style="font-size:12px;color:#888;">${err.message}</div>
                    </div>`;
            }
        }
        
        function buildTree() {
            const root = { name: 'root', path: '', lines: 0, isFile: false, children: {} };
            
            for (const f of state.files) {
                if (!f.path) continue;
                const parts = f.path.split('/');
                let node = root;
                
                for (let i = 0; i < parts.length - 1; i++) {
                    const part = parts[i];
                    if (!node.children[part]) {
                        node.children[part] = { 
                            name: part, 
                            path: parts.slice(0, i + 1).join('/'),
                            lines: 0, 
                            isFile: false, 
                            children: {} 
                        };
                    }
                    node = node.children[part];
                }
                
                const fileName = parts[parts.length - 1];
                node.children[fileName] = {
                    name: f.name || fileName,
                    path: f.path,
                    lines: f.lines || 0,
                    isFile: true,
                    file: f,
                    category: f.category || 'Other',
                };
            }
            
            // Calculate folder sizes
            function sumLines(n) {
                if (n.isFile) return n.lines;
                let sum = 0;
                for (const c of Object.values(n.children || {})) {
                    sum += sumLines(c);
                }
                n.lines = sum;
                return sum;
            }
            
            sumLines(root);
            state.tree = root;
        }
        
        function resize() {
            dpr = Math.min(window.devicePixelRatio || 1, 2);
            
            [treemapCanvas, semanticCanvas].forEach(c => {
                if (!c) return;
                const rect = c.parentElement.getBoundingClientRect();
                c.width = rect.width * dpr;
                c.height = rect.height * dpr;
                c.style.width = rect.width + 'px';
                c.style.height = rect.height + 'px';
                c.getContext('2d').setTransform(dpr, 0, 0, dpr, 0, 0);
            });
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // RENDER LOOP
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function render() {
            if (state.view === 'treemap') {
                renderTreemap();
            } else {
                renderSemantic();
            }
            rafId = requestAnimationFrame(render);
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // TREEMAP â€” Proper Squarify Algorithm
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function renderTreemap() {
            if (!treemapCtx || !state.tree) return;
            
            const w = treemapCanvas.width / dpr;
            const h = treemapCanvas.height / dpr;
            const ctx = treemapCtx;
            
            // Background
            ctx.fillStyle = '#04040a';
            ctx.fillRect(0, 0, w, h);
            
            // Navigate to current path
            let node = state.tree;
            for (const seg of state.treemap.path) {
                if (node.children && node.children[seg]) {
                    node = node.children[seg];
                } else {
                    // Invalid path, reset
                    state.treemap.path = [];
                    node = state.tree;
                    break;
                }
            }
            
            // Get children as array
            const children = Object.values(node.children || {}).filter(c => c.lines > 0);
            if (!children.length) return;
            
            // Layout with padding
            const pad = 8;
            state.treemap.cells = squarify(children, pad, pad, w - pad * 2, h - pad * 2);
            
            // Draw cells
            for (const cell of state.treemap.cells) {
                drawTreemapCell(ctx, cell);
            }
        }
        
        // Proper squarify implementation
        function squarify(items, x, y, w, h) {
            if (!items.length || w < 4 || h < 4) return [];
            
            // Sort by lines descending
            const sorted = [...items].sort((a, b) => b.lines - a.lines);
            const total = sorted.reduce((s, c) => s + c.lines, 0);
            if (total === 0) return [];
            
            const cells = [];
            layoutStrip(sorted, x, y, w, h, total, cells);
            return cells;
        }
        
        function layoutStrip(items, x, y, w, h, total, cells) {
            if (!items.length || w < 2 || h < 2) return;
            
            const vertical = h > w;
            const shortSide = vertical ? w : h;
            
            // Find best row
            let row = [];
            let rowSum = 0;
            let bestRatio = Infinity;
            
            for (let i = 0; i < items.length; i++) {
                const testRow = [...row, items[i]];
                const testSum = rowSum + items[i].lines;
                const ratio = worstRatio(testRow, testSum, shortSide, total);
                
                if (ratio <= bestRatio) {
                    row = testRow;
                    rowSum = testSum;
                    bestRatio = ratio;
                } else {
                    break;
                }
            }
            
            // Layout row
            const rowFrac = rowSum / total;
            const rowSize = vertical ? h * rowFrac : w * rowFrac;
            
            let offset = 0;
            for (const item of row) {
                const itemFrac = item.lines / rowSum;
                const itemSize = shortSide * itemFrac;
                
                const gap = 2;
                let cx, cy, cw, ch;
                
                if (vertical) {
                    cx = x + offset;
                    cy = y;
                    cw = itemSize - gap;
                    ch = rowSize - gap;
                } else {
                    cx = x;
                    cy = y + offset;
                    cw = rowSize - gap;
                    ch = itemSize - gap;
                }
                
                if (cw > 2 && ch > 2) {
                    cells.push({ node: item, x: cx, y: cy, w: cw, h: ch });
                }
                
                offset += itemSize;
            }
            
            // Recurse with remaining items
            const remaining = items.slice(row.length);
            if (remaining.length) {
                const newTotal = total - rowSum;
                if (vertical) {
                    layoutStrip(remaining, x, y + rowSize, w, h - rowSize, newTotal, cells);
                } else {
                    layoutStrip(remaining, x + rowSize, y, w - rowSize, h, newTotal, cells);
                }
            }
        }
        
        function worstRatio(row, rowSum, side, total) {
            if (!row.length || rowSum === 0 || total === 0) return Infinity;
            
            const rowFrac = rowSum / total;
            const rowSize = side * rowFrac;
            if (rowSize === 0) return Infinity;
            
            let worst = 0;
            for (const item of row) {
                const itemFrac = item.lines / rowSum;
                const itemSize = side * itemFrac;
                if (itemSize === 0) continue;
                
                const ratio = Math.max(rowSize / itemSize, itemSize / rowSize);
                worst = Math.max(worst, ratio);
            }
            
            return worst;
        }
        
        function drawTreemapCell(ctx, { node, x, y, w, h }) {
            if (w < 2 || h < 2 || !isFinite(w) || !isFinite(h)) return;
            
            const hov = state.treemap.hovered === node;
            const sel = state.treemap.selected === node;
            const cat = node.category || node.file?.category || (node.isFile ? 'Other' : 'Folder');
            const c = getHSL(cat);
            
            // Calculate corner radius safely
            const r = Math.max(0, Math.min(8, Math.min(w, h) / 4));
            
            // Folders get more visible treatment
            const isFolder = !node.isFile;
            const baseAlpha = isFolder ? 0.55 : 0.85;
            const endAlpha = isFolder ? 0.45 : 0.75;
            
            // Fill with gradient
            const grad = ctx.createLinearGradient(x, y, x + w, y + h);
            grad.addColorStop(0, `hsla(${c.h}, ${c.s}%, ${c.l + 10}%, ${baseAlpha})`);
            grad.addColorStop(1, `hsla(${c.h}, ${c.s}%, ${c.l - 8}%, ${endAlpha})`);
            
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.roundRect(x, y, w, h, r);
            ctx.fill();
            
            // Always draw subtle border for definition
            ctx.strokeStyle = `hsla(${c.h}, ${c.s}%, ${Math.min(90, c.l + 25)}%, ${isFolder ? 0.35 : 0.25})`;
            ctx.lineWidth = 1;
            ctx.stroke();
            
            // Hover/selection effects
            if (hov || sel) {
                ctx.strokeStyle = sel ? '#f0c860' : 'rgba(255,255,255,0.7)';
                ctx.lineWidth = sel ? 3 : 2;
                ctx.stroke();
                
                if (sel) {
                    ctx.shadowColor = 'rgba(240, 200, 96, 0.6)';
                    ctx.shadowBlur = 24;
                    ctx.strokeStyle = '#f0c860';
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
            }
            
            // Label - scale with cell size
            if (w > 60 && h > 28) {
                const prefix = isFolder ? 'ğŸ“ ' : '';
                
                // Large folders get extra prominent labels
                const isLarge = w > 200 && h > 200;
                const fontSize = isLarge ? 18 : (isFolder && w > 150 ? 15 : 13);
                
                // Draw text shadow for better visibility
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.font = `600 ${fontSize}px "IBM Plex Sans", sans-serif`;
                
                const maxChars = Math.floor((w - 24) / (fontSize * 0.6));
                let label = prefix + node.name;
                if (label.length > maxChars) {
                    label = label.slice(0, maxChars - 1) + 'â€¦';
                }
                
                // Shadow
                ctx.fillText(label, x + 13, y + (isLarge ? 30 : 23));
                // Main text
                ctx.fillStyle = '#f5f2eb';
                ctx.fillText(label, x + 12, y + (isLarge ? 29 : 22));
                
                // Lines count
                if (h > 44) {
                    const lineY = isLarge ? 52 : 40;
                    ctx.fillStyle = 'rgba(0,0,0,0.5)';
                    ctx.font = `500 ${isLarge ? 13 : 11}px "IBM Plex Mono", monospace`;
                    ctx.fillText(formatNum(node.lines) + ' lines', x + 13, y + lineY + 1);
                    ctx.fillStyle = '#c0bdb5';
                    ctx.fillText(formatNum(node.lines) + ' lines', x + 12, y + lineY);
                }
            } else if (w > 35 && h > 20) {
                // Small label with shadow
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.font = '500 10px "IBM Plex Sans", sans-serif';
                const short = node.name.slice(0, 4);
                ctx.fillText(short, x + 5, y + 15);
                ctx.fillStyle = 'rgba(255,255,255,0.9)';
                ctx.fillText(short, x + 4, y + 14);
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // 3D SEMANTIC EXPLORER â€” Immersive Perspective
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function renderSemantic() {
            if (!semanticCtx || !state.files.length) return;
            
            const w = semanticCanvas.width / dpr;
            const h = semanticCanvas.height / dpr;
            const ctx = semanticCtx;
            const cx = w / 2;
            const cy = h / 2;
            
            // Deep space background
            const bgGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, Math.hypot(w, h) * 0.7);
            bgGrad.addColorStop(0, '#0a0a18');
            bgGrad.addColorStop(0.3, '#060612');
            bgGrad.addColorStop(0.6, '#040408');
            bgGrad.addColorStop(1, '#020204');
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, w, h);
            
            // Star field for depth
            ctx.fillStyle = 'rgba(255,255,255,0.08)';
            for (let i = 0; i < 150; i++) {
                const sx = seededRandom(i * 7) * w;
                const sy = seededRandom(i * 13 + 1000) * h;
                const size = 0.3 + seededRandom(i * 17 + 2000) * 0.8;
                ctx.beginPath();
                ctx.arc(sx, sy, size, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Filter files
            let files = state.files.filter(f => 
                f.x !== undefined && f.y !== undefined && f.z !== undefined &&
                isFinite(f.x) && isFinite(f.y) && isFinite(f.z)
            );
            
            if (state.filter) {
                files = files.filter(f => f.category === state.filter);
            }
            if (state.query) {
                const q = state.query.toLowerCase();
                files = files.filter(f => 
                    (f.path && f.path.toLowerCase().includes(q)) || 
                    (f.name && f.name.toLowerCase().includes(q))
                );
            }
            
            // Camera parameters for STRONG perspective
            const fov = 1.2;
            const cameraZ = 2.0;
            const scale = Math.min(w, h) * 0.85 * state.semantic.zoom;
            
            // Project all files to 2D
            const projected = [];
            
            for (const f of files) {
                // Normalize to -1..1 centered
                let px = (f.x - 0.5) * 2;
                let py = (f.y - 0.5) * 2;
                let pz = (f.z - 0.5) * 2;
                
                // Rotate around Y axis
                const cosY = Math.cos(state.semantic.rotY);
                const sinY = Math.sin(state.semantic.rotY);
                const x1 = px * cosY - pz * sinY;
                const z1 = px * sinY + pz * cosY;
                
                // Rotate around X axis
                const cosX = Math.cos(state.semantic.rotX);
                const sinX = Math.sin(state.semantic.rotX);
                const y1 = py * cosX - z1 * sinX;
                const z2 = py * sinX + z1 * cosX;
                
                // Perspective projection
                const depth = fov / (fov + z2 + cameraZ);
                if (depth <= 0 || !isFinite(depth)) continue;
                
                projected.push({
                    file: f,
                    sx: cx + x1 * scale * depth,
                    sy: cy + y1 * scale * depth,
                    sz: z2,
                    depth: depth,
                });
            }
            
            // Sort back to front for proper occlusion
            projected.sort((a, b) => a.sz - b.sz);
            state.semantic.projected = projected;
            
            // Draw connections for selected file
            if (state.semantic.selected && state.semantic.related.length) {
                const selP = projected.find(p => p.file === state.semantic.selected);
                if (selP) {
                    for (const relFile of state.semantic.related) {
                        const relP = projected.find(p => p.file === relFile);
                        if (relP) {
                            const grad = ctx.createLinearGradient(selP.sx, selP.sy, relP.sx, relP.sy);
                            grad.addColorStop(0, 'rgba(240, 200, 96, 0.7)');
                            grad.addColorStop(0.5, 'rgba(240, 200, 96, 0.3)');
                            grad.addColorStop(1, 'rgba(240, 200, 96, 0.1)');
                            
                            ctx.beginPath();
                            ctx.moveTo(selP.sx, selP.sy);
                            ctx.lineTo(relP.sx, relP.sy);
                            ctx.strokeStyle = grad;
                            ctx.lineWidth = 2;
                            ctx.stroke();
                        }
                    }
                }
            }
            
            // Draw nodes
            for (const p of projected) {
                drawNode(ctx, p);
            }
            
            // Auto rotate
            if (state.semantic.autoRotate && !state.semantic.dragging) {
                state.semantic.rotY += 0.003;
            }
        }
        
        function drawNode(ctx, { file, sx, sy, sz, depth }) {
            const hov = state.semantic.hovered === file;
            const sel = state.semantic.selected === file;
            const rel = state.semantic.related.includes(file);
            
            // Size based on importance and depth
            const baseSize = 3 + Math.sqrt(file.lines || 1) * 0.15 + (file.importance || 0) * 8;
            const depthScale = 0.5 + depth * 0.8;
            let size = baseSize * depthScale;
            
            // Interactive states
            if (hov) size *= 1.4;
            if (sel) size *= 1.6;
            
            // Alpha based on depth
            const alpha = Math.max(0.25, Math.min(1, 0.3 + depth * 0.8));
            
            const cat = file.category || 'Other';
            const color = getHSL(cat);
            
            // Glow for interactive states
            if (sel || hov || rel) {
                const glowSize = size * (sel ? 4 : hov ? 3 : 2.5);
                const glow = ctx.createRadialGradient(sx, sy, 0, sx, sy, glowSize);
                glow.addColorStop(0, `hsla(${color.h}, ${color.s}%, ${color.l}%, ${sel ? 0.6 : 0.4})`);
                glow.addColorStop(0.4, `hsla(${color.h}, ${color.s}%, ${color.l}%, ${sel ? 0.25 : 0.15})`);
                glow.addColorStop(1, 'transparent');
                ctx.fillStyle = glow;
                ctx.beginPath();
                ctx.arc(sx, sy, glowSize, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Main node
            ctx.beginPath();
            ctx.arc(sx, sy, size, 0, Math.PI * 2);
            ctx.fillStyle = `hsla(${color.h}, ${color.s}%, ${color.l}%, ${alpha})`;
            ctx.fill();
            
            // Bright core for larger nodes
            if (size > 4) {
                ctx.beginPath();
                ctx.arc(sx, sy, size * 0.35, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.85})`;
                ctx.fill();
            }
            
            // Label for selected/hovered
            if ((sel || hov) && size > 4) {
                const label = file.name || file.path.split('/').pop();
                ctx.font = '600 12px "IBM Plex Sans", sans-serif';
                ctx.textAlign = 'center';
                ctx.fillStyle = '#f5f2eb';
                ctx.fillText(label, sx, sy - size - 10);
                ctx.textAlign = 'left';
            }
        }
        
        // Seeded random for consistent star field
        function seededRandom(seed) {
            const x = Math.sin(seed) * 10000;
            return x - Math.floor(x);
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // EVENT HANDLERS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function setupEvents() {
            window.addEventListener('resize', debounce(resize, 100));
            
            // View tabs
            document.querySelectorAll('.tab').forEach(t => {
                t.addEventListener('click', () => switchView(t.dataset.view));
            });
            
            // Treemap events
            treemapCanvas.addEventListener('mousemove', onTreemapMove);
            treemapCanvas.addEventListener('click', onTreemapClick);
            treemapCanvas.addEventListener('mouseleave', () => {
                state.treemap.hovered = null;
                hideTooltip();
            });
            
            // Semantic 3D events
            semanticCanvas.addEventListener('mousedown', onSemanticDown);
            semanticCanvas.addEventListener('mousemove', onSemanticMove);
            semanticCanvas.addEventListener('mouseup', () => {
                state.semantic.dragging = false;
                semanticCanvas.style.cursor = 'grab';
            });
            semanticCanvas.addEventListener('mouseleave', () => {
                state.semantic.dragging = false;
                state.semantic.hovered = null;
                hideTooltip();
            });
            semanticCanvas.addEventListener('wheel', onSemanticWheel, { passive: false });
            semanticCanvas.addEventListener('click', onSemanticClick);
            
            // Controls
            document.querySelectorAll('.ctrl-btn').forEach(b => {
                b.addEventListener('click', () => onControl(b));
            });
            
            document.querySelectorAll('.zoom-btn').forEach(b => {
                b.addEventListener('click', () => {
                    const delta = b.dataset.dir === 'in' ? 1.25 : 0.8;
                    state.semantic.zoom = Math.max(0.3, Math.min(4, state.semantic.zoom * delta));
                });
            });
            
            // Search
            const searchInput = document.getElementById('search');
            searchInput.addEventListener('input', debounce(e => {
                state.query = e.target.value;
            }, 150));
            
            // Panel close
            document.getElementById('panel-close').addEventListener('click', closePanel);
            
            // Keyboard
            document.addEventListener('keydown', e => {
                if (e.key === 'Escape') closePanel();
                if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
                    e.preventDefault();
                    searchInput.focus();
                }
                if (e.key === 'Backspace' && state.view === 'treemap' && state.treemap.path.length && document.activeElement !== searchInput) {
                    e.preventDefault();
                    state.treemap.path.pop();
                    updateBreadcrumbs();
                }
            });
        }
        
        function switchView(view) {
            state.view = view;
            document.querySelectorAll('.tab').forEach(t => t.classList.toggle('active', t.dataset.view === view));
            document.querySelectorAll('.view').forEach(v => v.classList.toggle('active', v.id === view + '-view'));
            
            const is3D = view === 'semantic';
            document.getElementById('controls').style.display = is3D ? 'flex' : 'none';
            document.getElementById('zoom').style.display = is3D ? 'flex' : 'none';
            document.getElementById('breadcrumbs').style.display = is3D ? 'none' : 'flex';
        }
        
        function onTreemapMove(e) {
            const rect = treemapCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            state.treemap.hovered = null;
            
            // Find hovered cell (reverse order for front-to-back)
            for (let i = state.treemap.cells.length - 1; i >= 0; i--) {
                const cell = state.treemap.cells[i];
                if (x >= cell.x && x <= cell.x + cell.w && y >= cell.y && y <= cell.y + cell.h) {
                    state.treemap.hovered = cell.node;
                    break;
                }
            }
            
            if (state.treemap.hovered) {
                showTooltip(state.treemap.hovered, e.clientX, e.clientY);
                treemapCanvas.style.cursor = 'pointer';
            } else {
                hideTooltip();
                treemapCanvas.style.cursor = 'default';
            }
        }
        
        function onTreemapClick() {
            const node = state.treemap.hovered;
            if (!node) return;
            
            if (node.isFile && node.file) {
                selectFile(node.file);
            } else if (!node.isFile && node.children) {
                state.treemap.path.push(node.name);
                updateBreadcrumbs();
            }
        }
        
        function onSemanticDown(e) {
            state.semantic.dragging = true;
            state.semantic.lastX = e.clientX;
            state.semantic.lastY = e.clientY;
            semanticCanvas.style.cursor = 'grabbing';
        }
        
        function onSemanticMove(e) {
            if (state.semantic.dragging) {
                const dx = e.clientX - state.semantic.lastX;
                const dy = e.clientY - state.semantic.lastY;
                state.semantic.rotY += dx * 0.006;
                state.semantic.rotX += dy * 0.006;
                state.semantic.rotX = Math.max(-Math.PI * 0.48, Math.min(Math.PI * 0.48, state.semantic.rotX));
                state.semantic.lastX = e.clientX;
                state.semantic.lastY = e.clientY;
            } else {
                const rect = semanticCanvas.getBoundingClientRect();
                const mx = e.clientX - rect.left;
                const my = e.clientY - rect.top;
                
                state.semantic.hovered = findNodeAt(mx, my);
                
                if (state.semantic.hovered) {
                    showTooltip(state.semantic.hovered, e.clientX, e.clientY);
                    semanticCanvas.style.cursor = 'pointer';
                } else {
                    hideTooltip();
                    semanticCanvas.style.cursor = 'grab';
                }
            }
        }
        
        function onSemanticWheel(e) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            state.semantic.zoom = Math.max(0.3, Math.min(4, state.semantic.zoom * delta));
        }
        
        function onSemanticClick(e) {
            if (state.semantic.dragging) return;
            
            if (state.semantic.hovered) {
                selectFile(state.semantic.hovered);
            } else {
                // Click on empty space - deselect
                closePanel();
            }
        }
        
        function onControl(btn) {
            const preset = btn.dataset.preset;
            const action = btn.dataset.action;
            
            if (preset) {
                document.querySelectorAll('.ctrl-btn[data-preset]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                if (preset === 'orbit') { state.semantic.rotX = 0.4; state.semantic.rotY = 0; }
                else if (preset === 'top') { state.semantic.rotX = Math.PI / 2 - 0.1; state.semantic.rotY = 0; }
                else if (preset === 'front') { state.semantic.rotX = 0; state.semantic.rotY = 0; }
            }
            
            if (action === 'reset') {
                state.semantic.rotX = 0.4;
                state.semantic.rotY = 0;
                state.semantic.zoom = 1.0;
            }
            
            if (action === 'auto') {
                state.semantic.autoRotate = !state.semantic.autoRotate;
                btn.classList.toggle('active', state.semantic.autoRotate);
            }
        }
        
        function findNodeAt(mx, my) {
            // Search from front to back (reverse of draw order)
            const projected = state.semantic.projected;
            for (let i = projected.length - 1; i >= 0; i--) {
                const p = projected[i];
                const baseSize = 3 + Math.sqrt(p.file.lines || 1) * 0.15 + (p.file.importance || 0) * 8;
                const depthScale = 0.5 + p.depth * 0.8;
                const size = baseSize * depthScale;
                const hitRadius = Math.max(12, size * 1.5);
                
                const dist = Math.hypot(p.sx - mx, p.sy - my);
                if (dist < hitRadius) {
                    return p.file;
                }
            }
            return null;
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // UI HELPERS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function updateStats() {
            document.getElementById('file-count').textContent = formatNum(state.files.length);
            const totalLines = state.files.reduce((s, f) => s + (f.lines || 0), 0);
            document.getElementById('line-count').textContent = formatNum(totalLines);
        }
        
        function buildLegend() {
            const counts = {};
            for (const f of state.files) {
                const cat = f.category || 'Other';
                counts[cat] = (counts[cat] || 0) + 1;
            }
            
            const sorted = Object.entries(counts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 12);
            
            const legend = document.getElementById('legend');
            legend.innerHTML = `
                <div class="legend-title">Categories</div>
                ${sorted.map(([name, count]) => `
                    <div class="legend-item ${state.filter === name ? 'active' : ''}" data-cat="${name}">
                        <div class="legend-dot" style="background:${getColor(name)};color:${getColor(name)}"></div>
                        <span class="legend-name">${name}</span>
                        <span class="legend-count">${count}</span>
                    </div>
                `).join('')}
            `;
            
            legend.querySelectorAll('.legend-item').forEach(el => {
                el.addEventListener('click', () => {
                    state.filter = state.filter === el.dataset.cat ? null : el.dataset.cat;
                    buildLegend();
                });
            });
        }
        
        function updateBreadcrumbs() {
            const parts = ['root', ...state.treemap.path];
            const bc = document.getElementById('breadcrumbs');
            bc.innerHTML = parts.map((p, i) => `
                <span class="crumb ${i === parts.length - 1 ? 'current' : ''}" data-idx="${i}">${p}</span>
                ${i < parts.length - 1 ? '<span class="crumb-sep">/</span>' : ''}
            `).join('');
            
            bc.querySelectorAll('.crumb').forEach(el => {
                el.addEventListener('click', () => {
                    const idx = parseInt(el.dataset.idx);
                    state.treemap.path = state.treemap.path.slice(0, idx);
                    updateBreadcrumbs();
                });
            });
        }
        
        function showTooltip(item, x, y) {
            clearTimeout(state.tooltipTimer);
            
            const t = document.getElementById('tooltip');
            const file = item.file || item;
            const cat = file.category || item.category || 'Other';
            
            // Phase 1: Basic info immediately
            t.innerHTML = `
                <div class="tt-name">${file.name || item.name}</div>
                <div class="tt-path">${file.path || item.path}</div>
                <div class="tt-meta">
                    <span><strong>${formatNum(file.lines || item.lines)}</strong> lines</span>
                    <span style="color:${getColor(cat)}">${cat}</span>
                </div>
            `;
            
            // Position
            const pad = 16;
            t.style.left = Math.min(x + pad, window.innerWidth - 340) + 'px';
            t.style.top = Math.min(y + pad, window.innerHeight - 150) + 'px';
            t.classList.add('visible');
            
            // Phase 2: Show summary after delay if available
            if (file.summary) {
                state.tooltipTimer = setTimeout(() => {
                    t.innerHTML += `<div class="tt-summary">${file.summary}</div>`;
                }, 800);
            }
        }
        
        function hideTooltip() {
            clearTimeout(state.tooltipTimer);
            document.getElementById('tooltip').classList.remove('visible');
        }
        
        function selectFile(file) {
            if (!file || typeof file !== 'object') return;
            if (!file.path) return;
            
            state.treemap.selected = file;
            state.semantic.selected = file;
            state.semantic.related = findSimilar(file, 8);
            
            showPanel(file);
        }
        
        function findSimilar(file, limit = 5) {
            if (!file || file.x === undefined || file.y === undefined || file.z === undefined) return [];
            
            const results = [];
            
            for (const f of state.files) {
                if (f === file) continue;
                if (f.x === undefined || f.y === undefined || f.z === undefined) continue;
                
                const dist = Math.sqrt(
                    (f.x - file.x) ** 2 +
                    (f.y - file.y) ** 2 +
                    (f.z - file.z) ** 2
                );
                
                let score = Math.max(0, 1 - dist * 1.2);
                
                // Boost for same cluster
                if (f.cluster !== undefined && f.cluster === file.cluster) {
                    score += 0.2;
                }
                
                // Boost for same category
                if (f.category === file.category) {
                    score += 0.1;
                }
                
                if (score > 0.15) {
                    results.push({ file: f, score, dist });
                }
            }
            
            return results
                .sort((a, b) => b.score - a.score)
                .slice(0, limit)
                .map(r => r.file);
        }
        
        function showPanel(file) {
            document.getElementById('panel-title').textContent = file.name || file.path.split('/').pop();
            document.getElementById('panel-path').textContent = file.path;
            
            const similar = findSimilar(file, 6);
            
            document.getElementById('panel-content').innerHTML = `
                <div class="info-grid">
                    <div class="info-box">
                        <div class="info-box-label">Lines</div>
                        <div class="info-box-value">${formatNum(file.lines || 0)}</div>
                    </div>
                    <div class="info-box">
                        <div class="info-box-label">Category</div>
                        <div class="info-box-value" style="color:${getColor(file.category)}">${file.category || 'Other'}</div>
                    </div>
                    <div class="info-box">
                        <div class="info-box-label">Cluster</div>
                        <div class="info-box-value">#${file.cluster ?? 'â€”'}</div>
                    </div>
                    <div class="info-box">
                        <div class="info-box-label">Importance</div>
                        <div class="info-box-value">${file.importance ? (file.importance * 100).toFixed(0) + '%' : 'â€”'}</div>
                    </div>
                </div>
                
                ${file.summary ? `
                    <div class="section-title">AI Summary</div>
                    <p class="summary">${file.summary}</p>
                ` : ''}
                
                ${similar.length ? `
                    <div class="section-title">Similar Files</div>
                    ${similar.map(s => {
                        const dist = Math.sqrt(
                            (s.x - file.x) ** 2 + (s.y - file.y) ** 2 + (s.z - file.z) ** 2
                        );
                        const score = Math.max(0, Math.round((1 - dist) * 100));
                        return `
                            <div class="similar-item" data-path="${s.path}">
                                <div class="similar-score">${score}</div>
                                <div class="similar-info">
                                    <div class="similar-name">${s.name || s.path.split('/').pop()}</div>
                                    <div class="similar-cat" style="color:${getColor(s.category)}">${s.category || 'Other'}</div>
                                </div>
                            </div>
                        `;
                    }).join('')}
                ` : ''}
            `;
            
            document.querySelectorAll('.similar-item').forEach(el => {
                el.addEventListener('click', () => {
                    const f = state.files.find(f => f.path === el.dataset.path);
                    if (f) selectFile(f);
                });
            });
            
            document.getElementById('panel').classList.add('open');
        }
        
        function closePanel() {
            document.getElementById('panel').classList.remove('open');
            state.treemap.selected = null;
            state.semantic.selected = null;
            state.semantic.related = [];
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // UTILITIES
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function formatNum(n) {
            if (n >= 1000000) return (n / 1000000).toFixed(1) + 'M';
            if (n >= 1000) return (n / 1000).toFixed(1) + 'K';
            return new Intl.NumberFormat().format(n);
        }
        
        function debounce(fn, ms) {
            let t;
            return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); };
        }
        
        // Service worker registration for PWA
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js').catch(() => {});
        }
        
        // Start
        init();
    </script>
</body>
</html>
